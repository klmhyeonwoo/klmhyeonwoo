{
	"feed-5": {
		"title": "Docker Mysql 테스트서버 DB분리",
		"link": "https://minwoo-it-factory.tistory.com/entry/Docker-Mysql-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%84%9C%EB%B2%84-DB%EB%B6%84%EB%A6%AC",
		"description": "<h3 id=\"%EB%AA%A-%EC%B-%A-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">목차</span></h3>\n<p style=\"background-color: #ffffff; color: #000000; text-align: left;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot;<span><span><span>&nbsp;</span>개요</span></span></span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 환경분리 Spring boot dev,prod 파일</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot; 결론</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<h4 style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">개요</span></b></h4>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>인턴 프로젝트를 진행하면서 Staging 별 Spring서버가 분리되면서 DB도 분리해야 했다.</span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>각각 DB가 다 다르게 담겨야하는데 어떻게할지 찾아보다 간단해서 바로 블로그로 옮기게 됐습니다</span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<h3 style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">환경분리 Spring boot dev,prod 파일</span></b></h3>\n<p><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">방법 1&nbsp;</span></b></p>\n<p><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">Docker Mysql dev , Prod 각각 띄우기</span></b></p>\n<pre class=\"bash\" style=\"background-color: #263238; color: #eeffff; text-align: start;\"><code>spring:\n  profiles:\n    active: dev\n    include: test\n\n  datasource:\n    url: jdbc:mysql://dev-mysql:3306/testdb?characterEncoding=UTF-8\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: create</code></pre>\n<p>&nbsp;</p>\n<pre class=\"bash\" style=\"background-color: #263238; color: #eeffff; text-align: start;\"><code>spring:\n  profiles:\n    active: prod\n    include: test\n\n  datasource:\n    url: jdbc:mysql://mysql-prod:3306/testdb?characterEncoding=UTF-8\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: create</code></pre>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">방법 2</span></b></p>\n<p style=\"color: #333333; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">Docker DB명만 바꾸기</span></b></p>\n<pre class=\"bash\" style=\"background-color: #263238; color: #eeffff; text-align: start;\"><code>spring:\n  profiles:\n    active: dev\n    include: test\n\n  datasource:\n    url: jdbc:mysql://containername:3306/testdb-dev?characterEncoding=UTF-8\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: create</code></pre>\n<p>&nbsp;</p>\n<pre class=\"bash\" style=\"background-color: #263238; color: #eeffff; text-align: start;\"><code>spring:\n  profiles:\n    active: prod\n    include: test\n\n  datasource:\n    url: jdbc:mysql://containername:3306/testdb-prod?characterEncoding=UTF-8\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: create</code></pre>\n<p>&nbsp;</p>\n<h4 style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">결론</span></b></h4>\n<p><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>if(인스턴스 메모리가 넉넉하다 ){</span></span><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>클라우드 네이트브 환경에서 인스턴스의 메모리가 넉넉하다면 Container2개 띄워서 사용하면 될 것 같다.</span></span><br /></span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>}else{</span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>&nbsp; &nbsp; &nbsp; DB명만 다르게해서 매핑시켜 사용</span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span>}</span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>",
		"date": "Jun 07, 2024",
		"writer": "11기 김민우"
	},
	"feed-6": {
		"title": "Statement보다 PreparedStatement를 사용해야하는이유",
		"link": "https://minwoo-it-factory.tistory.com/entry/Statement%EB%B3%B4%EB%8B%A4-PreparedStatement%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EC%9D%B4%EC%9C%A0",
		"description": "<h3 id=\"%EB%AA%A-%EC%B-%A-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">목차</span></h3>\n<p style=\"background-color: #ffffff; color: #000000; text-align: left;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot;<span><span> 개요</span></span></span></span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; Statement, PreparedState 동작방식</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; Statement,PreparedState 차이점</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot; 결론</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">개요</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">&middot;<span> </span></span>Statement 종류에는 Statement,PreparedStatemennt,CallableStatement 3가지가 존재한다.</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; CallableStatement는 PL/SQL문을 호출할 때 사용한다고 했지만 성능상 이슈로 인해 거의 사용하지 않는다.</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 실무에서는 Statement를 사용하지않고 PreparedStatement를 사용한다고하는데 왜 그런지 이유를 알아보자.</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">Statement, PreparedState 동작방식</span></b></span></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/cmR7zJ/btsHRtLFdAn/OKQagBkSTqIkprREQPp91k/img.png\" /></span></figure>\n</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">동작방식</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">1. 구문 분석(Parsing) 및 정규화(Normalization)</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">- Query 문법 확인 및 데이터베이스, 테이블 존재여부 확인</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">2. 컴파일(Compliation)</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">- Query 컴파일</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">3. Query 최적화(Query Optimization Phase)</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">- Query 실행 방법의 최적 계획 선택</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">4. 캐시(Cache)</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">- Query 최적화 단계에서 선택된 계획이 캐시에 저장되어 동일한 Query 실행 시 . 1~3 단계를 실행하지 않고 캐시를&nbsp;</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">통해 찾는다.</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">5. 실행(Execution Phase)</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">- Quer가 실행된 값이 담긴 객체(ResultSet)를 사용자에게 반환</span></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">Statement vs PreparedStatement 차이점</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">캐시 사용 유무(재사용성)</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">- Statement는 매번 Query 실행 시 마다, 1번에서 5번까지의 과정을 반복하며 , Prepared Statment 는 최초</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">Query 실행 시 ,1~5번까지의 과정을 하지만 두번 째 Query 실행 부터는 1번부터 3번까지의 과정을 생략하고 4번부터 시작한다.</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">SQL Injection 방지(보안성)</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\"><b><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">- Prepared Statment 방식을 사용하면 SQL Injection 공격 또한 방지할 수 있다.</span></b></p>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>\n<pre class=\"bash\" id=\"code_1717654815375\"><code>[기존 Statement 방식]\nConnection conn = DriverManager.getConnection(url, id, pwd);\nStatement stmt = conn.createStatement();\nstmt.executeQuery(\"Select * from Member Where id = \" + id + \" and pwd = \" + pwd);\n\n&rarr; 로그인 시, 사용자에게서 입력받은 값을 Where 조건절에 넣어주어 조회하는 Query이지만 만약, 다음과 같이 공격자가 파라미터 값을 악의적으로 조작해서 보낼 수도 있다.\n\n[사용자에게서 입력받은 값]\nid = test123\npwd = 1234&rsquo; or 1=1\n\nQuery = Select * from Member Where id = &lsquo;test123&rsquo; and pwd = &lsquo;1234&rsquo; OR &lsquo;1&rsquo; = &lsquo;1&rsquo;;\n\n&rarr; 이처럼 공격자가 악의적으로 파라미터 값을 조작하여 &ldquo;OR 1=1&rdquo; 조건을 추가하는 방법으로 사용자 정보를 탈취할 수 있다.\n\n[PreparedStatment 방식]\nConnection conn = DriverManager.getConnection(url, id, pwd);\nString sql = \"Select * from Member Where id = ? and pwd = ?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setString(1, id);\npstmt.setString(2, pwd);\npstmt.executeQuery();\n\n&rarr; PreparedStatment 방식은 사용자에게서 받은 파라미터 값이 악의적으로 조작되었다 하더라도 파라미터 바인딩을 통해 SQL Injection을 방지할 수 있다.\n\n&rarr; 정확히는 pstmt.setString() 메소드 내부에서 사용되는 javaEncode() 메소드가 SQL Injection을 방지해주는데 내부 구현이 어떻게 되어있는지 살펴보자! \n\n[javaEncode() 메소드]\npublic static void javaEncode(String s, StringBuilder buff, boolean forSQL) {\n    int length = s.length();\n\n    for (int i = 0, i &lt; length; i++) {\n        char c = s.charAt(i);\n\n        switch (c) { \n            case &lsquo;\\t&rsquo;:\n                buff.append(&ldquo;\\\\t&rdquo;);\n                break;\n            case &lsquo;\\n&rsquo;:\n                buff.append(&ldquo;\\\\n&rdquo;);\n                break;\n            case &lsquo;\\f&rsquo;:\n                buff.append(&ldquo;\\\\f&rdquo;);\n                break;\n            case &lsquo;&ldquo;&rsquo;;\n                buff.append(&lsquo;\\&rsquo;&rsquo;);\n                break;\n                ...\n        }\n    }\n}\n\n&rarr; 이처럼 공격자가 악의적으로 조작한 파라미터 값에 &ldquo;\\&rdquo;를 붙여줌으로써 SQL Injection을 방지할 수 있는 것이다.\n출처: https://shuu.tistory.com/129#(3) Statement vs PreparedStatement 차이점-1 [All about IT:티스토리]</code></pre>\n<p style=\"background-color: #ffffff; color: #555555; text-align: start;\">&nbsp;</p>",
		"date": "Jun 06, 2024",
		"writer": "11기 김민우"
	},
	"feed-7": {
		"title": "Let's Encrypt Https인증서 자동갱신",
		"link": "https://minwoo-it-factory.tistory.com/entry/Lets-Encrypt-Https%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%9E%90%EB%8F%99%EA%B0%B1%EC%8B%A0",
		"description": "<h3 id=\"%EB%AA%A-%EC%B-%A-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">목차</span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">&middot;</span><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span><span> 인증서 갱신 유효기간 확인하는방법</span></span></span></span></p>\n<p style=\"background-color: #ffffff; color: #000000; text-align: left;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot;<span><span> 90일 간 유지되는 Let's Encrypt 인증서 어떻게해야할까?</span></span></span></span><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"></span></p>\n<p style=\"background-color: #ffffff; color: #000000; text-align: left;\"><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\">&middot;</span><span style=\"font-family: 'Noto Serif KR'; background-color: #ffffff; color: #555555; text-align: start;\"><span><span> CronTab을 이용한 자동인증서 발급</span></span></span></p>\n<p style=\"background-color: #ffffff; color: #000000; text-align: left;\">&nbsp;</p>\n<h3 id=\"%EC%-A%B-%EB%AC%BC%--%EB%B-%--%EC%-C%BC%EB%A-%-C%--%EC%A-%--%ED%--%--%ED%--%B-%EB%B-%B-%EA%B-%B-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">인증서 갱신 유효기간 확인하는 방법</span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">인증서 만료일이 얼마나 남았는지 확인하는 방법</span></p>\n<pre class=\"bash\" id=\"code_1717379793868\"><code>sudo certbot certificates</code></pre>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/MiT6S/btsHLW2nQvy/uZFkvxUpNw3JFnO4MvHY51/img.png\" /></span></figure>\n</p>\n<h3 id=\"%EC%-A%B-%EB%AC%BC%--%EB%B-%--%EC%-C%BC%EB%A-%-C%--%EC%A-%--%ED%--%--%ED%--%B-%EB%B-%B-%EA%B-%B-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">90일간 유지되는 Let's Encrypt 인증서 어떻게해야할까</span><span style=\"font-family: 'Noto Serif KR';\"></span></h3>\n<p><span style=\"font-family: 'Noto Serif KR';\">Let's Encrypt는 글로벌 공인인증기관인 CA에서 인증받은 기관이며, 신뢰할 수 있는 인증서를 제공합니다.</span></p>\n<p><span style=\"font-family: 'Noto Serif KR';\">인증서는 안전한 HTTPS 연결을 도와주는데 이용이 됩니다. 하지만 해당 인증서를 발급받게되면 90일동안만 유효하게 됩니다. 따라서 90일마다 인증서를 재발급해줘야합니다. 하지만 90일마다 재발급하는 것은 너무 번거럽고, 반복적인 작업을 해줘야 하기때문에 자동화를 시켜줘야합니다.</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR';\">AutoCertificateRenew.sh</span></p>\n<pre class=\"bash\" id=\"code_1717377704692\"><code>#인증서 재발급\n\nsudo certbot certonly --manual --preferred-challenges dns \\\n-d \"api.webbizcraft.shop\" --agree-tos --register-unsafely-without-email \\\n--manual-auth-hook \"$HOOK_RENEWAL\" --manual-cleanup-hook \"$HOOK_CLEANUP\" \\\n--manual-public-ip-logging-ok --force-renewal\n\n# deploy.sh 스크립트 실행\n/home/ubuntu/mobileapp/deploy.sh</code></pre>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Nanum Gothic';\">-- manual: 수동모드 사용</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">-- preferred-chaalenges dns: DNS 검증 방식을 사용합니다. DNS TXT레코드를 추가해야합니다.</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">-- agree-tos: 서비스 약관에 동의</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">-- register-unsafely-without-email: 이메일 주소 없이 계정을 등록합니다. 보안 상 권장하진 않지만</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">이메일 주소를 제공하지 않을 때 사용</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">--manual-auth-hook \"$HOOK_RENEWAL\": 인증서 갱신 시 실행할 스크립트를 지정합니다. $HOOK_RENEWAL은 갱신 시 실행할 스크립트의 경로입니다.</span></p>\n<p><span style=\"font-family: 'Nanum Gothic';\">--manual-cleanup-hook \"$HOOK_CLEANUP\": 인증서 갱신 후 정리 작업을 위해 실행할 스크립트를 지정합니다. $HOOK_CLEANUP은 정리 작업을 위한 스크립트의 경로입니다</span></p>\n<p>--manual-public-ip-logging-ok: 공개 IP 로그를 허용합니다. Certbot은 인증서 발급 과정에서 IP 주소를 기록할 수 있습니다.</p>\n<p>--force-renewal: 이미 유효한 인증서가 있더라도 강제로 갱신합니다.</p>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Serif KR'; color: #009a87; text-align: start;\">인증서가 재발급이 된 이후 Nginx를 reload시켜 인증서가 제대로 적용될 수 있도록해줍니다.</span></b><span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\"></span></p>\n<p>&nbsp;</p>\n<h3 id=\"%EC%-A%B-%EB%AC%BC%--%EB%B-%--%EC%-C%BC%EB%A-%-C%--%EC%A-%--%ED%--%--%ED%--%B-%EB%B-%B-%EA%B-%B-\" style=\"background-color: #ffffff; color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">CronTab을 이용한 자동인증서 발급</span></h3>\n<pre class=\"bash\" id=\"code_1717378215817\"><code>crontab -e</code></pre>\n<pre class=\"bash\" id=\"code_1717379549902\"><code>0 0 1 */2 * /home/ubuntu/mobileapp/AutoCertificateRenew.sh</code></pre>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">를 이렇게 설정하게되면&nbsp;</span>0 0 1 */2 *: 매 두 달마다 1일 0시에 해당 <span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">AutoCertificateRenew.sh를 자동으로 실행하게되고</span></p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">90일마다 인증서를 재갱신해야하는 불필요한 일을 줄일 수 있습니다.</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">쀼슝~</span></p>",
		"date": "Jun 03, 2024",
		"writer": "11기 김민우"
	},
	"feed-0": {
		"title": "타입스크립트 딥다이브",
		"link": "https://klmhyeonwooo.tistory.com/129",
		"description": "해당 내용은 타입스크립트 딥다이브를 보고, 내용을 요약하고 정리합니다.\n아는 내용이 섞일 수 있지만 복습차 테크블로그에 정리를 진행하고 있습니다.\n2024.05.31 자로 업데이트 되었으며, 학습한 내용이 계속 업데이트 될 예정입니다.\n&nbsp;\n원시 데이터에서 동등 연산자와 일치 연산자 차이\n자바스크립트에서 동등 연산자(==), 일치 연산자(===)가 존재합니다.\n이때 동등 연산자는 탄력적으로 string을 number로 변환합니다.\nconsole...",
		"date": "May 31, 2024",
		"writer": "5기 김현우"
	},
	"feed-1": {
		"title": "다국어를 지원할 때 언어에 따라 다른 CSS를 적용하고 싶을 때",
		"link": "https://klmhyeonwooo.tistory.com/127",
		"description": "목차\n&middot; 다국어 설정하기\n&middot; 다국어 스타일 시트 적용하기\n\n사내에서 콘텐츠 허브 서비스를 맡아, 개발을 진행하고 있어요 아무래도 국내 시장에서는 큰 점유율을 보유하고 있어 글로벌 시장 진출을 활발하고 있는데, 서비스 별로 가장 중요한 기능 중 하나가 바로 다국어 기능이에요. 입사를 하고 거의 3~4개월만의 연구소 공식 블로그 서비스를 런칭해야하기 때문에 새로 배우는 점이 참 많아요. 그 중 하나가 다국어에 따라 CSS를 변경하고..",
		"date": "May 31, 2024",
		"writer": "5기 김현우"
	},
	"feed-2": {
		"title": "3분만에 브라우저 익스텐션 만들어보기",
		"link": "https://klmhyeonwooo.tistory.com/126",
		"description": "목차\n&middot; 프로젝트 준비하기\n&middot; 익스텐션 만들어보기\n&middot; 익스텐션 스토어 배포\n\n저는 지금 리워크라는 업무에 필요한 멋진 서비스를 만들고 있어요, 처음으로 저한테 필요한 서비스를요   필요한 서비스를 만들면서 PWA 이외에 브라우저 익스텐션으로도 제공이 되었으면 좋겠다는 생각을 했어요. 그래서 관련 자료를 찾아보다가 브라우저 익스텐션 개발이 그리 어렵지는 않았고, PWA와 비슷한 과정을 거쳐 개발을 할 수 있더라구요...",
		"date": "May 27, 2024",
		"writer": "5기 김현우"
	},
	"feed-67": {
		"title": "[발상] 북카페",
		"link": "https://ub775.tistory.com/entry/%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4-%EB%B6%81%EC%B9%B4%ED%8E%98",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img height=\"368\" src=\"https://blog.kakaocdn.net/dn/c6BabR/btsHxf9bewU/uZC3klNkOqggTzoR1xm4BK/img.jpg\" width=\"368\" /></span><figcaption>BOOK CAFE</figcaption>\n</figure>\n</p>\n<p>현대인의 독서량은 매우 적다는 얘기를 들었다. 그도 그럴 것이 나도 독서를 안 한 지 굉장히 오래되었다. 초등학생 때 썼던 독후감들은 그것들을 엮어서 책으로 낼 수 있을 정도의 양이었다. 그때는 다독상 같은 독서 관련 업적들이 많았는데, 최근에 들어서는 제대로 된 독서 한번 해본 적이 없다. 그래서 독서를 해보자는 생각을 가졌고, 책을 조금씩 읽고 있다.</p>\n<p>&nbsp;</p>\n<p>그러다가 문득 이런 아이디어가 떠올랐다. 내가 읽는 책들에 대해 공유하는 플랫폼을 만들면 어떨까 싶다. 비슷한 유형의 플랫폼들이 있으나 이는 독서 모임에 기반한 플랫폼이었다. 하지만 나는 독서 모임을 통해 독서를 접한 사람이 아니기에 독서 플랫폼에 대한 접근이 조금 다른 것 같다.</p>\n<p>&nbsp;</p>\n<p>내가 생각한 몇 가지 기능은 이렇다.</p>\n<p>1) 독후감 공유(개인 피드의 형태를 보일 것 같다)</p>\n<p>2) 도서에서 나온 주제를 가지고 토론(또는 토의)</p>\n<p>3) 도서 구매 정보로 연결</p>\n<p>&nbsp;</p>\n<p>아이디어 이름은 &lt;북카페&gt;라고 지어봤는데 더 성격이 맞는 이름을 찾아봐야겠다.</p>",
		"date": "May 22, 2024",
		"writer": "11기 강명균"
	},
	"feed-8": {
		"title": "2023년, 그리고 지금의 2024년 회고록",
		"link": "https://minwoo-it-factory.tistory.com/entry/2023%EB%85%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A7%80%EA%B8%88%EC%9D%98-2024%EB%85%84-%ED%9A%8C%EA%B3%A0%EB%A1%9D",
		"description": "<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">목차</span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot;<span> </span></span>우물 밖으로 점프해보기</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 개발자로의 첫 면접</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 좋은사람들과의 관계유지하기</span><span style=\"font-family: 'Noto Serif KR';\"></span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&middot; 앞으로의 나, 어떤 가치관을 가질까?</span><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"></span></p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">우물 밖으로 점프해보기</span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">2023년 학교라는 우물안에서 벗어나보고자 다양한 활동들을 지원했다. 멋쟁이사자처럼 백엔드 파트 11기, 운이 좋게도 붙은 SW마에스트로 14기 연수생, 공모전 수상 등등 교내에 머무르는 것이 아닌 교외에서 다양한 사람들과 다양한 인연을 만들었다. 대외활동을 하면서 다양한 사람들을 만나고 이야기하면서 사람 사귀는법을 알게 되었고, 정말 내성적이였던 성격은 외향적으로 점점 변하는갔다. \"머리로 만나면 인맥\"이고 \"가슴으로 만나면 인연\" 이라는 말이 무슨 말인지 정말 잘 알게되었다. 다양한 사람들에게 나의 부족한부분이나 부끄러운점에 대해서 숨기려고 애써 소심하고 적극적으로 나서지 못했던 것들이 정말 많았다. 하지만 다양한 활동을 하면서 느낀것은 진심으로 사람을 대하는 것이 얼마나 중요한지, 소신있게 내 주장을 펼치는 것이 얼마나 중요한 일인지 많이 깨달았던 것 같다.</span></p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"408\" src=\"https://blog.kakaocdn.net/dn/csnGax/btsHuo5Vc6R/KGIIRO4tHd6hewCsnvjn8k/img.png\" width=\"551\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">개발자로의 첫 면접</span></h3>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">작년 하반기 말, 이제 4학년이 다가오면서 회사에 대한 경험이 있으면 좋다고 생각했다. 사실 무엇보다 한 회사에 대한 프로세스를 이해하고 싶었다. 그래서 스타트업 LG사내독립기업인 \"머스타드\"라는 곳에 운이 좋게 서류에 합격할 수 있었고 약 1시간 가량 온라인으로 3:1면접을 보았다. 인사팀 1분 시니어개발자분들 2명이 들어오셨고 정말 긴장이 많이되었다. 포트폴리오를 보고 칭찬을 많이해주시기도하고 답변을 잘 하지못했을 때도 괜찮다고 하시면서 이끌어가주시는 모습이 인상깊었다. 하지만 처음 면접이라 준비되지않은부분들이 너무 많았다. 몇몇 깃허브주소가 PRIVATE으로 설정이 되어있어 코드가 공유되지 않은 프로젝트들도 있었고, 누락된 기술스택이나 다소 정리되지않은 부분에 대해 간접적으로 피드백도 많이해주셨다. 결과적으로는 면접에서 탈락했지만 정말 좋은 경험을 했다.</span></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bKh2Go/btsHvzFzpcE/00ZRgT7n4Dsxq7Jj7mUep0/img.jpg\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">좋은사람들과 관계유지하기</span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">작년 2023년에는 사람을 만나도 다소곳 나를 숨기곤했다. 이사람이 나의 단점을 보고 나를 싫어하면 어떻하지? 나에 대한 안좋은 소문이 퍼지면 어떻게하지 ? 등등 인간관계에 있어서 항상 걱정을 많이했다. 하지만 이런 가치관을 깨준 새롭게 만난 동생한명이 있다. 나이는 나보다 한살어리지만 인생선배처럼 많은 것을 배울 수 있었다. 동생이 아직도 나에게 해준말이 아직도 기억에 남는다. \"솔직하게 날 보여주면 돼 결국 떠날사람은 떠나\" 이말을 해준 친구는 잊었을지 모르지만 나는 아직도 기억한다. 결국 내 단점을 보여줬을 때 떠날사람은 언젠간 떠난다. 이를 계기로 나는 많은 사람들과 대화할 때 그냥 내 있는 그대로의 모습을 보여주려고 최대한 노력한다. 가끔은 진짜 솔직하게 말했을 때 부끄러워서 얼굴이 빨개진 적도 있지만, 결국 내가 솔직하지 않으면 상대방도 그냥 나를 비즈니스로 생각할 것이다.. 최근에 유튜브에 어떤 동영상을 보면서 <span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"><span>&nbsp;</span>\"머리로 만나면 인맥\"이고 \"가슴으로 만나면 인연\"이 말이 딱 맞는말 같았다. 자꾸 머리 굴려가면서 이말저말 하는 것보다 그냥 있는 그대로 마음속 있는 그대로의 모습으로 보여주고 있는그대로 보여주면된다. 좋은사람들과 함께하니까 나도 덩달아 가치관이나 생각이 많이 좋아지고 있는 것 같아서 정말 좋다.</span></span><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"></span></p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"377\" src=\"https://blog.kakaocdn.net/dn/AapuQ/btsHt2voQNg/yRbG1yEKmK7iB6gri5Cmok/img.png\" width=\"719\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&nbsp;</span></p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">앞으로의 나, 어떤 가치관을 가질까?</span></span></h3>\n<p><span style=\"font-family: 'Noto Serif KR';\">- 내 행동하나하나에 소신있게 행동</span></p>\n<p><span style=\"font-family: 'Noto Serif KR';\">- 신뢰를 바탕하기위해 솔직함이 기본베이스라고 생각하기 때문에 최대한 솔직해지고 있는 그대로를 보여준다.</span></p>\n<p><span style=\"font-family: 'Noto Serif KR';\">- 취업 많이 어렵지만, 최대한 뭐든 긍정적으로 생각해서 임하자 결국에는 모두 힘들다</span></p>\n<p><span style=\"font-family: 'Noto Serif KR';\">- 잘 표현하지못했고, 겉으로는 티가 안내지만 ,정이 많아 사람잃는 것이 싫어 잘 다가가지 못했지만 결국 인간관계를 잘 유지하기위해서는 \"먼저 다가가지 못한다\"라는 키워드를 버려야한다.</span></p>\n<p>- <span style=\"font-family: 'Noto Serif KR'; color: #333333; text-align: start;\">지금도 계속 뭐든 일단하자, \"도전의 연속\"으로 살고 있다. 항상 Stay Hungry,Stay <span style=\"background-color: #ffffff; color: #636c76; text-align: start;\">Foolish</span>&nbsp; 마인드를 가지고 살 것이다.</span></p>\n<p>&nbsp;</p>\n<h3><b><span style=\"background-color: #ffffff; color: #4d5156; text-align: left;\">\"안락한 삶이 나를 달콤하게 하지만 성장은 멈출 수밖에 없고 우환과 역경이 나를 힘들게 하지만 새로운 성공을 찾아내는 계기가 될 것이다.\"</span></b></h3>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">&nbsp;</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>",
		"date": "May 20, 2024",
		"writer": "11기 김민우"
	},
	"feed-15": {
		"title": "[programmers] 258711번 - 도넛과 막대 그래프(BFS, 2024 KAKAO WINTER INTERNSHIP)",
		"link": "https://apape1225.tistory.com/165",
		"description": "<p><b>1. 문제 및 예제</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;카카오 문제에 신나게 달려들었다가 멘탈 박살났다. 처음 들어갈때는 \"이게 왜 LV.2야 ㄷㄷ\" 라는 생각이 들었는데, 풀다보니 \"이게 왜 LV.2야?\" 라는 생각이 계속 들었다. ㅋㅋ 임의로 생성된 노드를 구하는 방법이 진입 간선과 진출 간선의 수를 가지고 구한다는 생각을 하지 못해 결국 남의 풀이를 찾아 보았다. 역시 카카오는 기발한 생각으로 쉽게 문제를 풀 수 있거나 문자열과 같이 미친 집중력과 피지컬을 요구하는 쌩짜 구현 이 둘로 나뉘는 것 같다. 불평 해봤자 달라질 건 없으니 해당 방법으로 임의의 노드를 구하고 각 그래프의 종류를 구했다. 각 그래프의 종류를 구하는 방법은 어렵지 않았다. (솔직히 간선의 수로 다 해결할 수 있는 문제였구나를 나중에 깨달았다.)</p>\n<hr contenteditable=\"false\" />\n<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/258711?language=cpp\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://school.programmers.co.kr/learn/courses/30/lessons/258711?language=cpp</a></p>\n<figure contenteditable=\"false\" id=\"og_1716012678231\"><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/258711?language=cpp\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">프로그래머스</p>\n<p class=\"og-desc\">코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요.</p>\n<p class=\"og-host\">programmers.co.kr</p>\n</div>\n</a></figure>\n<hr contenteditable=\"false\" />\n<p><b>2. 풀이과정</b></p>\n<p>&nbsp;</p>\n<p>문제는 다음처럼 나눴다.</p>\n<p>1. 임의로 배치된 노드를 구한다.</p>\n<p>- 해당 노드를 구하면 이 노드와 연결된 점 부터 탐색을 시작하면 되기에 문제가 수월해 질 것이라고 생각했다.</p>\n<p>2. 그래프의 종류를 구한다.</p>\n<p>&nbsp;</p>\n<p>다음은 임의의 노드를 구하는 과정이다.</p>\n<p>&nbsp;</p>\n<pre class=\"cpp\" id=\"code_1716012786686\"><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; graph[1000001];\nint count_in[1000001] = {0};\nint count_out[1000001] = {0};\n\nint get_ans_node(){\n    int max_node = 0;\n    int max_node_size = -1;\n    for(int i = 0; i &lt; 1000001; i++){\n        //node is in graph\n        if(count_in[i] == 0 &amp;&amp; count_out[i] &gt;= 2){\n                return i;\n        }\n    }\n    return -1;\n}\n\nvector&lt;int&gt; solution(vector&lt;vector&lt;int&gt;&gt; edges) {\n    vector&lt;int&gt; answer = {0, 0, 0, 0};\n    int ans_node = -1;\n    //정점을 구한다.\n    \n    //create graph\n    for(int i = 0; i &lt; edges.size(); i++){\n        graph[edges[i][0]].push_back(edges[i][1]);\n        \n        count_in[edges[i][1]]++;\n        count_out[edges[i][0]]++;\n    }\n    \n    int start_node = get_ans_node();\n    answer[0] = start_node;\n    \n    return answer;\n}</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;그냥 진입 간선과 진출 간선을 카운트해주기만 했다. 들어오는 간선인 \"진입 간선\"의 수가 0이어야한다. 임의로 생성된 노드는 각 그래프를 연결하는 노드이기 때문이다. 그러나 이렇게만으로 판별하면 안된다. 막대 모양 그래프의 시작 노드도 진입 간선의 수가 0이기 때문이다. 따라서 이 노드와의 예외를 두기 위해 진출 간선이 2개 이상이라는 조건도 추가해서 구했다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;다음은 그래프 타입을 구하는 과정이다. 탐색알고리즘은 BFS를 사용했다. 전체 정답 코드를 적어보았다.</p>\n<p>&nbsp;</p>\n<pre class=\"cpp\" id=\"code_1716012946948\"><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; graph[1000001];\nint count_in[1000001] = {0};\nint count_out[1000001] = {0};\n\nint get_ans_node(){\n    int max_node = 0;\n    int max_node_size = -1;\n    for(int i = 0; i &lt; 1000001; i++){\n        //node is in graph\n        if(count_in[i] == 0 &amp;&amp; count_out[i] &gt;= 2){\n                return i;\n        }\n    }\n    return -1;\n}\n\nint get_graph_type(int start_node){\n    queue&lt;int&gt; q;\n    \n    if(graph[start_node].size() != 1){\n            \n        if(graph[start_node].size() == 0)\n            return 2;\n        else\n            return 3;\n    }\n    \n    q.push(graph[start_node][0]);\n    \n    while(true){\n        int node = q.front();\n        q.pop();\n        if(graph[node].size() != 1){\n            \n            if(graph[node].size() == 0)\n                return 2;\n            else\n                return 3;\n        }\n        if(node == start_node)\n            return 1;\n        \n        q.push(graph[node][0]);\n        \n    }\n}\n\nvector&lt;int&gt; solution(vector&lt;vector&lt;int&gt;&gt; edges) {\n    vector&lt;int&gt; answer = {0, 0, 0, 0};\n    int ans_node = -1;\n    //정점을 구한다.\n    \n    //create graph\n    for(int i = 0; i &lt; edges.size(); i++){\n        graph[edges[i][0]].push_back(edges[i][1]);\n        \n        count_in[edges[i][1]]++;\n        count_out[edges[i][0]]++;\n    }\n    \n    int start_node = get_ans_node();\n    answer[0] = start_node;\n    \n    for(int i = 0; i &lt; graph[start_node].size(); i++){\n        int root_node = graph[start_node][i];\n        int graph_type = get_graph_type(root_node);\n        answer[graph_type]++;\n    }\n    \n    return answer;\n}</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;각 타입 그래프의 특징을 정하면 다음과 같다.</p>\n<p>&nbsp;</p>\n<p>1. 도넛형: 탐색하다가 시작 노드를 만나면 도넛형</p>\n<p>2. 막대형: 탐색하다가 진출 간선이 0인 노드를 만다면 막대형</p>\n<p>3. 8자형: 탐색하다가 시작 노드를 만나기 전, 진출 간선의 수가 2개인 노드를 만나면 8자형</p>\n<p>&nbsp;</p>\n<p>해당 조건만 판별하면 됐다.</p>\n<p>&nbsp;</p>\n<p><b>3. 결어</b></p>\n<p>&nbsp;</p>\n<p>&nbsp; 결국 블로그를 찾아보았지만 손에 익숙해지는 연습의 필요성을 느끼게 되었다. 화이팅!</p>",
		"date": "May 18, 2024",
		"writer": "11기 성창규"
	},
	"feed-3": {
		"title": "캐치테이블에서 사용하는 Vanilla Extract이 뭘까?",
		"link": "https://klmhyeonwooo.tistory.com/124",
		"description": "목차\n&middot; Runtime 시점에서의 CSS in JS\n&middot; Vanilla Extract\n&middot; Vanilla Extract 시작하기\n&middot; Vanilla Extract, 어떻게 생각해요?\n\nRuntime 시점에서의 CSS in JS\nReact와 같은 SPA가 대두되면서 CSS in JS가 많은 인기를 얻고 있습니다. 이를테면&nbsp;React의 경우 styled-component 또는 emotion을 예를 들 수..",
		"date": "May 17, 2024",
		"writer": "5기 김현우"
	},
	"feed-4": {
		"title": "개발자는 내가 만드는 제품에 대한 애정을 가져야한다",
		"link": "https://klmhyeonwooo.tistory.com/122",
		"description": "&nbsp;\n왜 이런 버그들을 늦게 발견되었는지 알아? 우리가 제품을 많이 써보지 않았기 때문이야\n&nbsp;\n작년 첫 회사에서 필드로 출시하기 위해 준비 중인 제품에 들어갈 웹 에디터를 개발하면서 버그가 발생했다. 출시 일이 얼마 남지 않았기 때문에, 생각보다 긴급 이슈로 분류가 되었고 위와 같은 말을 들었다. 생각해보니 맞는 말이다, 첫 회사는 규모는 크지만 업무 단위는 스타트업처럼 작은 규모로 조직화되어 움직이고 있었고,&nbsp;전체 제품을 세분..",
		"date": "May 12, 2024",
		"writer": "5기 김현우"
	},
	"feed-47": {
		"title": "macOS에서 .ppk 파일을 .pem으로 변환하기",
		"link": "https://velog.io/@yunh03/macOS%EC%97%90%EC%84%9C-.ppk-%ED%8C%8C%EC%9D%BC%EC%9D%84-.pem%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0",
		"description": "<h3 id=\"변경하는-방법을-찾아보게-된-계기\">변경하는 방법을 찾아보게 된 계기</h3>\n<p>사이드 프로젝트를 함께 개발하는 팀원에게 AWS 서버 SSH 접근을 위한 인증키 파일을 받았다. 근데.. 팀원은 Windows 운영체제를 사용하고 있어 <code>putty</code>로 SSH 접속을 하기 때문에 <code>.ppk</code> 파일 인증서를 나에게 보내주었다. macOS에서는 터미널을 이용해서 SSH에 접속할 것이기 때문에 <code>.pem</code> 파일 인증서로 변환이 필요했다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/cb610a2c-5923-4c89-9984-a79727a3bc0e/image.jpg\" /></p>\n<h3 id=\"ppk-pem\">ppk, pem</h3>\n<ul>\n<li>PPK(PuTTY Private Key)<ul>\n<li>PuTTYgen 소프트웨어에 의해 생성 된 파일</li>\n</ul>\n</li>\n<li>PEM(Privacy Enhanced Mail)<ul>\n<li>인증서, 인증서 요청, 인증서 체인 및 키를 표시하는 데 사용</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ppk-파일을-pem-파일로-변환해-보자\">.ppk 파일을 .pem 파일로 변환해 보자!</h3>\n<pre><code>brew install putty</code></pre><p>위 명령어를 터미널에 입력하여 <code>putty</code>를 설치한다. 일반적으로 Windows 운영체제에서 사용하는 PuTTY 프로그램과는 달리 패키지 형식으로 된 cli PuTTY라고 생각하면 된다.</p>\n<p>위 명령어를 통해 PuTTY 설치를 완료했다면, 이제, <code>cd</code> 명령어를 이용해 변환하고자 하는 <code>.ppk</code> 파일이 위치한 곳으로 이동한다. 그리고 아래의 명령어를 입력해 실행하면 <code>.pem</code> 파일로 변환된다.</p>\n<pre><code>puttygen {ppk 파일 이름}.ppk -O private-openssh -o {pem 파일 이름}.pem</code></pre>",
		"date": "May 09, 2024",
		"writer": "11기 전윤환"
	},
	"feed-9": {
		"title": "Java Stream map,foreach 차이 및 예제",
		"link": "https://minwoo-it-factory.tistory.com/entry/Java-Stream-mapforeach-%EC%B0%A8%EC%9D%B4-%EB%B0%8F-%EC%98%88%EC%A0%9C",
		"description": "<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">목차</span></h3>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 왜 map과 foreach의 차이점에 대해 알아보게되었을까?</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; <span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">map과 foreach </span>무슨차이가 있을까?</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">&middot; 결론</span><span style=\"font-family: 'Noto Serif KR';\"></span></p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">왜 map과 foreach의 차이점에 대해 알아보게 되었을까?</span></h3>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR';\">4월부터 시작한 인턴생활, 파일럿프로젝트에서 매일 저녁 8시마다 파이어베이스 알림을 보내주는 스케줄러를 구현했고 테스트 서버에 올려두었다. 하지만 8시가 지나도 알림이 발생하지않았다. 뭐지뭐지.. 어리둥절하다가 결국 스케줄러 내부 메소드를 뜯어보게 되었고 map이 문제였었다.</span></p>\n<p>&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">map과 foreach는 무슨차이가 있을까?</span></h3>\n<p>&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">작동을 하지 않았던 코드</span></p>\n<pre class=\"bash\" id=\"code_1714777799575\"><code>List&lt;Plant&gt; plantList = plantRepository.findAll();\n        plantList.stream().map(plant -&gt; {\n            if(plant.isActive()){\n                notifyEveryDay(plant);\n            }\n            return plant;\n        });\n    }</code></pre>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">Map과 Foreach의 용도는 명확히 다르다.</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">Stream의 Map의 경우 최종연산을 해서 반환 값이 필요한 경우 써야한다. 최종연산이 존재하고</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">최종연산을 거치지 않으면 결과물이 도출이 되지않기 때문에 내부적인 notifyEveryDay메소드도</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">작동이 안했던 것이다. 결국에는 최종연산을 적어주어 Stream안에 있는 map의 메소드가 작동하도록 설계를 해야하지만</span></p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\">해당 로직에서는반환값이 필요하지않았기 떄문에 Map은 적절치 못하다고 판단했다.</span></p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">작동 코드</span></p>\n<pre class=\"bash\" id=\"code_1714777990066\"><code>plantRepository.findAll();\n        plantList.forEach(plant -&gt; {\n            if(plant.isActive()){\n                notifyEveryDay(plant);\n            }\n        });\n    }</code></pre>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">위 코드처럼 단순히 결과가 필요하지않고 반복적으로 작업만 하고 싶을 때 foreach를 사용해서 처리하면</span></p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">더욱 수월하게 처리할 수 있게된다!</span></p>\n<p>&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\"><span style=\"font-family: 'Noto Serif KR';\"><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">결론</span></span></h3>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">Stream map: 최종연산을 해주지 않으면 결과가 반환되지않고, 내부적으로 호출하는 메소드 또한 호출을 하지않는다.</span><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\"></span></p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">결국에는 최종연산이 필요한 작업에 적합한 스트림함수이다.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">Stream foreach: 단순히 결과가 필요하지 않고 반복적으로 작업만 하고 싶을 경우 사용!</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Serif KR'; color: #555555; text-align: start;\">이상 정리 끝! 이상무!</span></p>",
		"date": "May 04, 2024",
		"writer": "11기 김민우"
	},
	"feed-10": {
		"title": "점차 쌓이는 로그들 어떻게 처리해야할까 ?",
		"link": "https://minwoo-it-factory.tistory.com/entry/%EC%A0%90%EC%B0%A8-%EC%8C%93%EC%9D%B4%EB%8A%94-%EB%A1%9C%EA%B7%B8%EB%93%A4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C",
		"description": "<h3 style=\"color: #000000; text-align: start;\">목차</h3>\n<p style=\"color: #555555; text-align: start;\">&middot; docker , docker volume을 이용해서 로그를 기록해보자 log.info 와 was-log !</p>\n<p style=\"color: #555555; text-align: start;\">&middot; 점차 쌓여가는 로그들 나의 EC2의 용량은 누가 지킬 것 인가 알아보자!</p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\">최근에 실제 운영되는 프로젝트를 하면서 로그들을 관리해야할 상황이 왔다. docker logback에 의해 생성되는 로그들을</p>\n<p style=\"color: #555555; text-align: start;\">EC2내부에 기록을 해야했고, 해당 기록을 한 과정들을 담아보려고합니다.</p>\n<p style=\"color: #555555; text-align: start;\">&nbsp;</p>\n<p style=\"color: #555555; text-align: start;\">logback.xml</p>\n<pre class=\"bash\" id=\"code_1714375250817\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;!-- 이 곳에 추가할 properties를 넣는다. --&gt;\n    &lt;property name=\"LOGS_ABSOLUTE_PATH\" value=\"/var/log\"/&gt; &lt;!-- docker run 시 볼륨 매핑해주기 --&gt;\n\n    &lt;!-- appender(어디에 출력할 지)에서 콘솔에 출력되는 형식을 지정한다. --&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt;\n            &lt;Pattern&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{36} - %msg%n&lt;/Pattern&gt;\n        &lt;/layout&gt;\n    &lt;/appender&gt;\n\n    &lt;springProfile name=\"dev\"&gt;&lt;!-- profile prod 에서만 동작해서 파일에 기록하도록 --&gt;\n        &lt;!-- Info 레벨의 이름을 가진 로그를 저장할 방식을 지정한다. --&gt;\n        &lt;appender name=\"INFO_LOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n\n            &lt;file&gt;${LOGS_ABSOLUTE_PATH}/info.log&lt;/file&gt; &lt;!-- 파일을 저장할 경로를 정한다, 도커 사용 시 볼륨매핑 해주어야함 --&gt;\n            &lt;!-- filters 종류 키워드로 확인 --&gt;\n            &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!-- 지정한 레벨과 같은 로그이벤트 필터링 수행 --&gt;\n                &lt;level&gt;INFO&lt;/level&gt;\n                &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 해당 레벨만 기록한다. --&gt;\n                &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;!-- 지정 레벨과 맞지 않으면 onMisMatch 에 지정에 따라 수행, DENY -&gt; print 하지않음 --&gt;\n            &lt;/filter&gt; &lt;!-- 레벨별 필터링이 필요없을 경우 filter class 관련된 부분을 삭제하면 됨--&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;!-- 해당 패턴 네이밍으로 현재 로그가 기록됨 --&gt;\n            &lt;/encoder&gt;\n            &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n                &lt;fileNamePattern&gt;${LOGS_ABSOLUTE_PATH}/was-logs/info/info.%d{yyyy-MM-dd}.%i.log.gz&lt;/fileNamePattern&gt; &lt;!-- 해당 패턴 네이밍으로 이전 파일이 기록됨 --&gt;\n                &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt;\n                    &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;!-- 한 파일의 최대 용량 --&gt;\n                &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;\n                &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;!-- 한 파일의 최대 저장 기한 --&gt;\n                &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;!-- 전체 로그파일 크기 제한, 1기가 넘으면 오래된거 삭제 --&gt;\n            &lt;/rollingPolicy&gt;\n        &lt;/appender&gt;\n    &lt;/springProfile&gt;\n\n    &lt;springProfile name=\"dev\"&gt;\n        &lt;appender name=\"WARN_OR_MORE_LOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n\n            &lt;file&gt;${LOGS_ABSOLUTE_PATH}/warn-or-more.log&lt;/file&gt;\n            &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;!-- 지정레벨 이상의 로그만 print 하는 필터 --&gt;\n                &lt;level&gt;WARN&lt;/level&gt;\n            &lt;/filter&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;\n            &lt;/encoder&gt;\n            &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n                &lt;fileNamePattern&gt;${LOGS_ABSOLUTE_PATH}/was-logs/warn-or-more/warn-or-more.%d{yyyy-MM-dd}.%i.log.gz&lt;/fileNamePattern&gt;\n                &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt;\n                    &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;\n                &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;\n                &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;!-- 한 파일의 최대 저장 기한 --&gt;\n                &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;!-- 전체 로그파일 크기 제한, 1기가 넘으면 오래된거 삭제 --&gt;\n            &lt;/rollingPolicy&gt;\n        &lt;/appender&gt;\n    &lt;/springProfile&gt;\n\n    &lt;!-- 루트로거 구성, 루트로그의 기본 수준을 INFO로 지정, info 이상만 print --&gt;\n    &lt;root level=\"INFO\"&gt;\n        &lt;springProfile name=\"!dev\"&gt;\n            &lt;!-- 각 appender는 루트 로거에 추가 --&gt;\n            &lt;appender-ref ref=\"STDOUT\"/&gt;\n        &lt;/springProfile&gt;\n        &lt;springProfile name=\"dev\"&gt;\n            &lt;!-- 각 appender는 루트 로거에 추가 --&gt;\n            &lt;appender-ref ref=\"STDOUT\"/&gt;\n            &lt;appender-ref ref=\"WARN_OR_MORE_LOG\"/&gt;\n            &lt;appender-ref ref=\"INFO_LOG\"/&gt;\n        &lt;/springProfile&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;</code></pre>\n<p>여기서 중요한것은&nbsp;</p>\n<div style=\"background-color: #1e1f22; color: #bcbec4;\"><span style=\"color: #d5b778;\">&lt;property </span>name<span style=\"color: #6aab73;\">=\"LOGS_ABSOLUTE_PATH\" </span>value<span style=\"color: #6aab73;\">=\"/var/log\"</span><span style=\"color: #d5b778;\">/&gt; </span><span style=\"color: #7a7e85;\">&lt;!-- docker run </span><span style=\"color: #7a7e85;\">시 볼륨 매핑해주기 </span><span style=\"color: #7a7e85;\">--&gt;<br /></span></div>\n<p>이 부분입니다. 불륨을 어디에 할 것인가 이부분을 불륨마운트를 시켜 호스트에서도 해당 로그들을 관찰할 수 있도록 할 것입니다.</p>\n<p>또한 info레벨 이상에서의 로그들을 확인할 것 입니다.</p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"313\" src=\"https://blog.kakaocdn.net/dn/BtVzs/btsG3PvfNtC/NGuUbE6hkil3Mlk6TkTBgk/img.png\" width=\"602\" /></span></figure>\n</p>\n<p>저는 이렇게 진행하여 해당 로그들을 호스트에서 해놨습니다.</p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/cqEaNU/btsG3fHXKIb/u33IAohYShs8ahUjRMO0K0/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>이렇게하게되면 점차 로그들은 쌓이게되고 오늘이 아닌 다른 로그들은 was-log라는 디렉토리안에 쌓이게되고 점차 쌓이게되면</p>\n<p>EC2의 용량은 가득 차 오류가 날 것 입니다.&nbsp;</p>\n<p>&nbsp;</p>\n<h4><b><span style=\"color: #555555; text-align: start;\">점차 쌓여가는 로그들 나의 EC2의 용량은 누가 지킬 것 인가&nbsp;</span></b></h4>\n<p><b><span style=\"color: #555555; text-align: start;\">결론을 말하자면 , crontab과 aws s3로 처리하면된다.</span></b></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #555555; text-align: start;\">usage:&nbsp;&nbsp;crontab&nbsp;[-u&nbsp;user]&nbsp;file<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;crontab&nbsp;[&nbsp;-u&nbsp;user&nbsp;]&nbsp;[&nbsp;-i&nbsp;]&nbsp;{&nbsp;-e&nbsp;|&nbsp;-l&nbsp;|&nbsp;-r&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default&nbsp;operation&nbsp;is&nbsp;replace,&nbsp;per&nbsp;1003.2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(edit&nbsp;user's&nbsp;crontab)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;user's&nbsp;crontab)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delete&nbsp;user's&nbsp;crontab)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prompt&nbsp;before&nbsp;deleting&nbsp;user's&nbsp;crontab)</span></b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #555555; text-align: start;\">&nbsp;export VISUAL=vi; crontab -e 해당 명령어로 crontab를 vi편집기로 수정한다.</span></b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/cm7I0r/btsG3pDzuqb/cLXEgDtPobepcLDbYDn49k/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>매일 아침 6시 마다 해당 쉘 스크립트를 실행해준다.</p>\n<p>&nbsp;</p>\n<p>upload_logs_daily.sh</p>\n<pre class=\"bash\" id=\"code_1714375789448\"><code>#!/bin/bash\n\n# 압축할 디렉토리와 압축 파일 이름 설정\nsource_dir=\"/home/ubuntu/pullo/log/was-logs\"\ncompressed_file=\"logs-$(date +%Y%m%d).tar.gz\"\n# was-logs 디렉토리의 파일들을 압축\ntar -zcvf \"$compressed_file\" \"$source_dir\"\necho \"압축성공\"\n# 압축된 파일을 S3로 복사\naws s3 cp \"./$compressed_file\" \"s3://pullo-s3-bucket/$compressed_file\"\necho \"aws s3 업로드 성공\"\n# 압축 파일 삭제\nrm \"./$compressed_file\"\necho \"압출 파일 삭제 성공\"\n\n# was-log파일 삭제\nrm -rf \"$source_dir\"</code></pre>\n<p>&nbsp;</p>\n<p>이 작업은 was-logs라는 파일을 압축하여 s3 버킷에 저장하고 was logs파일을 삭제하는 방식으로 진행된다.</p>\n<p>하지만 이 작업을 하기위해서는 aws configure 설정을 해줘야한다.</p>\n<p>&nbsp;</p>\n<p><a href=\"https://kimjingo.tistory.com/209\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://kimjingo.tistory.com/209</a></p>\n<figure contenteditable=\"false\" id=\"og_1714375844478\"><a href=\"https://kimjingo.tistory.com/209\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">[AWS] AWS CLI 자격 증명하기(aws configure 명령어)</p>\n<p class=\"og-desc\">AWS CLI에서 다양한 리소스를 다루기 위해서는 자격 증명이 필요합니다. AWS 계정 혹은 액세스 키를 통하여 자격 증명을 할 수 있는데, 액세스 키를 이용하여 자격 증명을 하는 방법에 대하여 다루</p>\n<p class=\"og-host\">kimjingo.tistory.com</p>\n</div>\n</a></figure>\n<p>aws configure은 다음처럼 퍼플릭키 ,시크릿키 , 리전, output 에 대한 파일을 명시해주면됩니다.</p>\n<p>&nbsp;</p>\n<p>그러면 다음 쉘 스크립트는 6시마다 작동되어 logs들을 깔끔하게 처리해주고 s3버킷에 로그들은 매일 저장이 될 것입니다.</p>",
		"date": "Apr 29, 2024",
		"writer": "11기 김민우"
	},
	"feed-30": {
		"title": "[CS] JWT란?",
		"link": "https://velog.io/@handmk/CS-JWT%EB%9E%80",
		"description": "<h3 id=\"📌-서론\">📌 서론</h3>\n<p>프로젝트에 참여 하면서 로그인 기능을 많이 만들었었는데, JWT.. JWT.. 편한건 알겠는데 정작 왜 쓰는지 모르고 항상 사용했던 것 같습니다. 새로운 spring-security 버전 공부하면서 보안 관련 내용을 정리하고자 이 글을 쓰게 됐습니다.</p>\n<h3 id=\"📌-본론\">📌 본론</h3>\n<h4 id=\"jwt란\">JWT란?</h4>\n<p>JWT는 JSON Web Token 의 줄임말입니다.\n웹 상에서 두 당사자 간에 주고 받는 'JSON 객체' 라고 생각하면 편합니다.\n서버 상에 저장되는 '세션'과 달리 클라이언트에 저장되는 토큰입니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/21c3c37a-a0f8-412c-acf4-460af8b06e68/image.png\" />\nJWT는 세 부분으로 이루어져 있습니다.</p>\n<ul>\n<li>Header</li>\n<li>Payload</li>\n<li>Signature</li>\n</ul>\n<h4 id=\"header\">Header</h4>\n<pre><code>{\n    &quot;alg&quot; : &quot;HS256&quot;, // 암호화 알고리즘의 종류 중 SHA-256 의미\n    &quot;typ&quot; : &quot;JWT&quot; // JWT 토큰 의미\n}\n</code></pre><p>Header 는 암호화 알고리즘, 토큰 타입이 들어갑니다.</p>\n<h4 id=\"payload\">Payload</h4>\n<p>Payload에는 '정보'가 들어갑니다.</p>\n<pre><code>{\n  &quot;sub&quot;: &quot;1234567890&quot;,\n  &quot;name&quot;: &quot;HandMK&quot;,\n  &quot;iat&quot;: 1516239022\n}</code></pre><p>이런식으로 말이죠.\n위에 한 줄씩  '정보의 조각', <strong>claim</strong> 이라고 부릅니다.</p>\n<p>claim에는 3가지 종류가 존재합니다.</p>\n<ul>\n<li>등록된 클레임(registered)</li>\n<li>공개 클레임(public)</li>\n<li>비공개 클레임(private)</li>\n</ul>\n<p><strong>등록된 클레임(registered) **\nJWT에 정보들을 담기 위하여 **이미 정해진 필드값</strong>들을 의미합니다.\n모두 Optional 한 값들이라서 다 넣을 필요는 없습니다.</p>\n<p>등록된 클레임들은 다음과 같습니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/bb363419-7d80-42c7-a7bd-a50d8a31b539/image.png\" /></p>\n<p><strong>공개된 클레임(public)</strong>\n충돌이 방지된 key 값을 가져야 합니다. 보통 URI 형식으로 짓습니다.</p>\n<pre><code>{\n    &quot;https://handmk.com/jwt_claims/is_admin&quot; : true\n}</code></pre><p><strong>비공개 클레임(private)</strong>\n서버 - 클라이언트 간에 협의하에 사용되는 클레임입니다.\n다만 충돌이 일어나면 안됩니다.</p>\n<pre><code>{\n    &quot;username&quot; : &quot;Handmk&quot;\n}</code></pre><h4 id=\"signature\">Signature</h4>\n<p>Token을 인코딩 할 때 사용하는 고유한 암호화 코드 입니다.\n고유한 secretkey를 사용합니다.\nsignature를 생성하는 과정은 다음과 같습니다.</p>\n<ul>\n<li>Base64 인코딩 Header + &quot;.&quot; + Base64 인코딩 Payload 된 문자열 생성</li>\n<li>secretkey 를 Header에서 정의한 암호화 알고리즘으로 해싱</li>\n<li>앞서 생성한 문자열과 해싱한 secretkey를 Base64로 인코딩 <pre><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),비밀키)</code></pre></li>\n</ul>\n<p>생성한 Header . Payload . Signature 가 JWT의 구성 요소가 됩니다.</p>\n<h3 id=\"jwt를-이용한-인증과정\">JWT를 이용한 인증과정</h3>\n<p>JWT 토큰으로 이루어지는 인증 과정을 다음과 같이 시각화 됩니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/01ec234c-ee73-49f9-8405-cece506ba033/image.png\" /></p>\n<h3 id=\"jwt의-장단점\">JWT의 장단점</h3>\n<p>JWT 장점은 다음과 같습니다.</p>\n<ul>\n<li>인증 시에 필요한 모든 정보를 JSON 한 객체에 담아서 전달하기 때문에 별도의 저장소가 필요없다.</li>\n<li>데이터 위변조를 방지한다.</li>\n<li>웬만한 언어에서 모두 지원된다.</li>\n</ul>\n<p>물론 단점도 존재합니다.</p>\n<ul>\n<li>토큰을 탈취당하면 만료 될 때 까지 대처가 어렵습니다.</li>\n<li>Payload 부분은 누구든 디코딩하여 확인 가능합니다.</li>\n</ul>",
		"date": "Apr 29, 2024",
		"writer": "11기 손민기"
	},
	"feed-16": {
		"title": "[산업기능요원] 정직원 기념 회사 적응 회고록",
		"link": "https://apape1225.tistory.com/164",
		"description": "<p><b>1. 개요</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;산업기능요원으로 근무하는 회사에 정직원이 되었다. 달력에 표시해놓은 수습 종료일자 전주에 복지카드가 와서 정직원이 됐다는 사실은 조금 더 빠르게 알게 되었다. 사실 그 전부터 팀장님께서 \"제가 수습 기간 평가 자체 박하게 작성할 생각이었으면 그전에 몇번 주의를 줬을 것이고 작성 전에도 미리 말씀드렸을 거에요. 크리티컬한 일도 없고 적응이 빨라 수습기간에 너무 걱정하지 마세요.\" 라고 말씀해주셔서 안정감을 가지고 있었다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;회사 생활은 이전 CJ Olivenetworks에서의 계약직 생활이 다인 나에게 첫 정직원으로서 1년이상을 근무해야하는 회사는 이번이 처음이기에 마음가짐에 많은 책임감을 느꼈다. \"남자들이여 제발 책임감을 가지세요!\" 라는 조던 피터슨 형님의 말에 많이 동감하는 3개월이었다. 매달 결제 금액이 억단위가 넘어가는 게임에 나의 알고리즘으로 작성된 게임이 돌아간다는 사실은 내가 압박감을 느끼기에 충분한 사실이었다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;처음 써보는 회고록이기에 그저 장문의 푸념글이 되지 않을까 걱정되지만, 결국은 편한 마음을 가지고 생각나는 단어를 조합해 막 적어나가는 것이 회고록이 아닌가 싶다. 운좋게도 오늘은 내가 좋아하는 카페에 내가 좋아하는 위치의 창가자리의 책상이 남아있어 기분좋게 글을 작성할 수 있을 것 같다. 후드티의 계절을 맞이하는 4월 말 내일이 출근날이긴 하지만, 또 내가 좋아하는 일을 할 수 있다는 생각에 위안을 가지고자 한다.</p>\n<p>&nbsp;</p>\n<p><b>2. 본론</b></p>\n<p>&nbsp;</p>\n<p>- 재능 보다는 정성</p>\n<p>&nbsp;</p>\n<p>&nbsp;우리 회사가 서비스하는 게임은 2주당 한번씩 새로운 게임을 릴리즈한다. 완전 새로운 게임이 아닌 한 게임안에 다양한 게임들이 있고 그 다양한 게임의 로직단을 내가 작성한다고 생각하면 편하다. 일이 적응된 팀 선배를 보면 정말 가볍게 프로젝트를 완료하시지만, 첫 두달.. 아니 사실은 지금까지도 나에게는 적지 않은 스트레스를 받고 있다. 비교적 서버팀의 인원이 적어 일이 더 많이 느껴지나 싶었지만 그냥 내가 아직 적응을 하지 못하는 것 같기도 하다. 그래도 엉망진창 첫 게임이 릴리즈가 되고, 가끔 내가 작성한 게임을 해보면서 미래의 용기를 얻고자 노력한다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;이전 회사에서도 느꼈지만 확실이 나의 결과물은 내가 얼마나 많은 시간을 투자하냐에 따라 결과의 퀄리티가 천차만별로 달라지는 것 같다. (너무 당연한 이야기인가...) 솔직히 첫 게임을 만들고 나서 두번째 게임에서는 엄청난 시간을 들였다. 집중도가 달랐던 것 같다. 당연히 결과는 좋았다. 에러는 적었다. 버그도 한 개 밖에 발견되지 않았다. 미리 작업을 하니 몸이 좀 편하다는 것은 확실이 느껴졌다. 불행히도 세번째 게임은 그렇게 하지 못하였다. 스스로가 한심하긴 하지만 방심을 많이 한 것 같다. 그러니 버그는 역시 개발자 테스트 단계에서도 정말 많이 발견되었다. 그리고 이런 것들을 다 떠나서 그냥 내 마음이 불편했다. 내일부터 새로운 프로젝트가 실행되는데, 그때는 꼭 후회하지 않는 과정이 되었으면 좋겠다.</p>\n<p>&nbsp;</p>\n<p>- 클린 코드</p>\n<p>&nbsp;</p>\n<p>&nbsp;DDD 책에서 배운 내용을 적용해보고자 노력하였다. 회사 내부의 규약이 있어 객체를 마음대로 만들지는 못했지만 주어진 자유 내에서는 최대한 클린한 코드를 작성하고자하였다. 최대한 책처럼 읽히는 코드를 작성하는 것이 목표였다. 나의 사수님이 \"이걸 다 함수화 시키다니... 역시 적응이 빠르시네요...\" 라고 칭찬을 해주셔서 기분은 좋았다. 나만의 코드 규칙을 만들어보고 싶다. 서버팀 특성상 전역변수를 많이 쓰게 되는데 전역변수가 많은 상황에서 깔끔한 코드를 작성해야하는 상황이 아직은 많이 어렵게 느껴진다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;당장 다음주의 프로젝트도 막막하게 느껴지지만, 지금 그걸 생각한다고 달라지는게 없다는 것을 깨달은 뒤로는 최대한 스트레스를 받지 않도록 노력하고 있다. 주어진 시간동안 내가 할 수 있는 최선을 다하면 될것이다.</p>\n<p>&nbsp;</p>\n<p>- 시선</p>\n<p>&nbsp;</p>\n<p>&nbsp;태어날때부터의 고질병인지는 모르겠지만 아직은 남들의 시선이 많이 신경쓰인다. \"몇몇 사람들에게 내가 이미 일을 못하는 것처럼 보이면 어떡하지?\"라는 걱정이 앞선다. 버그가 발견될 때마다 그런 불안감이 마음속에 자리 잡는 것은 나도 어쩔 수 없는 부분인 것 같기도 하다. 3월에 있을 인사평가 때문인 것 같기도 하다. \"모든 직장인들은 그럼 이렇게 매일 평가받는 기분을 느끼면서 생활하는 것인가?\"라는 생각도 해보았지만, 그런건 아닌 것 같다. 그저 무딘 사람이 있는 것이고 그저 예민한 사람이 있는 것이다. 옳고 그른것은 없다. 그냥 \"다른\" 존재로 받아드리기로 했다. 정답이 없기에 배려가 필요한 세상이니 말이다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;나에게 상처되는 말을 한 사람이 있어도 그사람의 진심을 평가할 순 없다. 그건 비약이다. 표현의 방법은 정말 사람마다 제각각이기 때문이다. 사과도 받고 사과도 해보면서 참 좋은 사람들과 일하고 있다는 것을 느끼게 되었다. 그리고 나는 그만큼 열심히 해야 한다는 사실도 배웠다.</p>\n<p>&nbsp;</p>\n<p>- 조직 문화</p>\n<p>&nbsp;</p>\n<p>&nbsp;나는 운이 좋다고 생각한다. 지금의 회사가 두번째 회사이긴 하지만 너무 좋은 상사분들과 일하고 있다. 사수분들과 팀장분들은 다들 나를 배려해주셨다. 지금 회사의 팀장님은 누가 봐도 능력이 뛰어나셨다. 그러나 간섭과 참견을 안하신다. 도움이 필요할때만 조언을 해주신다. 코드리뷰를 할 때는 크리티컬한 부분이 아니라면 나의 작성법에 대한 이유를 말하시고 의견을 말해주신다. 그리고 나는 그 의견을 듣고 더 공부하고 더 좋은 길을 찾으려 노력한다. 스스로 생각하고 공부할 수 있는 기회가 된다. 이 부분이 너무 좋다고 생각한다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;사수분은 나를 많이 배려해주신다. 일정상 나의 프로젝트 일정이 조금은 빡빡했는데 약 2주정도 소요되는 프로젝트를 두개나 가져가셨다. 조금 힘들었던 나에게 그 시간동안 사내 작성된 코드를 공부하고 적용해보면 좋겠다고 하셨다. 능력이 있고 그 능력을 바탕으로 배려해주시는 모습이 너무 멋있어 보였다.</p>\n<p>&nbsp;</p>\n<p>- 운동</p>\n<p>&nbsp;</p>\n<p>&nbsp;난 겁나 돼지다. 변명일 수 있지만 안구에 염증이 생긴 뒤로 스테로이드 치료를 받자마자 15kg정도 몸무게가 늘었다. 나도 내가 놀랐다. 시도 때도 없이 먹었고 반마리 정도 먹으면 배가 터질 것 같았던 황금올리브를 그자리에서 다 먹었다. 독성이 강한 스테로이드가 몸안에서 다 사라지기까지 1년은 걸렸다. 21살에서 22살까지 약 1년간 매주 투약을 받고 복용하는 스테로이드도 먹었다. 이 스테로이드가 다 사라질 때 까지 다시 1년이라는 시간이 걸렸다. 정신을 차리고 나니 정말 건강하지 않은 나의 모습에 큰 충격을 받았다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;회사에서는 헬스장과 아침 도시락을 지원해주는 좋은 복지가 있다. 매주 4번은 도시락 중 셀러드를 집에 가져가 저녁으로 먹고 운동도 했다. 고강도는 아니지만 그래도 땀날 정도의 강도를 유지하기 위해 노력하였다. 회사 입사 후 5kg정도 감량되었다. 근육은 약 1 ~ 2kg늘었다. 건강해지는 것 같아 기분이 좋다. 물론 아직 난 과체중이다. 갈길이 멀지만 적어도 저번달의 나보다는 건강해졌다는 사실에 위안을 얻는다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"370\" src=\"https://blog.kakaocdn.net/dn/bOWBKm/btsG3pZCf6s/wSMS1aQdqxvSWcXnfroMW1/img.jpg\" width=\"493\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>- 산업기능요원 신규 편입자 교육</p>\n<p>&nbsp;</p>\n<p>&nbsp;산업기능요원 신규 편입자 교육을 받았다. 회사를 하루 쉬는 날이었다. 조금 재밌었다. 노동법은 참 복잡하다. 노무사라는 직업이 왜 따로 있는지 알 것 같았다. 정말 많은 위법 사례를 봤다. 우리 회사 인사팀분들에게 너무 감사했다. 회사측에서 너무 큰 배려를 받고 있다는 것을 알게 되었다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"508\" src=\"https://blog.kakaocdn.net/dn/bGQDJa/btsG5kiJTiw/qAovIAZYDxXAGqoMBR6Ee0/img.jpg\" width=\"381\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p><b>3. 결어</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;운이 좋은건지 복이 많은건지... 일단 지금은 너무 좋은 분들과 근무하고 있다는 생각에 다행이라는 생각이 든다. 매일 칼퇴를 할 수 있기에 자기 개발할 시간도 주어지고 운동할 시간도 주어진다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;2일에 걸쳐 작성한 회고록이지만 지금 보니 그리 긴 내용도 아닌데 왜이리 시간을 끌었는지... 다음 회고록은 더 간결하게 작성해보았으면 한다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;마지막으로 우리 회사 와인파티 사진!</p>\n<hr contenteditable=\"false\" />\n<table border=\"1\" style=\"border-collapse: collapse; width: 100%; height: 524px;\">\n<tbody>\n<tr style=\"height: 524px;\">\n<td style=\"width: 50%; height: 524px; text-align: center;\"><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/266UJ/btsG591RT6H/dQzuDwhpxfifiKoJRQUSo0/img.jpg\" width=\"391\" /></span></figure>\n<span><br /></span></td>\n<td style=\"width: 50%; height: 524px; text-align: center;\"><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/p4nZg/btsG59HzxZs/3WJtKxeK0QGS8hKQHUmKPK/img.jpg\" width=\"389\" /></span></figure>\n</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;</p>",
		"date": "Apr 28, 2024",
		"writer": "11기 성창규"
	},
	"feed-11": {
		"title": "Nginx Blue green 무중단 배포",
		"link": "https://minwoo-it-factory.tistory.com/entry/Jenkins-Nginx-Blue-green-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC",
		"description": "<p>무중단 배포를 하기 위해서는 몇가지 configuration 설정이 필요합니다.</p>\n<p>&nbsp;</p>\n<p>1.&nbsp; docker-compose.green.yaml</p>\n<p>2.&nbsp; docker-compose.blue.yaml</p>\n<p>3.&nbsp; nginx-docker-compose.yaml</p>\n<p>4. mysql-docker-compose.yaml</p>\n<p>5. deploy.sh</p>\n<p>&nbsp;</p>\n<p>docker-compose.green.yaml</p>\n<pre class=\"bash\" id=\"code_1714193497416\"><code>version: \"3.7\"\n\nservices:\n  pullo:\n    image: kimminwoo1234/pullo-backend:${BUILD_NUMBER}\n    restart: always\n    ports:\n      - 8080:8080\n    environment:\n      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL}\n      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME}\n      SPRING_DATASOURCE_PASSWORD: ${SPRING_DATASOURCE_PASSWORD}\n      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}\n    networks:\n      - pullo-network-group\n    volumes:\n      - ./log:/var/log\nnetworks:\n  pullo-network-group: # 기존에 생성한 네트워크 그룹과 동일한 이름으로 지정\n    external: true</code></pre>\n<p>- BUILD_NUMBER를 환경변수 처리함으로 써 버전관리를 할 수 있도록하였습니다.</p>\n<p>- external networks를 사용해야만 compose가 내려가도 네트워크는 사라지지않습니다.</p>\n<p>&nbsp;</p>\n<p>docker-compose.blue.yaml&nbsp;</p>\n<pre class=\"bash\" id=\"code_1714193641426\"><code>version: \"3.7\"\n\nservices:\n  pullo:\n    image: kimminwoo1234/pullo-backend:${BUILD_NUMBER}\n    restart: always\n    ports:\n      - 8081:8080\n    environment:\n      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL}\n      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME}\n      SPRING_DATASOURCE_PASSWORD: ${SPRING_DATASOURCE_PASSWORD}\n      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}\n    networks:\n      - pullo-network-group\n    volumes:\n      - ./log:/var/log\nnetworks:\n  pullo-network-group: # 기존에 생성한 네트워크 그룹과 동일한 이름으로 지정\n    external: true</code></pre>\n<p>- 호스트포트는 8081 게스트포트는 8080으로 돌아가게함으로 blue와 green컨테이너가 동시에 띄워질 수 있도록 설정하였습니다.</p>\n<p>&nbsp;</p>\n<pre class=\"bash\" id=\"code_1714193710745\"><code>version: \"3.7\"\nservices:\n  nginx:\n    image: nginx:latest\n    restart: always\n    ports:\n      - 80:80\n    volumes:\n      - ./nginx/conf.d:/etc/nginx/conf.d\n    networks:\n      - pullo-network-group\nnetworks:\n  pullo-network-group: # 기존에 생성한 네트워크 그룹과 동일한 이름으로 지정\n    external: true</code></pre>\n<p>&nbsp;- configuration파일을 불륨마운트를 시켜 제가 직접 custom한 configuration을 주입시켰습니다.</p>\n<p>&nbsp;</p>\n<p>경로는 pullo/nginx/conf.d</p>\n<pre class=\"bash\" id=\"code_1714193776577\"><code>upstream backend {\n    server green_pullo_1:8080;\n}\n\nserver {\n    listen 80;\n    \n    # HTTP Keepalive Timeout 설정 (기본 75초)\n    keepalive_requests 200;\n\n    # 클라이언트 요청 버퍼 크기 설정\n    client_body_buffer_size 10K;\n    client_header_buffer_size 1k;\n    client_max_body_size 8m;\n    large_client_header_buffers 2 1k;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        error_page   500 502 503 504  /50x.html;\n    }\n\n    location /api/ {\n        allow all;\n\n        add_header 'Access-Control-Allow-Origin' \"$http_origin\";\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, PATCH, DELETE';\n        add_header 'Access-Control-Allow-Headers' 'x-requested-with, authorization, content-type, credential, X-AUTH-TOKEN, X-CSRF-TOKEN';\n        add_header 'Access-Control-Max-Age' 1728000;\n        add_header 'Content-Type' 'text/plain; charset=utf-8';\n        add_header 'Content-Length' 0;\n\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n    location /swagger-ui/ {\n\n        allow all;\n        add_header 'Access-Control-Allow-Origin' \"$http_origin\";\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, PATCH, DELETE';\n        add_header 'Access-Control-Allow-Headers' 'x-requested-with, authorization, content-type, credential, X-AUTH-TOKEN, X-CSRF-TOKEN';\n        add_header 'Access-Control-Max-Age' 1728000;\n        add_header 'Content-Type' 'text/plain; charset=utf-8';\n        add_header 'Content-Length' 0;\n\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n\n    }\n}</code></pre>\n<p>- 주위깊게 볼 부분은 upstream쪽입니다 저부분이 바뀌고 nginx -s reload를 통해 nginx의프록시를 변경시켜 라우팅시켜줄 것 입니다.</p>\n<p>mysql-docker-compose.yml</p>\n<pre class=\"bash\" id=\"code_1714193872266\"><code>version: \"3.7\"\nservices:\n  mysql:\n    image: mysql:5.7\n    container_name: pullo-mysql\n    environment:\n      MYSQL_DATABASE: pullo\n      MYSQL_USER: user\n      MYSQL_PASSWORD: user\n      MYSQL_ALLOW_EMPTY_PASSWORD: \"yes\"\n      MYSQL_CHARSET: utf8mb4\n      MYSQL_COLLATION: utf8mb4_general_ci\n    ports:\n      - 3306:3306\n    networks:\n      - pullo-network-group\n    volumes:\n      - ./db:/var/lib/mysql\n      - ./initdb:/docker-entrypoint-initdb.d  # Mount a directory containing SQL initialization scripts\nnetworks:\n  pullo-network-group: # 기존에 생성한 네트워크 그룹과 동일한 이름으로 지정\n    external: true</code></pre>\n<p>- spring boot가 띄워질라면 docker mysql이 띄워져야하기에 미리 띄워둡니다.</p>\n<p>&nbsp;</p>\n<p>5.deploy.sh</p>\n<pre class=\"bash\" id=\"code_1714193915930\"><code>#!/bin/bash\n \n# Blue 를 기준으로 현재 떠있는 컨테이너를 체크한다.\nEXIST_BLUE=$(docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yaml ps | grep Up)\n \n# 컨테이너 스위칭\nif [ -z \"$EXIST_BLUE\" ]; then\n    echo \"blue up\"\n    docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yaml up -d\n    BEFORE_COMPOSE_COLOR=\"green\"\n    AFTER_COMPOSE_COLOR=\"blue\"\nelse\n    echo \"green up\"\n    docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yaml up -d\n    BEFORE_COMPOSE_COLOR=\"blue\"\n    AFTER_COMPOSE_COLOR=\"green\"\nfi\n \nsleep 30\n \n# 새로운 컨테이너가 제대로 떴는지 확인\nEXIST_AFTER=$(docker-compose -p ${DOCKER_APP_NAME}-${AFTER_COMPOSE_COLOR} -f docker-compose.${AFTER_COMPOSE_COLOR}.yaml ps | grep Up)\nif [ -n \"$EXIST_AFTER\" ]; then\n    \n    # Nginx 설정 변경 및 재로드\n    docker exec -it pullo_nginx_1 /bin/bash -c \"sed -i 's/${BEFORE_COMPOSE_COLOR}/${AFTER_COMPOSE_COLOR}/g' /etc/nginx/conf.d/nginx.conf &amp;&amp; nginx -s reload\"\n    echo \"Nginx configuration updated and reloaded\"\n    # 이전 컨테이너 종료\n    docker-compose -p ${DOCKER_APP_NAME}-${BEFORE_COMPOSE_COLOR} -f docker-compose.${BEFORE_COMPOSE_COLOR}.yaml down\n    echo \"$BEFORE_COMPOSE_COLOR down\"\nfi</code></pre>\n<p>- blue를 기준으로 그린이 띄워져있는지 블루가 띄워져있는지 체크를 합니다.</p>\n<p>- 새로운 컨테이너 제대로 떳으면 컨테이너에 bash shell로 접속하여 nginx.conf파일에서 upstream부분을 새로운 컨테이너 이미지로</p>\n<p>변경시켜줍니다.</p>\n<p>- nginx는 새로운 그린포트로 업데이트가 될 것이고, 기존에 있던 blue 컨테이너는 삭제시켜줍니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>JenkinsFile구성</p>\n<pre class=\"bash\" id=\"code_1714194019387\"><code>pipeline {\n    agent any\n    options {\n    timeout(time: 1, unit: 'HOURS') // set timeout 1 hour\n    }\n\n    environment {\n\n        TIME_ZONE = 'Asia/Seoul'\n\n        //github\n        TARGET_BRANCH = 'develop'\n        REPOSITORY_URL= 'https://github.com/minwoo1999/pullo'\n\n        //docker-hub\n        registryCredential = 'docker-hub'\n\n        CONTAINER_NAME = 'pullo-backend'\n        IMAGE_NAME = 'kimminwoo1234/pullo-backend'\n    }\n\n\n\n    stages {\n\n\n        stage('init') {\n            steps {\n                echo 'init stage'\n                deleteDir()\n            }\n            // post {\n            //     success {\n            //         echo 'success init in pipeline'\n            //     }\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'fail init in pipeline'\n            //     // }\n            // }\n        }\n\n        stage('Prepare') {\n            steps {\n                echo 'Cloning Repository'\n                git branch: 'develop',\n                    url: 'https://github.com/minwoo1999/pullo.git',\n                    credentialsId: 'gitihub-signin'\n            }\n            // post {\n            //     success {\n            //         echo 'Successfully Cloned Repository'\n            //     }\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'This pipeline stops here...'\n            //     // }\n            // }\n        }\n      // 일단은 merge 하기전에 테스트통과함으로 테스트없이 빌드\n        stage('Build Gradle') {\n            steps {\n                echo 'Build Gradle'\n\n                dir('.'){\n                    sh '''\n                        pwd\n                        cd /var/jenkins_home/workspace/pullo-backend\n                        chmod +x ./gradlew\n                        ./gradlew build\n\n                    '''\n                }\n            }\n            // post {\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'This pipeline stops here...'\n            //     // }\n            // }\n        }\n\n        // 도커 이미지를 만든다. build number로  latest 태그 부여한다.\n        stage('Build Docker') {\n            steps {\n                echo 'Build Docker'\n                sh \"\"\"\n                    cd /var/jenkins_home/workspace/pullo-backend\n                    docker build -t $IMAGE_NAME:$BUILD_NUMBER .\n                    docker tag $IMAGE_NAME:$BUILD_NUMBER $IMAGE_NAME:latest\n                \"\"\"\n            }\n            // post {\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'This pipeline stops here...'\n            //     // }\n            // }\n        }\n\n\n     // 빌드넘버 latest\n        stage('Push Docker') {\n            steps {\n                echo 'Push Docker'\n                script {\n                    docker.withRegistry('', registryCredential) {\n                        docker.image(\"${IMAGE_NAME}:${BUILD_NUMBER}\").push()\n                        docker.image(\"${IMAGE_NAME}:latest\").push()\n                    }\n                }\n            }\n            // post {\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'This pipeline stops here...'\n            //     // }\n            // }\n        }\n\n\n\n    stage('rm container and rm images') {\n            steps {\n                echo 'rm container stage'\n                sh '''\n                docker rm -f $CONTAINER_NAME\n                docker image prune -f --filter \"label=${IMAGE_NAME}\"\n                '''\n            }\n            // post {\n            //     success {\n            //         echo 'success rm container in pipeline'\n            //     }\n            //     // failure {\n            //     //     slackSend (channel: '#backend', color: '#FF0000', message: \"${env.CONTAINER_NAME} CI / CD 파이프라인 구동 실패, 젠킨스 확인 해주세요\")\n            //     //     error 'fail rm container in pipeline'\n            //     // }\n            // }\n    }\n\n    stage('Docker run') {\n            steps {\n                echo 'Pull Docker Image &amp; Docker Image Run'\n\n                script {\n                    docker.withRegistry('', registryCredential) {\n                        sshagent (credentials: ['ssh']) {\n                            sh \"ssh -o StrictHostKeyChecking=no ubuntu@43.200.143.218 'cd pullo &amp;&amp; sed -i \\\"s/^BUILD_NUMBER=.*/BUILD_NUMBER=${BUILD_NUMBER}/\\\" .env'\"\n                            sh \"ssh -o StrictHostKeyChecking=no ubuntu@43.200.143.218 'cd pullo &amp;&amp; ./deploy.sh'\"\n                        }\n                    }\n                }\n\n            }\n            post {\n                    failure {\n                      echo 'Docker Run failure !'\n                    }\n                    success {\n                      echo 'Docker Run Success !'\n                    }\n            }\n        }\n\n\n\n    stage('Clean Up Docker Images on Jenkins Server') {\n        steps {\n            echo 'Cleaning up unused Docker images on Jenkins server'\n\n            // Clean up unused Docker images, including those created within the last hour\n            // sh \"docker image prune -f --all --filter \\\"until=1m\\\"\"\n            sh \"docker image prune\"\n        }\n    }\n\n\n\n\n}\n\n    // post {\n    //     success {\n    //         slackSend (channel: '#backend', color: '#00FF00', message: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n    //     }\n    //     failure {\n    //         slackSend (channel: '#backend', color: '#FF0000', message: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n    //     }\n    // }\n}</code></pre>\n<p>&nbsp;</p>\n<p>- 환경변수 부분에서 BUILD_NUMBER를 변경하고</p>\n<p>- ./deploy.sh를 실행시켜 blue/green배포를 실시합니다.</p>\n<p>- docker image prune 명령어를 통해 사용하지 않는 이미지들은 처리해줍니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>nginx swagger config</p>\n<pre class=\"bash\" id=\"code_1714198573288\"><code>upstream backend {\n    server blue_pullo_1:8080;\n}\n\nserver {\n    listen 80;\n    \n    # HTTP Keepalive Timeout 설정 (기본 75초)\n    keepalive_requests 200;\n\n    # 클라이언트 요청 버퍼 크기 설정\n    client_body_buffer_size 10K;\n    client_header_buffer_size 1k;\n    client_max_body_size 8m;\n    large_client_header_buffers 2 1k;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        error_page   500 502 503 504  /50x.html;\n    }\n\n    location /api/ {\n        allow all;\n\n        add_header 'Access-Control-Allow-Origin' \"$http_origin\";\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, PATCH, DELETE';\n        add_header 'Access-Control-Allow-Headers' 'x-requested-with, authorization, content-type, credential, X-AUTH-TOKEN, X-CSRF-TOKEN';\n        add_header 'Access-Control-Max-Age' 1728000;\n        add_header 'Content-Type' 'text/plain; charset=utf-8';\n        add_header 'Content-Length' 0;\n\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n    location /swagger-ui/ {\n\n        allow all;\n\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n\n    }\n\n    location /v3/ {\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}</code></pre>\n<p>참고한 블로그:<a href=\"https://jay-ji.tistory.com/99\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://jay-ji.tistory.com/99</a></p>",
		"date": "Apr 27, 2024",
		"writer": "11기 김민우"
	},
	"feed-31": {
		"title": "[c++] 1874번 스택수열",
		"link": "https://velog.io/@handmk/c-1874%EB%B2%88-%EC%8A%A4%ED%83%9D%EC%88%98%EC%97%B4",
		"description": "<p><strong>시간제한 : 2초</strong></p>\n<h3 id=\"📕문제\">📕문제</h3>\n<p>스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.</p>\n<p>1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.</p>\n<h3 id=\"📙입력\">📙입력</h3>\n<p>첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.</p>\n<h3 id=\"📗출력\">📗출력</h3>\n<p>입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.</p>\n<h3 id=\"정답풀이\">정답풀이</h3>\n<pre><code>/*조건\n1. V[i] 가 max 보다 크면 max 가 V[i]에 도달할 때까지 stack.push()\n - V[i]가 최대 수보다 작을 경우엔 자기 자신을 pop 하면 됨.\n2. max가 N이 되면 2가지 경우가 있음.\n - stack.size()가 남은 벡터 값의 개수와 일치할 경우 -&gt; 전부 pop()\n - stack.size()가 남은 벡터 값의 개수와 불일치 할 경우 -&gt; NO 출력\n*/\n\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int N;\n    cin &gt;&gt; N;\n    vector&lt;int&gt; V(N+1,0);\n    vector&lt;char&gt; rst;\n\n    for(int i=0; i&lt;N; i++){\n        cin &gt;&gt; V[i];\n    }\n\n    stack&lt;int&gt; s; // 스택선언\n    int max=1;\n\n    for(int i=0; i&lt;N; i++){\n        if(V[i] &gt;= max){ // max 보다 클때\n            while(max &lt;= V[i]){\n                s.push(max);\n                rst.push_back('+');\n                max++;\n            }\n            s.pop(); // 다 push 하고 자기자신 pop 해줘야 함.\n            rst.push_back('-');\n        }\n        else{\n            if(s.empty() || s.top() != V[i]){ // max가 N에 도달했을 때, stack 이 비어있거나 top이 아니면\n                cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\\n';\n                return 0;\n            }\n            s.pop();\n            rst.push_back('-');\n        }\n    }\n    for(char a : rst){\n        cout &lt;&lt; a &lt;&lt; '\\n';\n    }\n\n    return 0;\n}</code></pre>",
		"date": "Apr 02, 2024",
		"writer": "11기 손민기"
	},
	"feed-17": {
		"title": "[FLOWBIT] BITCOIN SERVICE의 DDD 구조 작성",
		"link": "https://apape1225.tistory.com/163",
		"description": "<h4>1. 개요</h4>\n<p>&nbsp;길고긴 DDD 스터디가 끝나고 해당 구조를 나의 서비스에 적용해보고 싶었다. 사실 기본적인 개념만을 이해한 상태에서 서버에서 돌아가고 있는 서비스의 구조를 바꾸는 것은 생각보다 쉽지 않았다. 바운디드 컨텍스트를 MSA를 구성하는 하나의 서버라고 생각하고 도메인을 정리하니 나름 구조가 갖춰졌다. 이번 기록지에서는 기존에 돌아가던 서비스에 DDD 개발론을 적용하는 과정을 적어보고자 한다.</p>\n<h4>2. 본론</h4>\n<p>&nbsp;일단 기존의 파일 구조는 다음과 같았다. (이렇게 보니 머신이고 뭐고 아주 개판인 것 같다.)</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"545\" src=\"https://blog.kakaocdn.net/dn/x65nK/btsGeg2J2eU/i5a6Hq4bKHzVfUBUs4FjJK/img.png\" width=\"187\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;아주 개판이다... ㅋㅋㅋ spring boot의 controller, service, dao, dto, repository 계층의 구조만 알고있던 사람이 자동시스템 코드에 주먹구구식으로 배운 flask 프레임워크를 도입한 처참한 결과이다...</p>\n<p>&nbsp;</p>\n<p>&nbsp;사실 flask에도 공통적으로 쓰이는 파일구조가 있는지를 찾아보았었다. 결국 flask도 MVC 패턴에 맞게 directory structure를 작성하는건 비슷했다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/cIye70/btsGgZZEksc/T8i2wtCcAgcEPvKZ9GnlFk/img.png\" /></span></figure>\n</p>\n<p><a href=\"https://shravan-c.medium.com/mvc-for-flask-application-a636e6f58d72\">https://shravan-c.medium.com/mvc-for-flask-application-a636e6f58d72</a></p>\n<figure contenteditable=\"false\" id=\"og_1711879895533\"><a href=\"https://shravan-c.medium.com/mvc-for-flask-application-a636e6f58d72\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">MVC for Flask Application</p>\n<p class=\"og-desc\">Finally!!! freed!!! myself from structuring the flask app. Working for so long in Rails framework so used to the directory structure and&hellip;</p>\n<p class=\"og-host\">shravan-c.medium.com</p>\n</div>\n</a></figure>\n<hr contenteditable=\"false\" />\n<p>&nbsp;위의 구조대로 작성하지 못한 나름의 변명거리는 다음과 같다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>작성된 Machine CLASS의 계층이 너무 불분명했다.\n<ul>\n<li>만약 MongoDB를 편하게 사용할 수 있도록 해주는 객체는 어떤 계층에 넣어주어야할까?</li>\n</ul>\n</li>\n<li>service 계층단에서 수행할 역할이 불분명했다.\n<ul>\n<li>지금 돌아가는 BITCOIN SERVICE는 하루에 한번 cron을 통해 예측가격들을 없데이트 하게 된다. 해당 기능을 DB에 입력하면 그저 그 값을 USER에게 제공만 하면 된다.</li>\n</ul>\n</li>\n<li>나의 역량 부족\n<ul>\n<li>사실 app.py에서 crontroller를 분리하는 방법도 공부가 필요한 처참한 상황이었다.</li>\n</ul>\n</li>\n</ul>\n<hr contenteditable=\"false\" />\n<p>&nbsp;이렇게 보니 막상 나의 서비스는 학습된 모델을 사용한다는 특징이 있을 뿐 웹적으로 엄청난 역할은 수행하고 있지 않다는 생각이 들었다. 따라서 DDD로 리펙토링을 진행하면서 전체적인 파일 구조 또한 수정해야겠다는 생각이 들었다. 지금 보이는 부분이지만, 함수명들도 아주 가관이다... ㅠㅠ</p>\n<p>&nbsp;</p>\n<p>&nbsp;일단 DDD 구조를 작성해야 파일 구조를 작성할 수 있을 거라고 생각했다. 처음에 작성했을 때는 다음과 같은 구조였다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"495\" src=\"https://blog.kakaocdn.net/dn/cp4sVx/btsGejrDesB/sY26LGY7Rx0QYxJ9Cdv7n1/img.png\" width=\"715\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;init_coin 도메인과 one_day_ai 도메인을 따로 분리하는 방식이다. model_controller는 그저 예측 모델을 다루는 객체라고 생각하면 된다. 나의 첫 생각은 \"초기 서비스를 시작할 때 모든 데이터를 초기화하는 코드와 하루에 한번 예측 가격을 도출하는 코드의 역할은 다르니 각각의 root 도메인으로 생각하면 되겠지?\" 였다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;아주 좋지 않은 생각이었다. 결국 DDD는 사용자에게 제공하는 기능에 맞춰 구조를 설계하는 것이었는데 그런 개념이 전혀 반영되지 않았다. 결국 기능적인 측면으로 생각해보면 유저는 그저 \"예측가격을 제공받기\"만 하면 된다. 따라서 해당 기능을 제공하는 root domain으로 coin이라는 귀여운 도메인을 만들었다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"464\" src=\"https://blog.kakaocdn.net/dn/cm37KP/btsGgDvEHtJ/QIokQMDPDdeNoERCs7TWzk/img.png\" width=\"389\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;자, 그럼 이제 coin이라는 root domain을 위해 필요한 부분을 생각해야 될 때이다. 그 개념으로 봤을 때는 init_coin 도메인과 one_day_ai라는 도메인이 생기게 된다. 이 둘이 coin 도메인 안에 속하게 되면 자연스럽게 다음과 같이 Aggregate의 개념이 생긴다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"489\" src=\"https://blog.kakaocdn.net/dn/PJsBw/btsGdSaedwU/PibSoFhq3sh1jGIHFBUiu1/img.png\" width=\"422\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;위의 구조라면 USER는 coin이라는 root 도메인을 통해서만 기능을 제공받을 수 있고, 필요한 도메인은 묶이게 되어 Aggregate의 개념을 적용할 수 있다. 마지막으로 제공하고 싶은 기능을 구현하기 위해 필요한 모든 아키텍쳐 계층이 한 서버안에 있기에 바운디드 컨텍스트에 적합한 구조를 띄게 된다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;위의 구조가 정답이라고 할 수는 없지만, 나름 DDD의 규칙에 맞추려 노력했다 보니 적어도 처음의 개판 파일 구조보다는 깔끔하게 느껴졌다. 다음은 위의 구조에 맞게 Flask 프레임워크에 맞는 파일 구조를 작성하고자 한다.</p>\n<h4>3. 결어</h4>\n<p>&nbsp;개발론은 특정한 정답이 존재하는 것이 아닌 다양한 방법들만이 존재하는 것이기 때문에 참 어려운 것 같다. 근래 이만큼 여러 사람들의 의견을 들은 경험이 있는지에 대한 생각이 들정도로 많은 자료를 찾아보았다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;그래도 하나의 책을 끝내고 이를 적용하려고 노력한 과정이 나름 의미있게 느껴진다. 성과가 없는 상황에서는 이 모든 것이 \"정신승리\"로 평가되는 경우가 많은 세상이지만 이런 상황을 이겨내는 멘탈을 가지기위해 노력하고 있다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;다음에는 위의 DDD를 최종적으로 적용하고 깔끔해진 파일 구조로 완성된 FLOWBIT VER2를 릴리즈한 과정을 주제로 글을 작성할 것이다.</p>",
		"date": "Mar 31, 2024",
		"writer": "11기 성창규"
	},
	"feed-32": {
		"title": "[c++] 1253번 좋다",
		"link": "https://velog.io/@handmk/c-1253%EB%B2%88-%EC%A2%8B%EB%8B%A4",
		"description": "<p><strong>시간제한 : 2초</strong> </p>\n<h3 id=\"📕문제\">📕문제</h3>\n<p>N개의 수 중에서 어떤 수가 다른 수 두 개의 합으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다.</p>\n<p>N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.</p>\n<p>수의 위치가 다르면 값이 같아도 다른 수이다.</p>\n<h3 id=\"📙입력\">📙입력</h3>\n<p>첫째 줄에는 수의 개수 N(1 ≤ N ≤ 2,000), 두 번째 줄에는 i번째 수를 나타내는 Ai가 N개 주어진다. (|Ai| ≤ 1,000,000,000, Ai는 정수)</p>\n<pre><code>10\n1 2 3 4 5 6 7 8 9 10</code></pre><h3 id=\"📗출력\">📗출력</h3>\n<p>좋은 수의 개수를 첫 번째 줄에 출력한다.</p>\n<pre><code>8</code></pre><h3 id=\"⭐️정답풀이\">⭐️정답풀이</h3>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    long long N, Index, startIndex, endIndex, K, cnt;\n    cin &gt;&gt; N;\n    vector&lt;long long&gt; V(N,0);\n\n    for(long long i=0; i&lt;N; i++){ // vector 값 입력\n        cin &gt;&gt; V[i];\n    }\n\n    sort(V.begin(), V.end()); // vector 정렬\n\n    cnt = 0;\n    Index = 0;\n\n    for(long long i=0; i&lt;N; i++){ // N번 반복\n        K = V[i];\n        startIndex = 0;\n        endIndex = N-1;\n        while(startIndex != endIndex){ // 두개의 포인터가 만나지 않을 때 까지 반복\n            if(startIndex == i){ // start 포인터가 K 값과 일치할 때\n                startIndex += 1;\n                continue;\n            }\n            if(endIndex == i){ // end 포인터가 K 값과 일치할 때\n                endIndex -= 1;\n                continue;\n            }\n\n            if(V[startIndex] + V[endIndex] &gt; K){ // K 값보다 크면\n                endIndex -= 1;\n            }\n            else if (V[startIndex] + V[endIndex] &lt; K){ // K 값보다 작으면\n                startIndex += 1;\n            }\n            else{ // K 값과 같으면\n                cnt += 1;\n                break;\n            }   \n        }\n    }\n\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    return 0;\n    }</code></pre>",
		"date": "Mar 29, 2024",
		"writer": "11기 손민기"
	},
	"feed-12": {
		"title": "면접을 위한 CS 전공지식 노트 4장",
		"link": "https://minwoo-it-factory.tistory.com/entry/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B8-4%EC%9E%A5",
		"description": "<h4><b>데이터베이스 </b></h4>\n<p>&nbsp;</p>\n<p><b>데이터베이스 기본</b></p>\n<p>&nbsp;</p>\n<p><b>데이터베이스는 일정한 규칙,혹은 규악을 통해 구조화되어 저장되는 데이터의 모음.</b></p>\n<p>해당 데이터베이스를 제어 , 관리하는 통합 시스템을 DBMS라고하며 , 데이터베이스 안에 있는 데이터들은</p>\n<p>특정 DBMS마다 정의된 쿼리 언어를 통해 삽입,삭제,조회 등을 수행할 수 있다.</p>\n<p>또한 데이터베이스는 실시간 접근과 동시 공유가 가능합니다.</p>\n<p>&nbsp;</p>\n<p><b>엔티티란 ?</b></p>\n<p>사람 ,장소,물건,사건,개념 여러개의 속성을 지닌 명사를 의미</p>\n<p>예) 회원 엔티티 : 이름,아이디,주소,전화번호 속성을 갖습니다.</p>\n<p>&nbsp;</p>\n<p><b>약한 엔터티와 강한 엔터티란 ?</b></p>\n<p>예를 들어 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고 B는 강한</p>\n<p>엔터티가 됩니다. 예) 방은 건물안에만 존재할 수 있기떄문에 방은 약개체 건물은 강개체</p>\n<p>&nbsp;</p>\n<p><b>릴레이션이란?</b></p>\n<p>데이터베이스에서 정보를 구분하여 저장하는 기본단위</p>\n<p>엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리합니다.</p>\n<p>릴레이션을 다른말로 데이터베이스에서는 \"테이블\"이라고 한다. NoSQL에서는 컬렉션이라고 한다.</p>\n<p>&nbsp;</p>\n<p><b>테이블과 컬렉션&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>데이터베이스는 크게 관계형 데이터베이스와 NOSQL 데이터베이스로 나눌 수 있다.</b></p>\n<p><b>MYSQL은&nbsp; 레코드 - 테이블 - 데이터베이스로 이루어져 있고 MongoDB 데이터베이스의 구조는</b></p>\n<p><b>도큐먼트-컬렉션-데이터베이스로 이루어져 있다.</b></p>\n<p>&nbsp;</p>\n<p><b>속성</b></p>\n<p>&nbsp;</p>\n<p><b>속성은 릴레이션에석 관리하는 구체적이며 고유한 이름을 갖는 정보,</b></p>\n<p><b>예) 차 엔티티의 속성은 car_id,car_wheel_count,car_color,car_type등&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>도메인 </b></p>\n<p>&nbsp;</p>\n<p><b>도메인이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말합니다.&nbsp;</b></p>\n<p><b>예를 들어 성별이라는 속성이 있다면 이 속성은 남,여라는 집합을 갖게 된다.</b></p>\n<p>&nbsp;</p>\n<p><b>필드와 레코드</b></p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/3PCSe/btsF7IdlWBc/PKsf4WNNvJwNyx2nwLfWAK/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>DATE ,DATETIME,TIMESTAMP차이</b></p>\n<p>&nbsp;</p>\n<p>DATE: 날짜부분은 있지만 시간부분은 없는 값 1000-01-01~9999-12-31</p>\n<p>&nbsp;</p>\n<p>DATETIME: 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p>\n<p>&nbsp;</p>\n<p>TIMESTAMP: 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;\">Timestamp 타입을 갖는 쿼리는 캐시로 저장되나 Datetime 타입을 갖는 쿼리는 캐시로 저장되지 않는다.</span></p>\n<p><span style=\"font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;\">또한 DATETIME은 8바이트. TIMESTAMP는 4바이트다.</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #000000;\">CHAR 와 VARCHAR</span></b></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #000000;\">CHAR(30)이라면 최대 30글까지 입력할 수 있다.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #000000;\">VARCHAR는 가변길이 문자열 0~65535사이 값으로 지정가능</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #000000;\">TEXT BLOB</span></b></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #000000;\">TEXT: 큰 문자열 저장에 쓰며 주로 게시판의 본문에 사용</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #000000;\">BLOB:이미지,동영상 등 큰 데이터 저장 하지만 <span style=\"color: #ee2323;\"><b>보통은 aws s3 스토리에 저장하고 파일 경로를 VARCHAR로 함</b></span></span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #000000;\">ERD와 정규형</span></b></p>\n<p>&nbsp;</p>\n<p>ERD는 시스템의 요구사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축합니다.</p>\n<p>ERD는 관형 구조로 표현할 수 있는데 구성하는데 유용하지만, 비정형 데이터를 구성하는데 충분히 표현할 수 없다.</p>\n<p>&nbsp;</p>\n<p>- 비정형 데이터란?</p>\n<p>비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보</p>\n<p>&nbsp;</p>\n<p>정규화과정</p>\n<p>&nbsp;</p>\n<p>정규화과정은 릴레시연 간의 잘못된 종속관계로 인해 데이터베이스 <span style=\"color: #ee2323;\">이상현상이 일어나는&nbsp;<span style=\"color: #000000;\">것을 해결하거나,</span></span></p>\n<p><span style=\"color: #ee2323;\"><span style=\"color: #000000;\">저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개 분리하는 과정,</span></span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ee2323;\"><span style=\"color: #000000;\">데이타베이스 이상현상이란 ?</span></span></p>\n<p><span style=\"color: #ee2323;\"><span style=\"color: #000000;\">회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고,</span></span></p>\n<p><span style=\"color: #ee2323;\"><span style=\"color: #000000;\">데이터를 삽입해야하는데 하나의 필드 값이 NULL이 되서 삽입이 어려운 현상을 말합니다.</span></span></p>\n<p>&nbsp;</p>\n<p>정규형 원칙</p>\n<p>- 자료의 중복성은 감소, 독릭적인 관계는 별개의 릴레이션으로 표현해야하며,각각의 독립적인 표현이 가능해야한다.</p>\n<p>&nbsp;</p>\n<p style=\"color: #333333; text-align: left;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: left;\"><b>제1정규형&nbsp;</b></p>\n<p style=\"color: #333333; text-align: left;\">- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성되어야 합니다.</p>\n<p style=\"color: #333333; text-align: left;\">속상 값 중에서 한개의 기본키에 대해 두개 이상의 값을 가지는 반복 집합이 있어서는 안됩니다.</p>\n<p style=\"color: #333333; text-align: left;\">만약에 반복된 집합이 있다면 제거해야함</p>\n<p style=\"color: #333333; text-align: left;\"><b>제2정규형</b></p>\n<p style=\"color: #333333; text-align: left;\">- 제1정규형을 만족하며 부분 함수의 종속성을 제거한 형태</p>\n<p style=\"color: #333333; text-align: left;\">부분함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속이여야 한다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"457\" src=\"https://blog.kakaocdn.net/dn/wsahU/btsF5H0PdTJ/TankUBKcKk6Fq6kcQ3AZv0/img.png\" width=\"673\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>제3정규형</b></p>\n<p>&nbsp;</p>\n<p><b>제2정규형을 만족하고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않은 상태여야한다.</b></p>\n<p>&nbsp;</p>\n<p><b>이행적함수종속이란 ? A-&gt;B-&gt;C</b></p>\n<p>&nbsp;</p>\n<p><b>유저ID&nbsp; &nbsp; &nbsp;등급&nbsp; &nbsp; &nbsp; 할인율</b></p>\n<p><b>&nbsp;홍철&nbsp; &nbsp; 플래티넘&nbsp; &nbsp; 10%</b></p>\n<p><b>&nbsp;민우&nbsp; &nbsp; &nbsp; 골드&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30%</b></p>\n<p><b>&nbsp;건우&nbsp; &nbsp; &nbsp;실버&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50%</b></p>\n<p>-&gt; 제3정규형 시</p>\n<p>-----------------------</p>\n<p>홍철 픞래티넘&nbsp;</p>\n<p>-----------------------</p>\n<p>플래티넘 할인율 10%&nbsp;</p>\n<p>이런식으로 나눈다.</p>\n<p>&nbsp;</p>\n<p><b>트랜잭션과 무결성</b></p>\n<p>&nbsp;</p>\n<p>트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 데이터베이스에 접근하는 방법은 쿼리이므로,</p>\n<p>ㅡㄱ 여러개의 쿼리들을 하나로 묶는 단위입니다.&nbsp;</p>\n<p>&nbsp;</p>\n<p>트랜잭션 특징</p>\n<p>ACID - 원자성,일관성,독립성,지속성</p>\n<p>&nbsp;</p>\n<p>원자성 - 트랜잭션과 관련된 일이 모두 수행되거나 되지 않았거나를 보장하는 특징</p>\n<p>일관성- 하나의 트랜잭션 이전과 이후,데이터베이스의 상태는 이전과 같이 유효해야한다.</p>\n<p>격리성- 트린잭션 수행 시 서로 끼어들지 못해야한다. 서로 격리되어 순차적으로 실행되어야 한다.</p>\n<p>지속성- 트랜잭션이 커밋이 된 데이터를 그 이후에도 로그 기록이 남아있어야 한다.</p>\n<p>격리수준 - SERIALIZABLE,REPEATABLE_READ,READ_COMMITTED,READ_UNCOMMITTTED</p>\n<p>&nbsp;</p>\n<p>REPEATABLE_READ : 팬텀리드</p>\n<p>READ_COMMITTED: 팬텀리드, 반복 가능하지 않은 조회가 발생함</p>\n<p>READ_UNCOMMITTED 팬텀리드, 반복 가능하지 않은 조회, 더티리드가 발생할 수 있다.</p>\n<p>&nbsp;</p>\n<p>격리수준에 따라 발생하는 형상</p>\n<p>&nbsp;</p>\n<p>격시 수준에 따라 ㅂ라생하는 현상은 팬텀리드,반복가능하지않은 조회, 더티 리드가 있습니다.</p>\n<p>&nbsp;</p>\n<p>팬텀리드란 ?</p>\n<p>&nbsp;</p>\n<p>트랜잭션내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른경우를 의미합니다.</p>\n<p>ex) 사용자 A가 회원 테이블에서 age가 12이상인 회원들을 조회하는 쿼리를 보낸다고 해봅시다.</p>\n<p>이결과로 세개의 테이블이 조회한다고하보죠. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입합니다.</p>\n<p>그러면 그다음 세 개가 아닌 네 개의 테이블이 조회가 됩니다.</p>\n<p>&nbsp;</p>\n<p>반복 가능하지 않은 조회(<span style=\"background-color: #ffffff; color: #1f1f1f; text-align: left;\">Non-Repeatable Read</span>)</p>\n<p>&nbsp;</p>\n<p>반복가능하지않은 조회: 한 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했을 때 그 값이 다른경우</p>\n<p>ex) 사용자 A가 민우의 보석 개수가 100개라는 값을 가진 데이터였는데 그 이후 사용자 B가 그 값을 1로 변경</p>\n<p>해서 커밋했다고 하면 사용자 A는 100이 아닌 1을 읽게된다.</p>\n<p>&nbsp;</p>\n<p>더티리드</p>\n<p>&nbsp;</p>\n<p>반복가능하지않은 조회와 유사하며 한 트랜잭션이 실행 중 일때 다른 트른잭션에 의해 수정되었지만 아직</p>\n<p>\"커밋되지 않은\" 행의 데이터를 읽을 수 있을 때 발생합니다.</p>\n<p>ex) 사용자 A가 민우의 보석개수를 100을 1로 변경한 내용이 \"커밋되지 않은\"상태라도 그 이후 사용자</p>\n<p>B가 조회한 결과가 1로 나오는 경우</p>\n<p>&nbsp;</p>\n<p><b>격리수준</b></p>\n<p>&nbsp;</p>\n<p><b>SERIALIZABLE</b></p>\n<p>&nbsp;</p>\n<p><b>말 그대로 트랜잭션을 순차적으로 진행시키는 것을 말한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.</b></p>\n<p><b>이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야한다.</b></p>\n<p><b>그렇기 떄문에 교착상태가 일어날 확률이 많고 가장 성능이 떨어지는 격리 수준입니다.</b></p>\n<p>&nbsp;</p>\n<p><b>REPEATABLE_READ</b></p>\n<p>&nbsp;</p>\n<p><b>MYSQL의 innodb 기본값 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만&nbsp;</b></p>\n<p><b>새로운 행을 추가하는 것은 막아주지 않는다. 따라서 이후에 추가된 행이 발견될 수 있다. 하지만 INNODB는 팬텀리드가 발생하지않는다&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>READ_COMMITTED</b><b></b></p>\n<p>&nbsp;</p>\n<p><b>가장 많이 사용하는 격리수준이며 PostrgreSQL,SQL Server,Oracle에서 기본값으로 셋팅되어있음</b></p>\n<p><b>READ_UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수 없다. 즉 , 커밋이 완료된</b></p>\n<p><b>데이터에 대해서만 조회를 허용, 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.</b></p>\n<p>&nbsp;</p>\n<p><b>READ_UNCOMMITTED</b></p>\n<p>&nbsp;</p>\n<p><b>가장낮은 격리수준,하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있다.</b></p>\n<p><b>하지만 속도가 제일빠름, 거대한 양의 데이터를 \"어림잡아\"집계하는데 사용하면 괜찮다.</b></p>\n<p>&nbsp;</p>\n<p><b>지속성</b></p>\n<p>&nbsp;</p>\n<p><b>성공적으로 수행된 트랜잭션은 영원히 반영되어야한다. 데이터베이스 시스템 장애가 발생해도 원래 상태로</b></p>\n<p><b>복구하는 회복 기능이 있어야 함 .데이터베이스는 이를위해 저널링,체크썸,롤백기능을 제공&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b><b>체크섬:</b>오류 정정을 통해 송신된 자료의 무결성보호</b></p>\n<p><b><b>저널링: </b>데이터베이스에 변경사항을 커밋하기 전 로킹하는 것. 트랜잭션 등 변경 사항에 대한 로그는 남기는 것</b></p>\n<p>&nbsp;</p>\n<p><b>무결성</b></p>\n<p><b>- 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야하는 성질</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><a href=\"https://alexander96.tistory.com/55?category=1065003\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://alexander96.tistory.com/55?category=1065003</a></b></p>\n<figure contenteditable=\"false\" id=\"og_1711502182293\"><a href=\"https://alexander96.tistory.com/55?category=1065003\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">Serializable로 동시성을 잡으려 하면 데드락을 만납니다</p>\n<p class=\"og-desc\">최근 우연찮은 기회로 현업 개발자와 동시성 이슈에 대한 얘기를 할 기회를 얻었다. 동시성 이슈에 대해서 고민해보고 어떤 상황에 어떤 방식으로 해결하는 결론을 내렸는 지 정리된 걸 얘기해</p>\n<p class=\"og-host\">alexander96.tistory.com</p>\n</div>\n</a></figure>\n<p><span style=\"color: #555555; text-align: start;\">Serializable은 팬텀 리드 문제를 해결하기 위해서만 사용한다.(mysql의 InnoDB 엔진일 경우 Repeatable Read만 되어도 팬텀 리드가 발생하지 않는다.) 사실 거의 사용할 일 없다. 동시성을 잡는다고, Serializable의 락 기능을 이용해보겠다고 그걸 걸었다간&hellip; 더 어려운 문제를 맞이할 수 있다.</span></p>\n<p>&nbsp;</p>\n<p><b>데이터베이스 종류</b></p>\n<p>&nbsp;</p>\n<p><b>관계형 데이터베이스</b></p>\n<p>&nbsp;</p>\n<p>행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가르키며 SQL이라는 언어를 써서 조작합니다.</p>\n<p>MYSQL, PostgreSQL,Oracle,SQL Server,MSSQL 등이 있습니다.&nbsp;</p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"806\" src=\"https://blog.kakaocdn.net/dn/v4qcK/btsF8lJLadX/uLHrRXjjlQ6SnXg4X1Bw2K/img.png\" width=\"730\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>왜 사람들은 InnoDB를 사용할까 ?</p>\n<p>&nbsp;</p>\n<p>&nbsp;MyISAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB</p>\n<p>&nbsp;</p>\n<p>Mysql의 스토리지 엔진으로 가장 많이 사용하는 MyISAM(발음하기 힘드네... 마이아이삼,마이아이샘), InnoDB의 차이를 알아보자.</p>\n<p>결론적으로 얘기하자면 트랜잭션 처리가 필요하고 대용량의 데이터를 다루기 위해서는 InnoDB가 효율적이고, 반면 트랜잭션 처리가 필요없고&nbsp;운영에 Read only 기능이 많은 서비스일수록 MyISAM 엔진이 효율적이다.</p>\n<p>한마디로 MyISAM은 SELECT가 많은서비스에, InnoDB는 데이터의 변화가 많은 서비스에 적합하다 할 수 있다.</p>\n<p>&nbsp;</p>\n<p>1. MyISAM</p>\n<p>MyISAM은 항상 테이블에 ROW COUNT를 가지고 있기 때문에 SELECT count(*) 명령시 빠르고,&nbsp;</p>\n<p>SELECT 명령시에도 빠른 속도를 자랑한다. 또한, 풀텍스트 인덱스를 지원하는데</p>\n<p>여기서 풀텍스트 인덱스는 검색 엔진과 유사한 방법으로 자연 언어를 이용해 검색할 수 있는 특별한 인덱스로 모든 데이터 문자열의 단어를 저장한다.</p>\n<p>그렇기 때문에 Read Only기능이 많은 서비스일 수록 MyISAM엔진이 효율적이라 할 수 있다.</p>\n<p>단점으로는, row level locking을 지원하지 못해, select insert update delete시 <u>해당 Table 전체에 Locking</u>이 걸린다.</p>\n<p>(row의 수가 커지면 커질수록 속도는 엄청나게 느려진다는 단점!)</p>\n<p>&nbsp;</p>\n<p>2. InnoDB</p>\n<p>장점으로는... MyISAM의 단점으로 있었던 row level locking이 지원된다. 그렇기 때문에 트랜잭션 처리가 필요한 대용량의 데이터에 유리한 점이 있어서,&nbsp;뭐 예를 들자면 사용자의 CRUD가 많은 서비스에 유리할 것 같다&nbsp;(필자가 담당하고있는 서비스의 대부분의 스토리지 엔진도 InnoDB인데)</p>\n<p>단점으로는, MyISAM의 장점인 풀텍스트 인덱스를 지원하지 못한다고 한다. </p>\n<p>&nbsp;</p>\n<p><b>Nosql 데이터베이스</b></p>\n<p>&nbsp;</p>\n<p><b>mongodb</b></p>\n<p>&nbsp;</p>\n<p><b>mongodb는 json을 통해 데이터에 접근할 수 있고, Binary JSON 형태로 데이터가 저장되며 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스입니다. 확장성이 뛰어나며, 빅데이터 </b><b>를 저장할 때 성능이 좋고 고가용성 샤딩, 레플리카셋을 지원합니다. 또한 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점을 보입니다.</b></p>\n<p>&nbsp;</p>\n<p><b>또한 MongoDB는 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID가 생성됩니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bDgLXQ/btsF6dTvn24/UqNkfVEUIyNVHElpSkjIY0/img.png\" /></span></figure>\n</p>\n<p>기본키는 유닉스 시간 기반의 타임스탬프(4바이트),랜덤 값(5바이트),카운터(3바이트)로 이루어져 있습니다.</p>\n<p>&nbsp;</p>\n<p><b>Redis</b></p>\n<p>&nbsp;</p>\n<p><b>redis는 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스</b></p>\n<p>&nbsp;</p>\n<p><b>기본적인 데이터 타입은 문자열이며 최대 512MB까지 저장할 수 있습니다. 이외에도 Set,Hash등을 지원</b></p>\n<p><b>pub/sub 기능을 통해 채팅시스템, 데이터베이스 앞단에 두어 캐싱계층,단순한 키 - 값이 필요한 세션정보관리,</b></p>\n<p><b>정렬된 셋(sorted set)자료구조를 이용하여 실시간 순위표 서비스에 사용됩니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>인덱스</b></p>\n<p>&nbsp;</p>\n<p><b>인덱스의 필요성</b></p>\n<p>&nbsp;</p>\n<p><b>인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bCj2ex/btsF9ep7DSI/fzev6k6EptyQF941BWa8RK/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>책의 본문이 있고 그 본문 안에 내가 찾고자 하는 \"항목\"을 찾아보기를 통해 빠르게 찾을 수 있다.</p>\n<p>&nbsp;</p>\n<p><b>B-TREE</b></p>\n<p>&nbsp;</p>\n<p><b>인덱스는 B-TREE라는 자료구조로 이루어져 있다. 이는 루트노드,인터널노드,리프노드로 나뉩니다.</b></p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bOps96/btsGaynCUS8/3JtebfulcXpe1Fy4gp5btk/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>트리탐색은 맨위 루트노드부터 탐색이 일어나며 브랜치노드(인터널노드)를 거쳐 리프노드까지 내려옵니다. 57보다 같거나 클때까지 &lt;=를 기반으로 처음 루트노드에서 39.83이후 아래 노드로 내려와 46,53,57등 정렬된 값을 기반으로 탐색을 합니다. 이렇게 루트노드부터 시작하여 마지막 리프 노드에 도달해서 57이 가리키는 데이터 포인터를 통해 결과값을 반환합니다.</p>\n<p>&nbsp;</p>\n<p>B-tree 와 B+tree의 차이</p>\n<table border=\"1\" id=\"3f4e196c-390a-4f0b-b5c9-54502b2632cc\" style=\"border-collapse: collapse; width: 100%;\">\n<tbody>\n<tr id=\"65b7f238-b1e3-4dc0-a659-9cd495fe8811\">\n<td id=\"~^du\">&nbsp;</td>\n<td id=\"d^oj\"><b>B-tree</b></td>\n<td id=\"LKuP\"><b>B+tree</b></td>\n</tr>\n<tr id=\"724cba73-4923-4cc6-9797-884042dd0147\">\n<td id=\"~^du\">주요 특징</td>\n<td id=\"d^oj\">모든 내부, 리프 노드들이 데이터를 가진다</td>\n<td id=\"LKuP\">단지 리프노드만 데이터를 가진다</td>\n</tr>\n<tr id=\"6cabfc06-cea2-4c2f-9d51-27e9c9b80505\">\n<td id=\"~^du\">검색</td>\n<td id=\"d^oj\">모든 키가 리프에서 사용가능 하지 않기 때문에, 검색이 때로 느리다</td>\n<td id=\"LKuP\">모든 키가 리프 노드에 있기 때문에 검색이 빠르고 정확하다</td>\n</tr>\n<tr id=\"8a9db85d-1c15-45a0-be48-b4dfefa7d891\">\n<td id=\"~^du\">중복 키</td>\n<td id=\"d^oj\">트리에 중복키가 없다</td>\n<td id=\"LKuP\">중복키가 존재하며 모든 데이터들은 리프에 있다</td>\n</tr>\n<tr id=\"60390851-5263-4d70-ac13-cbf7395e2c24\">\n<td id=\"~^du\">삭제</td>\n<td id=\"d^oj\">내부 노드의 삭제는 목잡하고 트리 변형이 많다</td>\n<td id=\"LKuP\">어떠한 노드든 리프에 있기 때문에 삭제가 쉽다</td>\n</tr>\n<tr id=\"79d17266-b056-4adc-9726-c0ed3dbc08a3\">\n<td id=\"~^du\">리프노드</td>\n<td id=\"d^oj\">링크드 리스트로 저장되지 않는다</td>\n<td id=\"LKuP\">링크드 리스트로 저장된다</td>\n</tr>\n<tr id=\"7a89b934-3772-45b4-8d88-9ebcb2484a5c\">\n<td id=\"~^du\">높이</td>\n<td id=\"d^oj\">특정 갯수의 노드는 높이가 높다</td>\n<td id=\"LKuP\">같은 노드일 때 B-tree보다 높이가 낮다</td>\n</tr>\n<tr id=\"9060e796-df9e-41ab-8139-6e3f050f45ed\">\n<td id=\"~^du\">사용</td>\n<td id=\"d^oj\">데이터베이스, 검색엔진</td>\n<td id=\"LKuP\">멀티레벨 인덱스, DB 인덱스</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>b+트리가 빠른이유 : B+ 트리에서는 내부 노드는 키만을 저장하며, 데이터는 리프 노드에만 저장됩니다. 이는 더 많은 키를 저장할 수 있도록 하며, 캐시의 효율성을 향상시킵니다.</p>\n<p>&nbsp;</p>\n<p>Mysql 인덱스를 만드는 방법</p>\n<p>&nbsp;</p>\n<p>MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스터형 인덱스는 테이블 당 하나를 설정할 수 있다.</p>\n<p>primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있다. 기본키로 만들지 않고 unique not null옵션을&nbsp;</p>\n<p>붙이면 클러스터형 인덱스로 만들 수 있다.</p>\n<p>&nbsp;</p>\n<p>create index ... 명령어 기반으로 만들면 보조인덱스(세컨더리 인덱스)를 만들 수 있다. 하나의 인덱스만 생성할 것이라면&nbsp;</p>\n<p>클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것 보다 성능이 좋다.</p>\n<p>&nbsp;</p>\n<p>세컨더리 인덱스는 보조 인덱스로 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야합니다.</p>\n<p>ex) age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하겠죠 ? 하지만 age,name,email등등이</p>\n<p>where 조건문에 타게되면 다양한 필드를 기반으로 쿼리를 보낼 것이고 세컨더리 인덱스를 사용해야합니다.</p>\n<p>but , 하지만 <span style=\"background-color: #ffffff; color: #212529; text-align: start;\">중복도가 낮은( 카디널리티가 높은 것) 을 </span>기반으로 인덱스를 설정해야합니다.&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>카디널리티가 높을 때 index를 왜 더 잘탈까 ?</b></p>\n<ol style=\"background-color: #ffffff; color: #0d0d0d; text-align: start;\">\n<li><b>검색 속도 향상</b>: 카디널리티가 높을수록 각 값이 더 분산되어 있기 때문에 특정 값을 찾을 때 인덱스를 사용하는 것이 더 효율적입니다. 만약 열의 값이 대부분 중복되는 경우 인덱스를 사용하더라도 해당 값이 나타나는 레코드가 많아서 검색이 느려질 수 있습니다.</li>\n<li><b>인덱스 크기 관리</b>: 카디널리티가 낮은 열에 인덱스를 만들면 인덱스 크기가 커질 수 있습니다. 하지만 카디널리티가 높은 열에 인덱스를 만들면 인덱스 크기가 상대적으로 작아지고 메모리를 효율적으로 사용할 수 있습니다.</li>\n</ol>\n<p>인덱스를 최적화하는방법</p>\n<p>&nbsp;</p>\n<p>inflearn강의 듣는거에서 추가보충하자 추후 **********</p>\n<p>&nbsp;</p>\n<p>1. 항상 테스팅하라</p>\n<p>&nbsp;</p>\n<p>인덱스 최적화 기법은 서비스 특징에 따라 달라진다, 서비스에서 사용하는 객체의 깊이,테이블의 양등이 다 다르기 때문</p>\n<p>explain을 통해 실행계획을 분석하고 내 인덱스가 몇퍼센트 타고있고 몇개의 row 수를 가지고있고 몇 ms가 나오는지 비교를 하고 테스팅하여 걸리는 시간을 최소화해야합니다.</p>\n<p>&nbsp;</p>\n<p>2. 복합인덱스는 같음,정렬,다중값,카디널리티 순이다</p>\n<p>&nbsp;</p>\n<p>보통 여러필드를 기반으로 조회할 때 복합 인덱스를 생성하는데 , 이 인덱스를 생성할 때는 순서가 있고 생성순서에 따라&nbsp;</p>\n<p>인덱스 성능이 달라집니다. 같음,정렬,다중 값, 카디널리티 순으로 생성해야한다.</p>\n<p>&nbsp;</p>\n<p>1. 어떠한 값과 같음을 비교하는 ==이나 equals이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.</p>\n<p>2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정합니다.</p>\n<p>3. 다중 값을 출력해야 하는 필드 , 즉 쿼리 자체가 &gt; 이거나 &lt; 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정합니다.</p>\n<p>4. 유니크한 값의 정도를 카디널리티라고 합니다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 합니다.</p>\n<p>예를 들어 age와 email이 있다고 합시다. 어떤 것이 더 높죠? 당연히 email입니다. 즉 ,email이라는 필드에 대해 인덱스를 먼저 걸어야한다.</p>\n<p>&nbsp;</p>\n<p><b>조인의 종류</b></p>\n<p>&nbsp;</p>\n<p><b>내부조인(inner join):</b></p>\n<p><b>select * from tableA a</b></p>\n<p><b>inner join tableB b on&nbsp;</b></p>\n<p><b>A.key = B.key</b></p>\n<p>&nbsp;</p>\n<p><b>왼쪽조인(left outer join):</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>select * from tableA a</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>left outer join tableB b on&nbsp;</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>A.key = B.key</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p><b>오른쪽 조인(right outer join):</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>select * from tableA a</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>right outer join tableB b on&nbsp;</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>A.key = B.key</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p><b>합집합 조인(full outer join):</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>select * from tableA a</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>full outer join tableB b on&nbsp;</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>A.key = B.key</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>조인의 원리</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>조인의 원리인 중첩 루프 조인, 정렬 병합 조인, 해시 조인이 있다.</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>중첩루프조인</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>- Nested Loop Join은 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않습니다. 기본적으로 MySQL에서 사용하는 조인방법</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bcZxp1/btsF64IPZDA/d0xKKyqHZYpqOoEvhyXEkK/img.png\" /></span></figure>\n</p>\n<p style=\"color: #333333; text-align: start;\"><b>정렬 병합 조인 </b></p>\n<p style=\"color: #333333; text-align: start;\"><b>테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인, 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 &lt;,&gt; 등 범위 비교 연산자가 있을 때 씁니다.</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>해시 조인</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>해시조인은 해시 테이블을 기반으로 조인하는 방법 두개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적입니다.(메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생합니다) 또한 동등조인에서만 사용할 수 있습니다.</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>MySQL의 경우 8.0.18 릴리스와 함께 이 기능을 사용할 수 있게 되었으며 이를 기반으로 해시조인의 과정을 살펴보겠습니다.</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>빌드단계</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>빌드 단계는 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계</b></p>\n<p style=\"color: #333333; text-align: start;\"><b>예를들어 persons 와 countries라는 테이블을 조인한다고 했을 때 둘 중에 바이트가 더 작은 테이블을 기반으로해서 테이블을 빌드합니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/rOCCq/btsF7Qp4QBi/t3H04BKm2thtOjVcs05w4k/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>또한, 조인에 사용되는 필드가 해시 테이블의 키로 사용됩니다.countires_country_id 가 키로 사용된다.</p>\n<p>&nbsp;</p>\n<p><b>프로브단계</b></p>\n<p>&nbsp;</p>\n<p><b>프로브 단계 동안 레코드 읽기를 시작하며, 각 레코드에서 persons_country_id에 일치하는 레코드를 찾아서 결과값으로 반환&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>이를 통해 각 테이블은 한번 씩만 읽게 되어 중첩해서 두개의 테이블을 읽는 중첩 루프 조인보다 보통은 좋은 성능을 가짐.</b></p>",
		"date": "Mar 26, 2024",
		"writer": "11기 김민우"
	},
	"feed-13": {
		"title": "면접을 위한 CS 전공지식 노트 5장",
		"link": "https://minwoo-it-factory.tistory.com/entry/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B8-5%EC%9E%A5",
		"description": "<p><b>자료구조란?</b></p>\n<p>효율적으로 데이터를 관리하고 수정 , 삭제 , 탐색 ,저장할 수 있는 데이터 집합</p>\n<p>&nbsp;</p>\n<p>C++는 STL을 기반으로 전반적인 자료구조를 가장 잘 설명할 수 있는 언어</p>\n<p>STL 이란 ? C++의 표준템플릿 라이브러리이자 스택,배열 등 데이터 구조의 함수 등을 제공하는 라이브러리의 묶음</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>시간복잡도</b></p>\n<p><b>- 빅오표기법 으로 표기를 하며 , 입력 크기에 대해 어떠한 알고리즘이 실행되는 데 걸리는 시간입니다.</b></p>\n<p><b>주요 로직의 반복 횟수를 중점으로 츨정되며, 보통 빅오 표기법으로 나타냅니다 예를 들어 \"입력크기 n\"의 모든 입력에 </b></p>\n<p><b>대한 알고리즘에 필요한 시간이 n^2이라고 하면 이중 for문을 생각하면된다. 이것을 빅오표기법으로 표기하면</b></p>\n<p><b>O(n^2)으로 표기한다. 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것입니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>공간복잡도</b></p>\n<p>프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양, 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서</p>\n<p>필요로 할 경우도 포함한다.</p>\n<p>&nbsp;</p>\n<p>자료구조에서의 시간복잡도&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/wyV03/btsF4VLL8IN/m16eVAfZJkCKzkc497qUE1/img.png\" /></span></figure>\n</p>\n<p>이진탐색트리는 최악의 조건에 O(n)이다 한쪽으로 치우칠 수 있다.</p>\n<p>&nbsp;</p>\n<p><b>선형 자료 구조</b></p>\n<p>&nbsp;</p>\n<p>연결리스트</p>\n<p>- 연결리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조,</p>\n<p>삽입과 삭제가 O(n)이 걸리며 탐색에는 O(n)이 걸립니다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/OWpN5/btsF6382LjP/KgZKPrnKrmPRiLhksHJmj1/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>그림처럼 previous 포인터와 Next포인터로 앞과 뒤의 노드를 연결시킨 것이 연결리스트이며, 연결리스트는 싱글 연결리스트 ,이중 연결리스트,원형 이중 연결리스트가 있습니다. 맨앞의 있는 도르르 헤드라고도 합니다.<b></b></p>\n<p>&nbsp;</p>\n<p>싱글 연결 리스트: next 포인터만 가집니다</p>\n<p>이중 연결 리스트: next 포인터와 prev포인터를 가집니다.</p>\n<p>원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next포인터가 헤드노드를 가리키는 것을 의미, 원형 연결 리스트</p>\n<p>&nbsp;</p>\n<p>C++에서 이중 연결리스트 예제</p>\n<p>앞에서 요소를 넣을 때 push_front , 뒤에서 요소를 넣을 때 push_back() , 중간에 요소를 넣는 insert()</p>\n<p>&nbsp;</p>\n<p><b>배열</b></p>\n<p>배열은 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며,인접한 메모리 위치에 있는 데이터를 모아놓은 집합, 또한 중복을 허용하고 순서가 있습니다. 접근 참조에 O(1)의 시간복잡도를 가지며 랜덤접근이 가능합니다. 삽입과 삭제에는 O(n)이 걸립니다. 따라서 <span style=\"color: #ef6f53;\"><b>추가와 삭제를 많이하는 것은 연결리스트,접근을 많이하는 것은 배열로 하는 것이 좋습니다.</b></span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>랜덤 접근과 순차적 접근</b></p>\n<p>직접 접근이라고 하는 랜던접근은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능, 이는 데이터를 저장된 순서대로 검색해야하는 순차적 접근과는 반대입니다.</p>\n<p>&nbsp;</p>\n<p>n번째 요소의 접근은 배열이 빠리고 연결리스트는 느립니다. 배열의 경우 그저 상자 위에 있는 요소를 접근하면 되기 때문에 O(1)의 시간복잡도를 가집니다. 연결리스트와 같은 경우 매번 상자를 순차적으로 열어야하기 때문에 O(n)의 시간복잡도를 가집니다.</p>\n<p>참조가 많이 일어나는 작업의 많은 경우 배열이 빠르고, 연결리스트는 느립니다. 하지만 데이터 추가 및 삭제는 연결리스트가 더 빠르고 배열은 느립니다.</p>\n<p>&nbsp;</p>\n<p><b>벡터</b></p>\n<p><b>동적으로 요소를 할당할 수 있는 동적배열, 컴파일 시점에 개수를 모른다면 벡터를 써야합니다. 또한 중복을 허용하고 순서가 있고 랜덤 접근이 가능합니다. 탐색과 맨뒤 요소를 삭제하거나 탐색하는데 O(1)이 걸리며, 맨 뒤나 맨앞이 아닌 요소를 삭제하고 삽입하는데 O(n)의 시간이 걸립니다.</b></p>\n<p>&nbsp;</p>\n<p><b>스택&nbsp;</b></p>\n<p><b>ex) 재귀함수 or 방문기록</b></p>\n<p><b>스택은 가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 성질(LIFO,last in first out)을 가짐, 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.</b></p>\n<p>&nbsp;</p>\n<p><b>큐</b></p>\n<p><b>ex) cpu작업을 기다리는 프로세스, 스레드 행렬, 너비우선탐색,캐시</b></p>\n<p><b>먼저 넣은 데이터가 먼저 나오는 성질(FIFO, first in first out)</b></p>\n<p><b>삽입과 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>비선형 자료 구조</b></p>\n<p>비선형 자료구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말합니다. 일반적으로는 트리, 그래프</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>그래프</b></p>\n<p>&nbsp;</p>\n<p>그래프는 정점과 간선으로 이루어진 자료를 말합니다.</p>\n<p>&nbsp;</p>\n<p><b>정점과 간선</b></p>\n<p><b>정점은 target , 간선은 Line이라고 생각하면 된다.</b></p>\n<p><b> </b></p>\n<p><b>outdegree: 정점으로 나가는 간선</b></p>\n<p><b>indegree: 들어오는 간선</b></p>\n<p>&nbsp;</p>\n<p><b>가중치: 1번노드와 2번노드로 가는 비용</b></p>\n<p>&nbsp;</p>\n<p><b>트리</b></p>\n<p>&nbsp;</p>\n<p><b>그래프 중 하나로 그래프의 특징처럼 정점과 간선으로 이루어져 있고,트리 구조로 배열된 일종의 계층적 데이터 집합,</b></p>\n<p><b>root node,internal node,leaf node(자식이 없는 노드)로 이루어진 집합의 숲.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>트리의 높이와 레벨</b></p>\n<p><b>- 다음은 트리의 높이와 레벨을 설명한 그림입니다.</b><b></b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/A88Sr/btsF65eLek3/hpmHS213djUb8oBjYtnK0k/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>깊이: 트리에서의 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말합니다. 예를들어 4번 노드의 깊이는 2입니다.</p>\n<p>&nbsp;</p>\n<p>높이: 트리의 높이는 루트 노드부터 리프노드까지 거리 중 가장 긴 거리를 의미하며, 앞 그림의 트리 높이는 3 입니다.</p>\n<p>&nbsp;</p>\n<p>레벨: 1번 노드를 0레벨 ,2번노드,3번 노드를 1레벨, 1번노드를 1레벨이라고 한다면 2,3번 노드는 2레벨</p>\n<p>&nbsp;</p>\n<p>서브트리: 트리 내에 있는 부분집합, 5번,6번,7번 노드가 이 트리의 하위 집합으로 \"저 노드들은 서버트리이다\" 라고 합니다.</p>\n<p>&nbsp;</p>\n<p><b><b>이진 트리</b></b></p>\n<p><b><b>- 이진 트리는 자식의 노드 수가 두 개 이하인 트리를 의미합니다.</b></b></p>\n<p>&nbsp;</p>\n<p>이진트리 종류</p>\n<p>&nbsp;</p>\n<p>- 정이진 트리(full binary tree): 자식노드가 0 또는 두개의 이진트리를 의미합니다.</p>\n<p>- 완전 이진트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리를 의미합니다. 마지막 레벨을&nbsp;</p>\n<p>제외하고는 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 경우 왼쪽부터 채워져 있습니다.</p>\n<p>- 변질 이진트리(degenerate binary: 자식 조드가 하나밖에 없는 이진 트리를 의미합니다.</p>\n<p>- 포화 이진트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진트리를 의미합니다.</p>\n<p>- 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진 트리를 의미합니다.</p>\n<p>map,set을 구성하는 레드 블랙 트리는 균형 이진트리 중 하나 입니다.</p>\n<p>&nbsp;</p>\n<p>이진탐색트리</p>\n<p>&nbsp;</p>\n<p>BST는 노드의 오른쪽 하위트리에는 \"노드 값보다 큰 값\"이 있는 노드만 포함되고, 왼쪽 하위 트리에는 \"노드 값 보다 작은 값\"이 들어가는 트리를 말합니다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"365\" src=\"https://blog.kakaocdn.net/dn/bCBrBf/btsF5uGu93v/TSlOaBARW2OkQJFWJPO321/img.png\" width=\"619\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>보통 요소를 찾을 때 이진탐색트리는 O(logn)이 걸립니다. 하지만 최악의 경우 O(n)이 걸립니다.</p>\n<p>&nbsp;</p>\n<p>그 이유는 이진탐색 트리는 삽입 순서에 따라 선형적일 수 있다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"507\" src=\"https://blog.kakaocdn.net/dn/TaCsa/btsF5FOzcgu/E8NxOLDItOfUDbSumLvcS0/img.png\" width=\"385\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><b>AVL 트리</b></b></p>\n<p><b><b> </b></b></p>\n<p><b><b>앞서 설명한 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형잡힌 이진탐색트리 입니다.</b></b></p>\n<p><b><b>두 자식 서브트리의 높이는 항상 1만큼 차이 난다는 특징이 있다. 탐색,삽입,삭제, 모두 시간 복잡도가</b></b></p>\n<p><b><b>O(logN)이며 삽입,삭제할 때마다 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전ㄴ시키며 균형을 잡습니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>레드 블랙 트리</b></b></p>\n<p><b>레드 블랙 트리는 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logN)입니다.</b></p>\n<p><b>각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용됩니다.</b></p>\n<p>&nbsp;</p>\n<p><b>참고로 \"모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이며 그 노드의 자식은 반드시 블랙이다\" 등의 규칙을 기반으로</b></p>\n<p><b>균형을 잡는 트리입니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/4C5fQ/btsF5GUfeU8/Crr1bkQozNFywKBWKHnW4k/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><b>힙</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>힙은 완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리를 말합니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 합니다. 또한 각 노드의 자식 노드와의 관계도 이와같은 특징이 재귀적으로 이루어져야 합니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>최소힙: 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어 합니다. 또한 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어저야 합니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>힙에는 어떠한 값이 들어와도 특정 힙의 규칙을 지키게 만들어져 있습니다.&nbsp;</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>최대힙의 삽입</b></b></p>\n<p><figure class=\"imageblock floatLeft\"><span><img src=\"https://blog.kakaocdn.net/dn/eb87QE/btsF3UFB4S9/zkzEBQVc5QTq5vfLcbDRik/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><b>최대힙의 삭제</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>최대힙에서는 최댓값은 루트 노드이므로 루트노드가 삭제되고, 그 이후 마지막 노드와 루트 노드를 스왑하여 또 다시 스왑 등의 과정을 거쳐 재구성할 수 있습니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>우선순위 큐</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>우선순위 큐는 우선순위 대기열이라도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료구조 입니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>우선순위 큐는 힙을 기반으로 구현됩니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>맵</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조입니다. key value를 써서 할당한다.</b></b></p>\n<p><b><b>레드블랙트리자료 구조를 기반으로 형성되고 삽입하면 자동으로 정렬됩니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>맵을 쓸때는 map&lt;string,int) 형태로 구현합니다. 배열과 비슷하게 clear함수로 모든요소를 삭제할 수 있고 size()로 map의 크기를 구할 수 있습니다. 또한 erase()로 해당 키와 매핑된 키값을 지울 수 있습니다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>map은 해시테이블을 구현할 때 쓰며 정렬을 보장하지 않은 unordered_map과 정렬을 보장하는 map이 있다.</b></b></p>\n<p>&nbsp;</p>\n<p>map을 순회할 때는 키에 해당하는 key을 first, 키에 매핑된 값에 해당하는 값을 second로 탐색 합니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><b>셋</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>셋은 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며,중복되는 요소는 없고 오로지 유니크한 값만 저장한다.</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>해시테이블</b></b></p>\n<p>&nbsp;</p>\n<p><b><b>해시테이블은 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블입니다. 삽입,삭제.,탐색 시 평균적으로</b></b></p>\n<p><b><b>O(1)의 시간을 가지며 unordered_map으로 구현합니다.</b></b></p>\n<p>&nbsp;</p>\n<h2 style=\"background-color: #ffffff; color: #0a0b0c; text-align: start;\">정리</h2>\n<p>HASHMAP</p>\n<p>HASHTABLE</p>\n<p>CONCURRENTHASHMAP</p>\n<table border=\"1\" style=\"background-color: #ffffff; color: #303a3e; text-align: start; border-collapse: collapse; width: 100%;\">\n<tbody>\n<tr>\n<td style=\"text-align: center;\">key와 value에 null 허용</td>\n<td style=\"text-align: center;\">O</td>\n<td style=\"text-align: center;\">X</td>\n<td style=\"text-align: center;\">X</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">동기화 보장(Thread-safe)</td>\n<td style=\"text-align: center;\">X</td>\n<td style=\"text-align: center;\">O</td>\n<td style=\"text-align: center;\">O</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">추천 환경</td>\n<td style=\"text-align: center;\">싱글 쓰레드</td>\n<td style=\"text-align: center;\">멀티 쓰레드</td>\n<td style=\"text-align: center;\">멀티 쓰레드</td>\n</tr>\n</tbody>\n</table>\n<p style=\"color: #333333; text-align: left;\">&nbsp;</p>\n<h2 style=\"background-color: #ffffff; color: #0a0b0c; text-align: start;\">결론</h2>\n<p style=\"background-color: #ffffff; color: #303a3e; text-align: start;\">싱글 쓰레드 환경이면 HashMap을, 멀티 쓰레드 환경이면 HashTable이 아닌 ConcurrentHashMap을 쓰자. 그 이유는 HashTable보다 ConcurrentHashMap이 성능적으로 우수하기 때문이다. 앞에서도 언급했듯이 HashTable은 쓰레드간 락을 걸어 데이터를 다루는 속도가 느리다. 반면, ConcurrentHashMap은 Entry 아이템별로 락을 걸어 데이터를 다루는 속도가 빠르다.</p>",
		"date": "Mar 26, 2024",
		"writer": "11기 김민우"
	},
	"feed-14": {
		"title": "면접을 위한 CS 전공지식 노트 2장",
		"link": "https://minwoo-it-factory.tistory.com/entry/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B8-2%EC%9E%A5",
		"description": "<h3><b>네트워크 기초</b><b></b></h3>\n<p>&nbsp;</p>\n<p><b>네트워크란 노드와 링크가 서로 연결되어 있거나 연결되어 있으며 리소스를 공유하는 집합,</b></p>\n<p><b>여기서 노드는 서버,라우터,스위치 등 네트워크 장치를 의미하고 링크는 유선 또는 무선을 의미합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>처리량과 지연 시간</b></p>\n<p>&nbsp;</p>\n<p><b>네트워크를 구축할 때 \"좋은: 네트워크로 만드는 것이 중요합니다. 좋은 네트워크란 많은 처리량을 처리할 수 있으며 지연시간이 짧고 장애 빈도가 적으며 좋은 보안을 갖춘 네트워크를 말합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>처리량</b></p>\n<p>&nbsp;</p>\n<p><b>- 처리량은 링크 내에서 성공적으로 전달된 데이터의 양을 말하며 보통 얼만큼의 트래픽을 처리했는지를 나타냅니다.</b></p>\n<p><b>\"많은 트래픽을 처리한다= 많은 처리량을 가진다\"</b></p>\n<p>&nbsp;</p>\n<p><b>단위로는 bps(bits per second)를 씁니다. 초당 전송 또는 수신되는 비트 수라는 의미입니다. 처리량은 사용자들이 많은 접속할 때마다 커지는 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러, 장치의 하드웨어 스펙에 영향을 받습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>트래픽이 많아짐 -&gt; 흐르는 데이터가 많아졌다</b></p>\n<p><b>처리량이 많아짐 -&gt; 처리되는 트래픽이 많아졌다</b></p>\n<p>&nbsp;</p>\n<p><b>대역폭 - 주어진 시간동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수</b></p>\n<p>&nbsp;</p>\n<p><b>지연시간 - latency&nbsp;</b></p>\n<p><b>요청이 처리되는 시간을 말하며 어떤 메세지가 두 장치 사이를 왕복하는 데 걸린 시간을 말합니다 .</b></p>\n<p>&nbsp;</p>\n<p><b>지연시간은 매체타입(무선,유선) , 패킷 크기, 라우터의 패킷 처리시간에 영향을 받습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>네트워크 토폴리지와 병목현상</b></p>\n<p>&nbsp;</p>\n<h4><b>네트워크 토폴리지</b></h4>\n<p>&nbsp;</p>\n<p><b>노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결형태를 의미합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>트리 토폴리지</b></p>\n<p>&nbsp;</p>\n<p>계층형 토폴로지라고 하며 트리 형태로 배치한 네트워크 구성을 말합니다.</p>\n<p>노드의 추가 , 삭제가 쉬우며 특정 노드에 트래픽이 집중될 때 하위 노드에 영향을 끼칠 수 있습니다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/F4ReQ/btsF1jMWXRz/lMLaNjddKfmZVbNwkF5lkk/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>버스 토폴리지</b></p>\n<p>&nbsp;</p>\n<p><b>중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 네트워크 구성을 말하며 근거리 통신망(LAN)에서 사용합니다.<br /></b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/pkFfj/btsF1kZmkt3/apGoAeIEKbs4tZKv7lbUy0/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>설치 비용이 적고 신뢰성이 우수하며 중앙 통신 회선에 노드를 추가하여 삭제하기 쉽습니다. 그러나 스푸핑이 가능한 문제점이 있습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>스푸핑이란 ?</b></p>\n<p><b>LAN상에서 송신부에 패킷을 송신과 관련 없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서 특정 노드에 해당 해킷이 오도록 처리하는 것을 말합니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bndej9/btsF11rf3Ul/mfiV9f9Lmwq0Od91XadsJK/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>스푸핑을 적용하면 올바르게 수신부로 가야 할 패킷이 악의적인 노드에 전달되게 됩니다.</p>\n<p>&nbsp;</p>\n<p><b>스타 토폴리지</b></p>\n<p>&nbsp;</p>\n<p><b>중앙에 있는 노드에 모두 연결된 네트워크 구성을 말합니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/ygrmu/btsF3UkiTHY/kP4JrvwCHpZpT7JG5G8gVK/img.png\" /></span></figure>\n</p>\n<p>노드를 추가하거나 에러를 탐지하기 쉽고 패킷의 충돌발생 가능성이 적습니다. 또한 어떠한 노드에 장애가 발생해도 쉽게 에러를 발견할 수 있으며 장애 노드가 중앙 노드가 아닐 경우 다른 노드에 영향을 끼치는 것이 적다 하지만 중앙 노드에 장애가 발생하면 전체 네트워크를 사용할 수 없고 설치비용이 고가 입니다.</p>\n<p>&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\"><b>링형 토폴리지</b></p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p style=\"color: #333333; text-align: start;\">각각의 노드가 양 옆의 두 노드와 연결하여 전체적으로 고리처럼 하나의 연속된 길을 통해 통신을 하는 망 구성 방식</p>\n<p style=\"color: #333333; text-align: start;\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/61Qlo/btsF4AsrLFs/3RPJ5UrtF8tUmeJMDgO7B1/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>노드 수가 증가되어도 네트워크상의 손실이 거의 없고 충돌이 발생되는 가능성이 적고 노드의 고장 발견을 쉽게 찾을 수 있습니다. 하지만 네트워크 구성 변경이 어렵고 회선에 장애가 발생하면 전체 네트워크에 영향을 크게 끼치는 단점이 있습니다.&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>메시 토폴리지</b></p>\n<p>&nbsp;</p>\n<p><b>망형 토폴리지라고도 하며 그물망처럼 연결되어 있는 구조입니다.</b></p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/b1T2Oh/btsF12cGvsY/IlRJQRiuWjWMzG9KNuukHk/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>한 단말 장치에 장애가 발생해도 여러개의 경로가 존재하므로 네트워크를 계속 사용할 수 있고 트래픽도 분산처리가 가능합니다. 하지만 노드의 추가가 어렵고 구축 비용과 운용 비용이 고가인 단점이 있습니다.</p>\n<p>&nbsp;</p>\n<p>-병목현상이란?</p>\n<p>전체시스템의 성능이나 용량이 하나의 구송 요소로 인해 제한을 받는 현상</p>\n<p>&nbsp;</p>\n<h4 style=\"color: #000000; text-align: start;\"><b>네트워크 분류</b></h4>\n<p>&nbsp;</p>\n<p><b>LAN: 근거리 통신망을 의미하며 같은 건물이나 캠퍼스 같은 좁근 공간에서 운영됩니다. 전송속도가 빠르고 혼잡하지 않습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>MAN: 대도시 지역 네트워크를 나타내며 도시 같은 넓은 지역에서 운영됩니다. 전송 속도는 평균이며 LAN보다는 더 많이 혼잡합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>WAN: 광역 네트워크를 의미하며 국가 또는 대륙 같은 더 넓은 지역에서 운영됩니다. 전송 속도는 낮으며 MAN보다 더 혼잡합니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4 style=\"color: #000000; text-align: start;\"><b>네트워크 성능 분석 명령어</b></h4>\n<p><b>네트워크 병목 현상의 주된 원인은 다음과 같습니다</b></p>\n<p>&nbsp;</p>\n<p><b>- 네트워크 대역폭</b></p>\n<p><b>- 네트워크 토폴로지</b><b></b></p>\n<p><b>- 서버 CPU, 메모리 사용량</b></p>\n<p><b>- 비효율적인 네트워크 구성</b></p>\n<p>&nbsp;</p>\n<p><b>ping</b></p>\n<p>&nbsp;</p>\n<p><b>ping(Packet Internet Grouper)은 네트워크 ㅅ항태를 확인하려는 대상 노드를 향해 일정한 패킷을 전송하는 명령어</b></p>\n<p><b>이를 통해 해당 노드의 패킷 수신 상태와 도달하기 까지 시간 등을 알 수 있으며 해당 노드까지 네트워크가 잘 연결되어 있는지 확인할 수 있습니다. ping 은 TCP/IP 중 ICMP 프로토콜을 통해 동작하며 이 떄문에&nbsp; ICMP프로토콜을 지원하지 않은 기기를 대상으로는 실행할 수 없거나 네트워크 정책 상 ICMP나 traceout를 차단하는 대상의 경우 ping 테스팅은 불가능합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>netstat </b></p>\n<p>&nbsp;</p>\n<p><b>접속되어 있는 서비스들의 네트워크 상태를 표시하는데 사용되며 네트워크 접속,라우팅 테이블,네트워크 프로토콜 등 리스트를 보여줍니다. 주로 서비스의 포트가 열려 있는지 확인할 때 씁니다.</b></p>\n<p>&nbsp;</p>\n<p><b>nslookup</b></p>\n<p>&nbsp;</p>\n<p><b>DNS에 관련된 내용을 확인하기 위해 쓰는 명령어 특정 도메인에 매핑된 IP를 확인하기 위해 사용합니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>tracert&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>윈도우에서는 tracert이고 리눅스에서는 traceoute라는 명령어로 구동된다. 목적지 노드까지의 네트워크 경로를 확인할 때 사용 목적지 노드까지 구간들 중 어느 구간에서 응답 시간이 느려지는지 등을 확인할 수 있다.</b></p>\n<p>&nbsp;</p>\n<h4 style=\"color: #000000; text-align: start;\"><b>TCP/IP 4계층</b></h4>\n<p>&nbsp;</p>\n<p><b>인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 프로토콜의 집합입니다.</b></p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/lUgZJ/btsF1JkbbwX/qjZTkEb8qPzOORCDLIcDb0/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>애플리케이션 계층</b></p>\n<p><b>FTP,HTTP,SSH,SMTP,DNS 등 응용 프로그램이 사용되는 프로토콜 계층이며 웹 서비스 ,이메일 등 서비스를 실질적으로 사람들에게 제공하는 층입니다.</b></p>\n<p>&nbsp;</p>\n<p><b>전송계층</b></p>\n<p><b>- 전송계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하며 연결 지향 데이터 스트림지원, 신뢰성,흐름제어를 제공합니다. 대표적으로 TCP,UDP가 있습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>TCP는 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부를 확인하여 가상회선 패킷 교환방식이라고 합니다.&nbsp; 3way handshake와 4way handshake에 대한 이해가 필요하다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bUzcLM/btsF3TFLgoi/dytljSxydYDaLYNgD1kvpK/img.png\" width=\"451\" /></span></figure>\n<figure class=\"imageblock alignCenter\"><span><img height=\"279\" src=\"https://blog.kakaocdn.net/dn/lFY1u/btsF4WPK8eQ/7lTYbFRPwGNfNBKTiaPcrk/img.png\" width=\"461\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>UDP는 순서를 보장하지 않고 수신 여부를 확인하지 않으며 단순히 데이터만 주는 데이터그램 패킷 교환방식을 사용합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>TCP 가상회선 패킷 교환방식&nbsp;</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/HEn6n/btsF3F8Dhoa/X2FZqOPq3nRsHOHfjwcadK/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>인터넷 계층</b></p>\n<p>&nbsp;</p>\n<p><b>인터넷계층은 장치로부터 받은 네트워크 패킷을 IP주소로 지정된 목적지로 전송하기 위해 사용되는 계층입니다. IP,ARP,ICMP등이 있으며 패킷을 수신해야 할 상대의 주소를 지정하여 데이터를 전달합니다. 상대방이 제대로 받았는지 에 대해 보장하지 않는 비연결형적인 특징을 가지고 있습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>링크 계층</b></p>\n<p>&nbsp;</p>\n<p><b>전선 , 광섬유,무선 등으로 실질적으로 데이터를 전달하며 장치 간에 신호를 주고받는 \"규칙\"을 정하는 계층</b></p>\n<p><b>물리계층은 무선LAN과 유선 LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층, 데이터 링크계층은 이더넷 프레임을 통해 에러확인 , 흐름제어 ,접근제어를 담당</b></p>\n<p>&nbsp;</p>\n<h4><b>네트워크 기기</b></h4>\n<p>&nbsp;</p>\n<p><b>애플리케이션 계층:L7 스위;치</b></p>\n<p><b>인터넷 계층: L3 스위치</b></p>\n<p><b>데이터링크: L2 스위치,브리지</b></p>\n<p><b>물리계층:NIC,리피터 ,AP</b></p>\n<p>&nbsp;</p>\n<p><b>L7스위치는 로드밸런서라고도 하며 , 서버의 부하를 분산하는 기기입니다. 클라이언트로부터 오는 요청들을 뒤쪽의 여러서버로 나누는 역할을 하며 시스템이 처리할 수 있는 트래픽 증가를 목표로 합니다.</b></p>\n<p>&nbsp;</p>\n<p><b>URL,서버,캐시,쿠키들을 기반으로 트래픽을 분산합니다. 또한 , 바이러스 ,불필요한 외부 데이터 등을 걸러내는 필터링 기능 또한 가지고 있으며 응용 프로그램 수준의 트래픽 모니터링도 가능합니다.</b></p>\n<p><b>만약 장애가 발생한 서버가 있다면 이를 트래픽 분산 대상에서 제외해야하는 , 이는 정기적으로 헬스체크를 이용하면서 감시하고 이루어집니다.</b></p>\n<p>&nbsp;</p>\n<p><b>L4스위치</b></p>\n<p><b>IP와 포트를 기반으로(특히 포트를 기반으로) 트래픽을 분산처리 합니다.&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>AWS에서는 L7스위치를 이용한 로드밸런서인 ALB를 사용하고 , L4는 NLB를 사용합니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b>NAT</b></p>\n<p>&nbsp;</p>\n<p><b>NAT(network address translation)는 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP주소를 다른 주소로 매핑하는 방법입니다. IPv4 주소체계만으로는 많은 주소들을 모두 감당하지 못하는 단점이 있는데, 이를 해결하기 위해 NAT로 공인 IP와 사설 IP로 나눠서 많은 주소를 처리합니다. NAT를 가능하게 하는 소프트웨어는 ICS,RRAS,Netfilter등이 있습니다.</b></p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/N8Rq6/btsF3UY0ngY/eSdWOgbMoHFUmYKcRMe2Zk/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>앞의 그림처럼 홍철 팀장, 가영대리는 192.168.0.xxx를 기반으로 각각의 다른 IP를 가지고 있습니다. 이는 사설 IP라고 합니다. 그리고 NAT 장치를 통해 하나의 공인 IP인 121.165.151.200으로 외부 인터넷에 요청할 수 있습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>이를 통해 어비스 회사에 있는 홍철 팀장과 가영 대리는 하나의 IP인 121.165.151.200을 기반으로 각각의 다른 IP를 가지는 것 처럼 인터넷을 사용할 수 있습니다. 이처럼 NAT장치를 통해 사설 IP를 공인 IP로 변환하거나 공인 IP를 사설 IP로 변환하는데 사용됩니다.</b></p>\n<p>&nbsp;</p>\n<p><b>NAT를 이용한 보안&nbsp;</b></p>\n<p>&nbsp;</p>\n<p><b>NAT를 이용하면 내부 네트워크에서 사용하는 IP주소와 외부에 드러나는 IP주소를 다르게 유지할 수 있기 떄문에 내부 네트워크에 대한 어느정도의 보안이 가능합니다.</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4 style=\"color: #000000; text-align: start;\"><b>HTTP</b></h4>\n<p><b>HTTP/1.0은 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었습니다.이는 RTT 증가를 불러왔습니다.</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/dZa2vU/btsF2QJyvMu/alFbq9w0m7oZpqARaaeln0/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><b>서버로부터 파일을 가져올 때마다 TCP의 3웨이 핸드셰이크를 계속해서 열어줘야하기 때문에 RTT증가하는 단점이 있었습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>RTT(<span style=\"background-color: #ffffff; color: #1f1f1f; text-align: left;\">Round trip delay)</span> ? 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며 , 패킷 왕복시간이라고 생각하면된다.</b></p>\n<p>&nbsp;</p>\n<p><b>RTT해결하기위한 방법&nbsp;</b></p>\n<p><b>- 매번 연결할 때마다 RTT가 증가하니 서버에 부담이 많이 가고 사용자 응답시간이 길어졌습니다. 이를 해결하기 위해&nbsp;</b></p>\n<p><b>이미지 스플리팅,코드 압축,이미지 Base64인코딩사용했습니다.</b></p>\n<p>&nbsp;</p>\n<p><b>이미지 스플리팅</b></p>\n<p>&nbsp;</p>\n<p>하나의 이미지인 icons.png를 기반으로 background-position을 통해 2개의 이미지를 설정하여 해결</p>\n<p>&nbsp;</p>\n<p>코드 압축</p>\n<p>&nbsp;</p>\n<p>코드를 압축하여 개행문자,빈칸을 없애서 코드의 크기를 최소화</p>\n<p>&nbsp;</p>\n<p>이미지 Base64인코딩</p>\n<p>&nbsp;</p>\n<p>64진법으로 이루어진 문자열로 인코딩. 이 방법을 사용하며 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없다는 장점이 있습니다.하지만 문자열로 변환할 경우 37% 정도로 크기가 더 커지는 단점이 있습니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4><b>HTTP/1.1</b></h4>\n<p>&nbsp;</p>\n<p><b>HTTP/1.0에서 발전한 것이 바로 HTTP/1.1입니다. 매번 TCP연결을 하는 것이 아닌 , 한번 TCP초기화를 한 이후에 keep -alive라는 옵션으로 여러개의 파일을 송수신 할 수 있도록 바뀌었습니다. 1.0에도 있엇지만 표준화가 되지 않았다.</b></p>\n<p><b>그래서 1.1부터 기본옵션으로 설정되었음</b></p>\n<p>&nbsp;</p>\n<p><b>하지만 1.1로 단점이 존재함 . 다수의 리소스(이미지,동영상,css 파일 ,js파일 등)를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있었다.</b></p>\n<p>&nbsp;</p>\n<p><b>HOL Blocking</b></p>\n<p>&nbsp;</p>\n<p><b>네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연이 될때 발생하는 성능 저하 현상</b></p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/chtK6l/btsF3Ty2Xf7/j1fCthnLUKRKXZufrsJQ81/img.png\" /></span></figure>\n</p>\n<p>image.jpg가 느리게 받아진다면 그 뒤에 있는 것들이 대기하며 다운로드가 지연되는 상태가 된다.</p>\n<p>&nbsp;</p>\n<p><b>무거운 헤더구조</b></p>\n<p><b>HTTP1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어가 있고 압축이 되지않아 무거웠다.</b></p>\n<h4>&nbsp;</h4>\n<h4><b>HTTP/2.0</b></h4>\n<p>&nbsp;</p>\n<p><b>HTTP/2 은 HTTP/1.x보다 지연시간을 줄이고 응답시간을 더 빠르게 할 수 있으며 멀티플렉싱,헤더압축,서버푸시,요청의 우선순위 처리를 지원하는 프로토콜</b></p>\n<p>&nbsp;</p>\n<p><b>멀티플렉싱이란 ?</b></p>\n<p>&nbsp;</p>\n<p><b>여러개의 스트림을 사용하여 송수신 한다는 것입니다. 이를 통해 특정 스트름의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 끼치고 나머지 스트림을 멀쩡하게 동작함.</b></p>\n<p>&nbsp;</p>\n<p><b>스트림이란 ?</b></p>\n<p>&nbsp;</p>\n<p><b>시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름</b></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bp2NrL/btsF4z8glT3/8qrbZp6Hgck0v4csKAMrV0/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>병렬적인 스트림을 통해 데이터를 서빙하고있다. 스트림내의 데이터 들도 쪼개어져 있습니다. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 후 다시 조립하여 데이터를 주고 받습니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>이로써 2.0에서는 단일 연결을 사용하여 병렬로 여러 요청을 받을 수 있고, 응답을 줄일 수 있었습니다. 이렇게 되면 HTTP/1.x에서 발생하는 문제인 HOL Blocking( <span style=\"background-color: #ffffff; color: #1f1f1f; text-align: left;\">Head-of-line blocking</span> )문제를 해결할 수 있고 keep-alive 및 헤더크기문제를 해결할 수 있습니다.</p>\n<p>&nbsp;</p>\n<p>HTTP2.0에서는 헤더압축을 써서 해결하는데 이때 허프만 코딩 압축 알고리즘을 사용하여 HPACK 압축 형식을 가집니다.</p>\n<p>&nbsp;</p>\n<p>허프만 코딩이란 ?</p>\n<p>문자열을 문자단위로 쪼개 빈도수를 세어 빈도가 높은 정보를 적은 비트 수를 사용하여 표현하고,빈도가 낮은 정보를 비트 수를 많인 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리입니다.</p>\n<p>&nbsp;</p>\n<p>서버푸시</p>\n<p>&nbsp;</p>\n<p>HTTP1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드받을 수 있었다면 , HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있습니다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/1N3Wk/btsF5tUgQ2l/SIZn5VuN1kIJ7rIswgGTF1/img.png\" /></span></figure>\n</p>\n<p>이로써 html에는 css나 js파일이 포함되기 마련인데 html파일을 읽으면서 그 안에 들어 있던 css파일을 서버에 푸시하여 클라이언트에 먼저 줄 수 있습니다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4 style=\"color: #000000; text-align: start;\"><b>HTTPS</b></h4>\n<p>HTTP/2는 HTTPS위에서 동작합니다. HTTPS는 애플리케이션 계층과 전송계층 사이에 신뢰계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP요청을 말합니다. 통신을 암호화한다.</p>\n<p>&nbsp;</p>\n<p>SSL/TLS은 전송계층에서 보안을 제공하는 프로토콜입니다. 클라이언트와 서버가 통신할 때 SSL/TLS을 통해 제 3자가 메세지를 도청하거나 변조하지 못하도록 합니다.</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/cBmD1F/btsF1SnQ2Yp/thTR1HUQ5UI2TvkYJCOvK1/img.png\" /></span><figcaption>S</figcaption>\n</figure>\n</p>\n<p>SSL/TLS를 통해 공격자가 서버인 척 하며 사용자의 정보를 가로채는 네트워크상의 \"인터셉터\"를 방지할 수 있습니다.&nbsp;</p>\n<p>SSL/TLS 는 보안세션을 기반으로 데이터를 암호화하며 보안세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘,해싱알고리즘이 사용됩니다.</p>\n<p>&nbsp;</p>\n<p>보안세션이란 ?</p>\n<p>보안이 시작되고 끝나는 동안 유지되는 세션을 말하고, SSL/TLS는 핸드셰이크를 통해 보안세션을 생성하고 이를 기반으로 상태 정보를 공유합니다.</p>\n<p>&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/RUYkF/btsF4UdrOX1/SSe414lHCPhxUFmzclQj6k/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p>클라이언트와 서버와 키를 공유하고 이를 기반으로 인증합니다. 인증 확인 등의 작업이 일어나는 단 한번의 1-RTT가 생긴 후 데이터를 송신하는 것을 볼 수 있습니다.</p>\n<p>&nbsp;</p>\n<p>클라이언트에서 사이퍼 슈트를 서버에 전달하면 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인합니다. 제공할 수 있다면 서버에서 클라이언트로 인증서는 보내는 인증 메커니즘이 시작되고 이후 해싱 알고리즘 등으로 암호화 된 데이터를 송수신을 시작합니다.</p>\n<p>&nbsp;</p>\n<p>사이퍼 슈트란 ?</p>\n<p>&nbsp;프토토콜, 해싱 알고리즘이 나열된 규약을 말합니다.</p>\n<p>&nbsp;</p>\n<p>인증매커니즘이란 ?</p>\n<p>&nbsp;</p>\n<p>CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어집니다. CA에서 발급한 인증서는 안전한 연결을 시작하는데 있어 필요한 공개키를 클라이언트에 제공하고 사용자가 접속한 :\"서버가 신뢰\"할 수 있다는 서버임을 보장합니다. 인증서는 서비스 정보 ,공개 키 ,지문,디지털 서명등으로 이루어져 있다.</p>\n<p>&nbsp;</p>\n<p>CA는 아무기업이나 할 수 있는 것이 아닌 , 신뢰성이 엄격한 공인된 기업들만 참여할 수 있다.</p>\n<p>&nbsp;</p>\n<p>CA발급과정</p>\n<p>&nbsp;</p>\n<p>자신의 서비스가 CA인증서를 발급받으려면 자신의 사이트 정보와 공개키를 CA에 제출해야합니다. 이후 CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키 등을 기반으로 CA인증서를 발급해줍니다.</p>\n<p>&nbsp;</p>\n<p>SHA256 해싱 알고리즘</p>\n<p>- 단방향이며 , 해시 함수의 결과값이 256비트인 알고리즘입니다. 복호화 불가능</p>\n<p>&nbsp;</p>\n<p>HTTPS 구축방법 3가지&nbsp;</p>\n<p>&nbsp;</p>\n<p>직접 CA에 구매한 인증서를 기반으로 HTTPS 서비스 구축 , 서버 앞단에 HTTPS를 제공하는 로드밸런서 구축 ,서버 앞단에 HTTPS를 제공하는 CDN을 둬서 구축</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ee2323;\"><b>HTTPS정리 정말 잘 해놓았다.. 이거보자 대박..! 와이어샤크로 캡처까지...</b></span></p>\n<p>&nbsp;</p>\n<p><a href=\"https://nuritech.tistory.com/25\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://nuritech.tistory.com/25</a></p>\n<figure contenteditable=\"false\" id=\"og_1711340592836\"><a href=\"https://nuritech.tistory.com/25\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">HTTPS 통신 원리 쉽게 이해하기 (Feat. SSL Handshake, SSL 인증서)</p>\n<p class=\"og-desc\">이 글을 쓰게 된 이유는,, 나의 평소 HTTPS 에 대한 지식은 HTTPS 가 암호화된 네트워크 통신 프로토콜이고 HTTPS 를 사용한 네트워크 통신에서는 주고받는 패킷을 까도 데이터가 암호화되어 있어 안</p>\n<p class=\"og-host\">nuritech.tistory.com</p>\n</div>\n</a></figure>\n<p>&nbsp;</p>\n<p>간단하게 HTTPS 정리!</p>\n<p>&nbsp;</p>\n<p>1.&nbsp;client&nbsp;&rarr;&nbsp;server&nbsp;연결을&nbsp;시도한다&nbsp;(Client&nbsp;Hello) <br />이때,&nbsp;전송하는&nbsp;패킷에는&nbsp;아래의&nbsp;내용들이&nbsp;들어있다.&nbsp;(아래&nbsp;패킷&nbsp;캡처&nbsp;참고) <br /><br />자신(client)이&nbsp;사용&nbsp;가능한&nbsp;cipher&nbsp;suite&nbsp;목록&nbsp;(cipher&nbsp;suite&nbsp;예시&nbsp;:&nbsp;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA) <br />이&nbsp;cipher&nbsp;suite&nbsp;에&nbsp;어떤&nbsp;프로토콜(TLS/SSL)을&nbsp;사용할지,&nbsp;인증서&nbsp;검증&nbsp;또는&nbsp;데이터를&nbsp;어떤&nbsp;방식으로&nbsp;암호화할지&nbsp;등이&nbsp;표시된다. <br />session&nbsp;id <br />ssl&nbsp;protocol&nbsp;version <br /><br />2.&nbsp;server&nbsp;&rarr;&nbsp;client&nbsp;응답&nbsp;(Server&nbsp;Hello) <br />1번에서&nbsp;클라이언트에서&nbsp;받은&nbsp;인사(Client&nbsp;Hello&nbsp;패킷)에&nbsp;대해&nbsp;서버가&nbsp;응답을&nbsp;한다.&nbsp;이&nbsp;역시&nbsp;패킷을&nbsp;찍어보면&nbsp;Server&nbsp;Hello&nbsp;라고&nbsp;나오는&nbsp;것을&nbsp;확인할&nbsp;수&nbsp;있다. <br /><br />이때,&nbsp;서버는&nbsp;어떤&nbsp;내용을&nbsp;담아서&nbsp;응답하냐면, <br /><br />클라이언트에서&nbsp;받은&nbsp;cipher&nbsp;suite&nbsp;목록&nbsp;중&nbsp;선택한&nbsp;1개의&nbsp;cipher&nbsp;suite <br />ssl&nbsp;protocol&nbsp;version <br />등등 <br /><br />3.&nbsp;server&nbsp;&rarr;&nbsp;client&nbsp;(Certificate,&nbsp;&nbsp;Server&nbsp;Key&nbsp;Exchange,&nbsp;&nbsp;Server&nbsp;Hello&nbsp;Done) <br />이&nbsp;Certificate&nbsp;라는&nbsp;패킷에는&nbsp;어떤&nbsp;내용들이&nbsp;담겨&nbsp;있냐면,&nbsp;Server&nbsp;의&nbsp;SSL&nbsp;인증서&nbsp;내용이&nbsp;들어있다.&nbsp;아래의&nbsp;패킷&nbsp;내부를&nbsp;보면,&nbsp;인증서의&nbsp;signature&nbsp;algorithm,&nbsp;public&nbsp;key&nbsp;info&nbsp;등을&nbsp;확인할&nbsp;수&nbsp;있다. <br /><br />보면&nbsp;Server&nbsp;Key&nbsp;Exchange&nbsp;가&nbsp;있는&nbsp;것을&nbsp;볼&nbsp;수&nbsp;있는데&nbsp;이건&nbsp;뭐냐! <br />위에서&nbsp;전달한&nbsp;Certificate&nbsp;내의&nbsp;SSL&nbsp;인증서에&nbsp;서버의&nbsp;공개키(public&nbsp;key)가&nbsp;없는&nbsp;경우,&nbsp;서버가&nbsp;직접&nbsp;전달함을&nbsp;의미한다.&nbsp;즉,&nbsp;인증서&nbsp;내부에&nbsp;서버의&nbsp;공개키가&nbsp;존재한다면&nbsp;Server&nbsp;Key&nbsp;Exchange&nbsp;는&nbsp;생략된다! <br /><br />4.&nbsp;client&nbsp;에서&nbsp;server&nbsp;의&nbsp;SSL&nbsp;인증서&nbsp;검증&nbsp; <br /><br />SSL&nbsp;인증서를&nbsp;발급한&nbsp;CA(인증기관)는&nbsp;CA의&nbsp;비밀키(private&nbsp;key)를&nbsp;이용해&nbsp;인증서를&nbsp;암호화했다.&nbsp;그래서&nbsp;SSL&nbsp;인증서는&nbsp;CA의&nbsp;공개키를&nbsp;이용해서만&nbsp;복호화&nbsp;할&nbsp;수&nbsp;있다.&nbsp;클라이언트는&nbsp;해당&nbsp;CA의&nbsp;공개키를&nbsp;통해&nbsp;암호화된&nbsp;인증서를&nbsp;복호화&nbsp;한다.&nbsp;즉,&nbsp;클라이언트에서&nbsp;CA&nbsp;의&nbsp;공개키를&nbsp;이용해&nbsp;인증서를&nbsp;복호화했을&nbsp;때,&nbsp;복호화가&nbsp;되었다는&nbsp;것은&nbsp;인증서는&nbsp;해당&nbsp;CA&nbsp;에서&nbsp;발급되었다라는&nbsp;것을&nbsp;검증할&nbsp;수&nbsp;있는&nbsp;것. <br /><br />그렇다면,&nbsp;클라이언트는&nbsp;CA&nbsp;의&nbsp;공개키를&nbsp;어디서&nbsp;구할까? <br /><br />클라이언트가&nbsp;브라우저&nbsp;또는&nbsp;안드로이드&nbsp;기기일&nbsp;경우에는,&nbsp;인증서를&nbsp;발급하는&nbsp;주요&nbsp;인증기관(CA)의&nbsp;리스트와&nbsp;공개키를&nbsp;가지고&nbsp;있다.&nbsp;그래서&nbsp;매번&nbsp;CA로&nbsp;요청하는&nbsp;것이&nbsp;아닌&nbsp;가지고&nbsp;있는&nbsp;리스트에서&nbsp;확인할&nbsp;수&nbsp;있다. <br /><br />그러나,&nbsp;리스트에&nbsp;없다면&nbsp;외부&nbsp;인터넷을&nbsp;통해&nbsp;인증기관의&nbsp;정보와&nbsp;공개키를&nbsp;확보한다.&nbsp;이것이&nbsp;SSL&nbsp;인증서를&nbsp;사용&nbsp;시&nbsp;인터넷&nbsp;접속이&nbsp;필요한&nbsp;이유! <br /><br />&nbsp; <br /><br /> &nbsp;SSL&nbsp;인증서&nbsp;검증&nbsp;정리 <br /><br />클라이언트는&nbsp;인증서를&nbsp;발급한&nbsp;인증기관(CA)의&nbsp;공개키를&nbsp;구함. <br />1번에서&nbsp;구한&nbsp;공개키를&nbsp;이용해&nbsp;SSL&nbsp;인증서를&nbsp;복호화. <br />복호화&nbsp;성공&nbsp;시,&nbsp;인증서&nbsp;검증&nbsp;성공&nbsp;  <br /><br /><br />5.&nbsp;client&nbsp;&rarr;&nbsp;server&nbsp;대칭키(비밀키)&nbsp;전달&nbsp;(Client&nbsp;Key&nbsp;Exchange,&nbsp;Change&nbsp;Ciper&nbsp;Spec) <br /><br />이제&nbsp;클라이언트는&nbsp;서버와&nbsp;원하는&nbsp;데이터를&nbsp;안전하게&nbsp;주고받기&nbsp;위해서는&nbsp;전달하는&nbsp;데이터를&nbsp;암호화해야&nbsp;한다.&nbsp;클라이언트는&nbsp;데이터를&nbsp;암호화하기&nbsp;위한&nbsp;대칭키(비밀키,&nbsp;데이터를&nbsp;암호화하는&nbsp;키)를&nbsp;생성한다.&nbsp; <br /><br />이렇게&nbsp;생성한&nbsp;대칭키(비밀키)를&nbsp;서버에&nbsp;전달해야&nbsp;하는데,&nbsp;그냥&nbsp;전달하면&nbsp;큰일&nbsp;나겠지?&nbsp;탈취되면&nbsp;누구나&nbsp;주고받는&nbsp;데이터를&nbsp;볼&nbsp;수&nbsp;있을&nbsp;테니&nbsp;^^; <br /><br />그래서!!!!&nbsp;클라이언트는&nbsp;이&nbsp;대칭키(비밀키)를&nbsp;서버만&nbsp;볼&nbsp;수&nbsp;있게&nbsp;하기&nbsp;위해,&nbsp;서버의&nbsp;공개키로&nbsp;암호화를&nbsp;해서&nbsp;서버한테&nbsp;전달한다.&nbsp;(Client&nbsp;Key&nbsp;Exchange) <br /><br />6.&nbsp;Server&nbsp;/&nbsp;Client&nbsp;SSL&nbsp;Handshake&nbsp;Finished <br />서버는&nbsp;클라이언트가&nbsp;5번에서&nbsp;전달한&nbsp;암호화된&nbsp;대칭키(비밀키)를&nbsp;받았다.&nbsp;이&nbsp;키는&nbsp;서버의&nbsp;공개키로&nbsp;암호화되었으니,&nbsp;서버의&nbsp;비밀키로&nbsp;복호화해서&nbsp;얻을&nbsp;수&nbsp;있다. <br /><br />이제&nbsp;서버와&nbsp;클라이언트&nbsp;모두&nbsp;동일한&nbsp;대칭키(비밀키)를&nbsp;갖고&nbsp;있으니,&nbsp;통신할&nbsp;준비&nbsp;완료&nbsp;!!!</p>",
		"date": "Mar 25, 2024",
		"writer": "11기 김민우"
	},
	"feed-18": {
		"title": "도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지 - 최범균",
		"link": "https://apape1225.tistory.com/162",
		"description": "<h4>1. 개요</h4>\n<p>&nbsp;FLOWBIT 프로젝트를 끝내고 같은 팀원인 형님의 추천을 받아 DDD 스터디를 시작하였다. 처음 읽었을 때는 그저 클린 코드에 관한 서적 같은 느낌이 들었지만, 본격적으로 애그리거트의 개념이 나오는 순간 생각보다 정말 많은 시간이 필요하겠다는 생각이 들었다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;퇴근을 하고 내 몸둥아리가 맘에 들지 않아, 꾸준히 운동을 하기로 마음을 먹었기 때문에 퇴근을 하고 집에와서 잠을 자기 전까지 한 3시간 정도의 시간이 있었다. 씻는 시간까지 생각하면 한 2시간에서 2시간 30분 정도...? 주말이 있기에 다행이었지 지금 생각해보면 어떻게 완독을 했는지 싶다...</p>\n<p>&nbsp;</p>\n<h4>2. 본론</h4>\n<p>&nbsp;책 제목에 맞게 기본적인 부분 부터 심화된 부분까지 설명된 책이라고 생각된다. 구현에 대한 세세한 부분이 도메인 설계부터 나오기 때문에 초반에 쉽게 이해하면서 책을 읽을 수 있다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;계속 읽으면서 이런 개발론은 어떻게 내 시스템에 적용할 수 있을지에 대해 생각하였다. 그러다 보니 한 chapter당 소요시간이 너무 길어져 뒤로 갈수록 집중하기 어려웠다. 그래서 그런지 바운디드 컨텍스트 내용 이후에는 내용이 너무 어렵게 느껴졌다. 도메인에 대한 개념이 에그리거트로 커지고 그 개념이 다시 바운디드 컨텍스트로 커지는 부근에서는 이 개념의 경계선을 잡는 부근이 너무 어려웠다. 있는 그대로 말 하면, 무형의 방법론이라는 생각이 든다. 모든 개발 방법론이 그랬겠지만 <span style=\"color: #c1bef9;\"><b>\"귀에 걸면 귀걸이이고 코에 걸면 코걸이인가...?\"</b></span> 라는 말도 안되는 생각도 했다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;결국 생각에 생각을 하다, MSA 아키텍쳐에서의 서버 하나가 이 바운디드 컨텍스트가 아닌가? 라는 결론에 도달았다. 사실 MSA 아키텍쳐에서 서버를 나누는 기준도 하나의 기능이고, 바운디드 컨텍스트를 나누는 기준 또한 도메인 기능을 사용자에게 제공하는 모든 영역의 합이다. (정말이지 너무 어려운 한국어) 그래서 지금 진행되는 사이드프로젝트에서 새롭게 서버를 설계할 때 각 서버를 하나의 바운디드컨텍스트로 생각하고 root aggregate를 설계했다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/Pwy3x/btsF1uN4qL7/nZJpy0ihfw6SvMt90OxZA1/img.png\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;3시간동안 팀원과 카페에서 작성해보았다. 그뒤로도 수정사항이 나와 계속 바꾸고 있는 중이다. 위의 내용을 구현하는 내용도 꼭 블로그에 정리했으면 좋겠다.</p>\n<h4>3. 결론</h4>\n<p>&nbsp;총 11개의 chapter를 1월부터 3월까지 약 3개월간 공부하였다. 구멍이 숭숭 난 기분이지만 그래도 책 한 권을 끝낸 것에 의의를 두었다. 다음에는 클린코드 혹은 알고리즘을 조금 더 공부해보고자 한다.</p>",
		"date": "Mar 24, 2024",
		"writer": "11기 성창규"
	},
	"feed-33": {
		"title": "[c++] 1940번 주몽",
		"link": "https://velog.io/@handmk/c-1940%EB%B2%88-%EC%A3%BC%EB%AA%BD",
		"description": "<p><strong>시간제한 : 2초</strong></p>\n<h3 id=\"📕-문제\">📕 문제</h3>\n<p>주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.</p>\n<p>갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. 야철대장은 자신이 만들고 있는 재료를 가지고 갑옷을 몇 개나 만들 수 있는지 궁금해졌다. 이러한 궁금증을 풀어 주기 위하여 N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.</p>\n<h3 id=\"📙-입력\">📙 입력</h3>\n<p>첫째 줄에는 재료의 개수 N(1 ≤ N ≤ 15,000)이 주어진다. 그리고 두 번째 줄에는 갑옷을 만드는데 필요한 수 M(1 ≤ M ≤ 10,000,000) 주어진다. 그리고 마지막으로 셋째 줄에는 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다. 고유한 번호는 100,000보다 작거나 같은 자연수이다.</p>\n<pre><code>6\n9\n2 7 4 1 5 3</code></pre><h3 id=\"📗-출력\">📗 출력</h3>\n<p>첫째 줄에 갑옷을 만들 수 있는 개수를 출력한다.</p>\n<pre><code>2</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main (){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int N,M; // N개 숫자, M합\n    int cnt = 0;\n\n    cin &gt;&gt; N &gt;&gt; M; // N, M 입력\n\n    vector&lt;int&gt; V(N,0);\n\n    int startIndex = 0;\n    int endIndex = N-1;\n\n    for(int i=0; i&lt;N; i++){ // N개 숫자 입력 받아 V 채우기\n        cin &gt;&gt; V[i];\n    }\n\n    sort(V.begin(),V.end());\n\n    while(startIndex != endIndex){\n        if(V[startIndex] + V[endIndex] &lt; M){ // V[start] + V[end] 가 M보다 작을 때\n            startIndex += 1;\n        }\n        else if (V[startIndex] + V[endIndex] == M){\n            cnt += 1;\n            endIndex -= 1;\n        }\n        else{\n            endIndex -= 1;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    return 0;\n}</code></pre>",
		"date": "Mar 24, 2024",
		"writer": "11기 손민기"
	},
	"feed-48": {
		"title": "RabbitMQ를 이용해서 응답 시간을 반의 반의 반의 반으로 줄여보자",
		"link": "https://velog.io/@yunh03/RabbitMQ%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%9D%91%EB%8B%B5-%EC%8B%9C%EA%B0%84%EC%9D%84-%EB%B0%98%EC%9D%98-%EB%B0%98%EC%9D%98-%EB%B0%98%EC%9D%98-%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%A4%84%EC%97%AC%EB%B3%B4%EC%9E%90",
		"description": "<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/0c8e226e-c70f-4c1f-8e70-e99cdbfa5aae/image.png\" /></p>\n<h2 id=\"rabbitmq를-도입하게-된-배경\">RabbitMQ를 도입하게 된 배경</h2>\n<p>현재 개발 중인 사이드 프로젝트에서 회원가입을 진행할 때 이메일 인증 기능이 사용된다. 인증번호를 담은 메일을 발송하는 API에 요청을 보내면, 응답시간이 상당히 길게 소요된다. 대충 얼마나 소요되냐면..\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/7f8b9b66-4f97-47d4-87bc-e183173f662b/image.png\" />\n정확하게 4.68초, 약 5초 정도 소요된다. 이메일 요청을 보내게 되면, 아래와 같은 로직을 수행하게 된다.</p>\n<ol>\n<li>이메일 정규식에 일치하는가?</li>\n<li>이미 서비스에 등록된 회원이 있는가?</li>\n<li>이전 이메일 인증 요청을 발송한 후 1분이 경과되었는가? (Redis 사용)</li>\n<li>새 이메일 인증 번호 생성</li>\n<li>이메일 인증 번호를 담은 템플릿 생성</li>\n<li>메일 발송</li>\n</ol>\n<p>이 과정을 수행해야 사용자가 입력한 메일로 인증 메일이 발송된다. 근데 문득 생각이 들었다.</p>\n<blockquote>\n<p>이메일 인증 번호를 담은 메일이 발송되는 과정을 사용자가 기다려야 할 필요가 있을까?</p>\n</blockquote>\n<p>사용자 입장에서 이메일 인증 번호를 입력 란에 넣고 인증을 완료하는 단계까지 정리해 보았다.</p>\n<ol>\n<li>이메일 입력 란에 이메일 주소를 적음</li>\n<li>이메일 인증 번호 발송 버튼을 누름</li>\n<li>발송 요청이 완료될 때까지 기다림 (5초..)</li>\n<li>이메일을 확인하러 이동함</li>\n<li>이메일에서 인증번호를 확인함</li>\n<li>이메일 인증번호 입력</li>\n<li>이메일 인증번호 검증</li>\n</ol>\n<p>이 정도인데, 어차피 이메일 인증 요청 버튼을 누르고, 이메일을 확인하러 다른 웹 페이지로 이동하는 시간이 있다. 그냥 정리하면, 굳이 <code>이메일이 지금 발송되었어요!</code>를 알릴 필요가 없고, <code>인증 번호를 담은 이메일 발송이 요청되었어요!</code> 정도면 충분한 것이다.</p>\n<p>이메일 요청을 보내는 로직 중에 제일 시간이 많이 소요되는 것이, 마지막 단계인 6번(메일 발송) 과정이다. 그래서 아래와 같이 로직을 변경하고 싶었다.</p>\n<ol>\n<li>이메일 정규식에 일치하는가?</li>\n<li>이미 서비스에 등록된 회원이 있는가?</li>\n<li>이전 이메일 인증 요청을 발송한 후 1분이 경과되었는가? (Redis 사용)</li>\n<li>메일 발송 요청</li>\n</ol>\n<p>이렇게만 하면 메일 발송에 제일 시간을 많이 잡아먹는 과정을 싹 없앨 수 있다. <em><del>(없애기 보다는 사용자 몰래 처리하는 것이 더 정확할 수도?)</del></em> 그래서 이 로직을 구현할 방법을 강구해 보았는데, 이 과정에서 찾은 방법이 RabbitMQ를 사용하는 것이다.</p>\n<hr />\n<h2 id=\"rabbitmq란\">RabbitMQ란?</h2>\n<p>AMQP(Advanced Message Queuing Protocol)를 구현한 오픈 소스 메시지 브로커이다. Producers에서 Consumers로 메시지(요청)를 전달할 때 중간에서 브로커 역할을 수행한다. 이를 사용하는 케이스는 다음과 같다.</p>\n<ol>\n<li>요청을 많은 사용자에게 전달할 때</li>\n<li><strong>요청에 대한 처리 시간이 길 때</strong></li>\n<li>많은 작업이 요청되어 순차적으로 처리를 해야할 때</li>\n</ol>\n<h2 id=\"amqpadvanced-message-queing-protocol란\">AMQP(Advanced Message Queing Protocol)란?</h2>\n<p>메시지 지향 미들웨어(Message Oriented Middleware: MOM) 시스템 간 통신을 위한 개방형 네트워크 프로토콜이다.</p>\n<h3 id=\"amqp의-개념\">AMQP의 개념</h3>\n<p>AMQP는 Queue, Exchange, Binding 이 세 개념으로 구성된다.</p>\n<h4 id=\"queue\">Queue</h4>\n<ul>\n<li>메시지를 수신하고 처리를 대기하는 대기열</li>\n<li>큐는 메시지를 안전하게 저장하고, 필요에 따라 소비자에게 전달</li>\n</ul>\n<h4 id=\"exchange\">Exchange</h4>\n<ul>\n<li>Producer가 메시지를 큐로 보내기 위한 진입점</li>\n<li>바인딩 규칙에 따라 어떤 큐에게 메시지를 전달할지 결정</li>\n</ul>\n<h4 id=\"binding\">Binding</h4>\n<ul>\n<li>Exchange와 Queue 간 연결을 나타냄</li>\n<li>메시지가 어떤 큐로 전달되어야 하는지 결정</li>\n</ul>\n<h3 id=\"왜-사용하는가\">왜 사용하는가?</h3>\n<p>한 대규모 서비스가 있으면, 여러 서버를 구성하고 서로 상호 작용하는 방식으로 서비스를 구성하게 된다. 이 방식이 MSA(Micro Service Architecture) 방식이다. 이런 상황에서 서버들은 서로 정보를 주고 받아야 하는 상황이 발생된다. 일반적인 HTTP 통신을 이용해 요청을 보내면 응답을 받을 때까지 요청을 보낸 서버의 수행이 중단되게 된다. 이렇게 되면 여러 서버에 동시에 정보를 전달하기 어려워 지기 때문에 이런 상황에서 AMQP를 이용한다. 이를 이용하면 Message Brokder라는 미들웨어를 활용해 비동기식으로 메시지를 전달한다.</p>\n<h2 id=\"rabbitmq-필수-개념--아키텍쳐\">RabbitMQ 필수 개념 &amp; 아키텍쳐</h2>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/fc0681b1-3c45-4248-8bb5-d31ac84fa0ea/image.png\" /></p>\n<ol>\n<li><strong>Producer</strong>: 요청을 보내는 주체, 보내고자 하는 메시지를 Exchange에 Publish (Producer는 Queue에 직접 접근 X, 항상 Exchange를 통해 접근)</li>\n<li><strong>Exchange</strong>: Producer에게 전달받은 메시지들을 어떤 Queue에게 발송할지 결정 후 Binding</li>\n<li><strong>Binding</strong>: Exchange와 Queue의 관계.</li>\n<li><strong>Queue</strong>: Consumer가 메시지를 consume하기 전까지 보관하는 장소</li>\n<li><strong>Consumer</strong>: Producer로 부터 전달된 메시지를 Queue로부터 메시지를 받아 처리하는 주체</li>\n</ol>\n<h2 id=\"rabbitmq-도입하기\">RabbitMQ 도입하기</h2>\n<p>로컬에 설치하여 RabbitMQ를 사용할 수도 있지만, 간단하게 <a href=\"https://www.cloudamqp.com/\">CloudAMQP</a>라는 사이트에서 회원가입만 진행하여 사용할 수 있다! 나는 <a href=\"https://www.cloudamqp.com/\">CloudAMQP</a> 사이트를 이용했고, Spring Boot를 사용하여 개발하였다. 이 글에서 코드를 이용한 개발 과정은 담지 않았고, <a href=\"https://medium.com/@chungkhanhduy/create-work-s-queue-with-spring-and-rabbitmq-978cad149672\">여기</a>를 참고하여 개발을 진행하였다. 코드에 관련해서는 다음 글에서 다뤄보도록 하겠다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/ec94c6e6-afe5-45de-abc5-0ea82ed1f061/image.jpg\" /></p>\n<p>RabbitMQ의 아키텍쳐처럼 위 사진과 같이 로직을 구현하였다. 사진에 있는 순서에 따르면,</p>\n<ol>\n<li>인증 번호 요청: 사용자가 이메일을 입력하고, 인증 번호를 요청한다.\n1-2. 모든 조건(이메일 정규식 일치, 서비스 회원 등록되지 않은 사용자, 이전 이메일 발송 후 1분 경과) 만족 시 사용자에게 200 OK 즉시 응답.</li>\n<li>Producer(요청을 보내는 주체)가 이메일 발송 종류, 이메일 주소를 담은 메시지를 Exchange에 publish</li>\n<li>Exchange는 Producer로부터 전달 받은 메시지를 Queue로 bound</li>\n<li>Consumer는 Queue에 있는 메시지를 consume</li>\n<li>전달 받은 메시지(이메일 종류, 이메일 주소)에 따라 메일 발송 프로세스 진행</li>\n</ol>\n<p>위 사진대로 개발을 진행하고, 인증 번호 이메일 발송 API를 요청하면 아래와 같이 처리된다.</p>\n<pre><code>2024-03-22 01:48:51.216  INFO 61657 --- [nio-8080-exec-2] c.k.k.d.m.service.Impl.MailServiceImpl   : Email Request Successful: {&quot;mailType&quot;:&quot;REGISTER_VERIFY&quot;,&quot;email&quot;:&quot;*****@naver.com&quot;}\n2024-03-22 01:48:51.276  INFO 61657 --- [ntContainer#0-1] c.k.k.domain.mail.task.MailTaskReceiver  : Task received: {&quot;mailType&quot;:&quot;REGISTER_VERIFY&quot;,&quot;email&quot;:&quot;*****@naver.com&quot;}\n2024-03-22 01:48:57.053  INFO 61657 --- [ntContainer#0-1] c.k.k.d.m.service.Impl.MailServiceImpl   : Email Send Successful\n2024-03-22 01:48:57.054  INFO 61657 --- [ntContainer#0-1] c.k.k.domain.mail.task.MailTaskReceiver  : Task Process Complete</code></pre><p>정리하면 다음과 같다.</p>\n<pre><code>// 이메일 발송 요청 성공\nEmail Request Successful: {&quot;mailType&quot;:&quot;REGISTER_VERIFY&quot;,&quot;email&quot;:&quot;*****@naver.com&quot;}\n\n// Queue로부터 작업(메시지)을 전달 받음\nTask received: {&quot;mailType&quot;:&quot;REGISTER_VERIFY&quot;,&quot;email&quot;:&quot;*****@naver.com&quot;}\n\n// 이메일 전송 프로세스 완료\nEmail Send Successful\n\n// 작업 완료\nTask Process Complete</code></pre><h2 id=\"결과-및-정리\">결과 및 정리</h2>\n<p>RabbitMQ 적용이 끝나고, 회원가입 인증 번호 요청 단계는 다음과 같이 정리되었다.</p>\n<p>&lt;유저 입장&gt;</p>\n<ol>\n<li>이메일 정규식에 일치하는가?</li>\n<li>이미 서비스에 등록된 회원이 있는가?</li>\n<li>이전 이메일 인증 요청을 발송한 후 1분이 경과되었는가? (Redis 사용)</li>\n<li>메일 발송 <strong>요청</strong> -&gt; 200 OK</li>\n</ol>\n<p>&lt;그 후, 비동기 처리&gt;\n5. Queue로부터 요청(메시지)를 받아옴\n6. 인증 번호(난수)를 생성\n7. 이메일 종류에 따라 인증 번호를 담은 템플릿 생성\n8. 이메일 발송</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/a6138c25-1776-4902-a3fb-f46bb81416b6/image.png\" />\nRabbitMQ를 사용하여 회원가입 인증 번호 요청 과정을 비동기 방식으로 처리한 결과. 위 사진과 같이 응답 시간이 254.01ms로.. 기존(4. 68초, 4,680ms)에 비해 18분의 1 수준으로 응답 시간이 줄어들은 것을 확인할 수 있다. 이로 인해 전체 시스템의 응답성이 향상되고 사용자 경험을 개선할 수 있었다.</p>\n<h3 id=\"레퍼런스-정리\">레퍼런스 정리</h3>\n<ul>\n<li><a href=\"https://medium.com/@chungkhanhduy/create-work-s-queue-with-spring-and-rabbitmq-978cad149672\">https://medium.com/@chungkhanhduy/create-work-s-queue-with-spring-and-rabbitmq-978cad149672</a></li>\n<li><a href=\"https://velog.io/@sdb016/RabbitMQ-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90\">https://velog.io/@sdb016/RabbitMQ-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90</a></li>\n<li><a href=\"https://velog.io/@black_han26/AMQPAdvanced-Message-Queuing-Protocol\">https://velog.io/@black_han26/AMQPAdvanced-Message-Queuing-Protocol</a></li>\n<li><a href=\"https://yoonbing9.tistory.com/129\">https://yoonbing9.tistory.com/129</a></li>\n<li><a href=\"https://develop-writing.tistory.com/79\">https://develop-writing.tistory.com/79</a></li>\n<li><a href=\"https://stackoverflow.com/questions/72248024/switching-to-cloudamqp-gives-com-rabbitmq-client-shutdownsignalexception\">https://stackoverflow.com/questions/72248024/switching-to-cloudamqp-gives-com-rabbitmq-client-shutdownsignalexception</a></li>\n</ul>",
		"date": "Mar 21, 2024",
		"writer": "11기 전윤환"
	},
	"feed-49": {
		"title": "[Ubuntu] MariaDB 외부 접속 허용",
		"link": "https://velog.io/@yunh03/Ubuntu-MariaDB-%EC%99%B8%EB%B6%80-%EC%A0%91%EC%86%8D-%ED%97%88%EC%9A%A9",
		"description": "<pre><code class=\"language-java\">sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf</code></pre>\n<p><code>/etc/mysql/mariadb.conf.d/50-server.cnf</code> 파일을 <code>nano</code> 편집기로 열어준다. 방향키를 이용하여 아래 내용을 찾아준다.</p>\n<pre><code class=\"language-java\"># Instead of skip-networking the default is now to listen only on\n# localhost which is more compatible and is not less secure.\nbind-address            = 127.0.0.1</code></pre>\n<p>여기에서 <code>bind-address</code> 부분을 <code>0.0.0.0</code> 으로 변경해 주어 외부에서 접속하는 모든 아이피에 대해 허용해 준다. 수정하면 아래와 같다.</p>\n<pre><code class=\"language-java\"># Instead of skip-networking the default is now to listen only on\n# localhost which is more compatible and is not less secure.\nbind-address            = 0.0.0.0</code></pre>\n<p>위 작업을 완료한 후, 아래 명령어를 실행하여 MariaDB에 접속한다. (만약 root 계정이 아닐 경우 다른 계정을 사용하면 된다.)</p>\n<pre><code class=\"language-java\">mysql -u root -p</code></pre>\n<p>그 후 아래 명령을 실행하여, 모든 IP에 대한 접속을 허용해 준다.</p>\n<ul>\n<li>비밀번호에 root 계정 또는 본인의 데이터베이스 계정에 대한 비밀번호를 입력</li>\n<li>만약 특정 IP만 허용하고 싶다면 <code>%</code> 부분에 아이피를 입력</li>\n</ul>\n<pre><code class=\"language-java\">GRANT ALL PRIVILEGES ON *.* to root@'%' identified by '비밀번호';</code></pre>\n<h3 id=\"참고\">참고</h3>\n<ul>\n<li><a href=\"https://gsmj041729.tistory.com/47\">https://gsmj041729.tistory.com/47</a></li>\n<li><a href=\"https://maivve.tistory.com/86\">https://maivve.tistory.com/86</a></li>\n</ul>",
		"date": "Mar 19, 2024",
		"writer": "11기 전윤환"
	},
	"feed-19": {
		"title": "[산업기능요원] 산업기능요원 개발자 구직 성공 후기",
		"link": "https://apape1225.tistory.com/161",
		"description": "<h3>1. 산업기능요원이란 무엇인가...</h3>\n<p>&nbsp;대학생활이 끝나고 산업기능요원 신분으로 근무를 시작하게 되었다. 인터넷에 찾아보면 워낙 악명이 높다는 말이 많지만, 지금까지 나는 매우 매우 매우 만족하면서 근무를 하고 있다.</p>\n<p>&nbsp;</p>\n<p>산업기능요원이란 보충역 판정을 받은 사람들이 공익근무지가 아닌, 국가에서 지정한 산업체에서 근무할 수 있는 제도이다. 간단하게 말하면 지하철이나 동사무소에서 일하지 않고 회사에서 일할 수 있다고 생각하면 된다...</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;</p>\n<figure contenteditable=\"false\" id=\"og_1710003292469\"><a href=\"https://www.mma.go.kr/contents.do?mc=mma0000760\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">개요 - 전문연구,산업기능요원 - 복무제도 - 병역이행안내 - 병무청</p>\n<p class=\"og-desc\">병역이행안내INFORMATION --&gt; --&gt; 개요 개요 제도의의 병역자원 일부를 군 필요인원 충원에 지장이 없는 범위내에서 국가산업의 육성&middot;발전과 경쟁력 제고를 위하여 병무청장이 선정한 병역지정업체</p>\n<p class=\"og-host\">www.mma.go.kr</p>\n</div>\n</a></figure>\n<hr contenteditable=\"false\" />\n<p>&nbsp;중학교 때 부터 IT 업계에서 일하고 싶었기에 여러 정보와 세미나를 들으며 경력의 중요성을 너무 뼈저리게 느끼고 있었다. 차피 해야할 일 개발자로서 근무할 수 있다면 나에게는 더할 나위 없이 좋은 기회라고 생각했고, 공익판정을 받자 마자 준비하기 시작했다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;준비기간은 약 1년정도 되었는데... 솔직히 말해서 눈이 너무 높았던 것 같기도 하다. 그래도 서버 개발 업무를 맡을 수 있는 회사라면 위치와 여건을 생각하지 않고 지원하려고 노력하였다.</p>\n<h3>2. 준비 과정</h3>\n<h4>코딩테스트</h4>\n<p>&nbsp;제일 스트레스 받았던것은 바로 코테.. ㄷㄷ 지금은 백준 골드1을 찍은 상태인데 이게 의미가 있나 싶을정도로 실전에서 나는 진짜 못했다. 지금까지 코테를 요구하는 회사에서 올솔한 적이 완전 없는 느낌...? 그냥 머리가 나쁜 것 같다... ㅋㅋ</p>\n<p>&nbsp;</p>\n<p>&nbsp;<b><span style=\"color: #c1bef9;\">코테가 중요한 이유는 기본기가 보이기 때문</span></b>이라고 했던가... 그래서인지 생각보다 많은 스트레스를 받으며 준비했다. 구글에 치면 뭐 여러 사람들이 작성해주신 공부법이 있는데 참고하면 좋을 듯 한다. 혹시 몰라 내가 코테를 준비한 방법을 남겨본다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>자주 나오는 알고리즘 유형은 이유가 있다.\n<ul>\n<li>구현, 탐색, 문자열과 같은 문제가 자주 나오는 이유는 기본기를 많이 요구하는 유형임과 동시에 생각보다 실무에서 사용할 일이 많기 때문입니다.</li>\n<li>기본이 되는 유형들이기 때문에 이 유형을 깊게 공부하고 천천히 다익스트라, 투포인터와 같은 알고리즘을 공부하였습니다.</li>\n</ul>\n</li>\n<li>일단 꾸준하게 해보자.\n<ul>\n<li>초반에는 실버5 ~ 실버6의 문제도 풀기 힘들었습니다. 그리고 지금도 그렇습니다.. ㅋㅋㅋㅋ 그냥 엉덩이 붙이고 앉아서 일주일에 4~5문제 정도 푸는 것을 목표로 하였습니다.</li>\n</ul>\n</li>\n<li>실전처럼 푸는 연습을 해보았다.\n<ul>\n<li>문제를 처음 풀때는 일단 문제를 읽고 아이패드에 스윽 스윽 그려보고 문제를 풀었는데 이게 버릇이 되니 실전에서도 문제 푸는 속도가 느렸습니다.</li>\n<li>일주일에 한 번은 시간을 재고 문제를 푸는 방식으로 연습하였습니다.</li>\n</ul>\n</li>\n</ul>\n<hr contenteditable=\"false\" />\n<p>&nbsp;사실 코테는 정답이 없는 것 같다... 약간 운인 느낌도 있고... 그냥 하나를 공부할 떄 문제 하나를 전부 이해하고 풀어나가는 것이 중요하다는 생각이 든다.</p>\n<h4>포트폴리오</h4>\n<p>&nbsp;많은 산업기능요원들을 본 것은 아니지만, 적어도 내가본 산업기능요원들은 저학년(가끔은 고등학교 시절 또는 중학교시절) 부터 소프트웨어를 공부하고 또 좋아하는 사람들이었다. 한마디로 말하면 그냥 개발 좋아하는 사람들이었다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;위의 말을 하는 이유는 이분들의 포트폴리오는 <span style=\"color: #c1bef9;\"><b>자기가 하고싶어서 진행한 개발</b></span>들로 가득했었다. 원하는 것을 만드는 과정에서, 자연스럽게 기획에 참여하는 과정이 녹아있었고 프로젝트수는 적어도 깊이 있는 스펙들이 있었다. 내가 면접관이었어도 정말 이 프로젝트에 대해 궁금해서 질문할 것 같았다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;나도 많이 반성하면서 합격자들의 포트폴리오를 보고 특징들을 정리해보았다. 이것이 정답은 아닐지 몰라도 많은 분들에게 도움이 되었으면 좋겠다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>간결하다.\n<ul>\n<li>이것저것 살 붙이지 않고 스스로가 한것 위주로 적었다.</li>\n<li>어떤 문제를 만났고 어떤 방식으로 해결했는지가 정확하게 적혀있다.</li>\n</ul>\n</li>\n<li>과정이 있다.\n<ul>\n<li>서비스가 발전하는 과정을 블로그든 글이든 정리해놓았다.</li>\n</ul>\n</li>\n<li>정직하다.\n<ul>\n<li>자신이 한 것은 했다고 하고 모르는 것은 모른다고 한다.</li>\n<li>사실 이부분이 제일 중요하다고 생각된다. 요즘은 너무 많은 사람들이 자신의 프로젝트를 부풀려서 적는 것 같다.</li>\n</ul>\n</li>\n<li>모르는 것과 아는 것을 구분하여 적었다.\n<ul>\n<li>써본것과 아는 것은 다르다.</li>\n</ul>\n</li>\n</ul>\n<hr contenteditable=\"false\" />\n<h4>자소서</h4>\n<p>\"자소서는 지원자의 정성과 마음가짐을 뜻합니다.\"</p>\n<p>&nbsp;</p>\n<p>&nbsp;위의 말은 지금 내가 재직중인 회사의 팀장님이 말씀해주셨다. 가끔 빵빵한 포트폴리오를 가진 명문대생들이 지원을 해도 성의 없는 자소서를 보면 고민된다는 분들을 볼 수 있었다. 이걸로 알 수 있는 사실은 자소서를 잘 쓴다기 보다는 자소서를 정성스럽게 작성하는 것이 중요하다는 것이다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;나는 그래서 대부분의 회사에서 요구되는 공통문항을 따로 정리하고 한 달 정도의 간격으로 업데이트하였다. 글은 그 순간 모든 것을 써낸다기 보다 시간을 가지고 매일 조금씩 작성하는 것이 재능없는 나에게는 나름 좋은 방법이라는 생각이 든다. 지금은 각 문항당 500자에서 1000자의 분량이 되었다.</p>\n<h4>면접</h4>\n<p>&nbsp;한 사람을 전부 알아가는데는 많은 시간이 필요하지만 적어도 자소서에 있는 내용이 거짓인지 아닌지를 판별하기에는 4개의 질문이면 충분한 것 같다. 핵심적인 내용에 꼬리에 꼬리를 물어 대화하다 보면 지원자가 이 프로젝트에 대해 얼마나 깊게 고민하고 생각했는가에 대한 깊이를 알 수 있다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;가장 중요한 것은 포트폴리오를 정직하게 작성하는 것이고, 면접에서는 적어도 자기가 작성한 포트폴리오에 대한 내용에 대해 전부 숙지하는 것이 중요하다고 생각된다. 만약 그때 질문에 대한 정확한 답변을 하지 못하면 포트폴리오 자체의 신뢰성이 떨어지게 된다고 생각한다. 적어도 면접장에 들어가는 순간만큼은 자신이 구현했다고 한 기능, 혹은 사용한 기술에 대해 완벽하게 숙지하고 가려고 노력하였다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;<span style=\"color: #c1bef9;\"><b>바로 바로 대답 안 한다고 점수 안 깎인다. 면접은 지원자의 순발력을 위주로 평가하는 과정이 아니다.</b></span> 그렇다고 너무 느리게 대답하라는 것은 아니지만, 내가 전혀 생각하지 못한 질문을 받거나 너무 어려운 질문을 받으면 많은 지원자들이 빨리 대답해야된다는 생각과 압박감이 느껴지는 분위기에 횡설수설하게 되는 경우가 많다. \"정말 어려운 질문입니다... 생각할 시간을 조금 가져도 될까요?\" 라고 말해 양해를 구한 후 생각을 정리한 뒤 말해도 아무도 뭐라고 하지 않는다. 오히려 더 좋게 보는 분들도 계셨다.(오피셜) 물론 질문을 하자마자 수월하게 대답하는 사람들이 있을 수 있겠지만 모두가 그렇게 하기는 어렵다. 양해를 구하고 천천히 생각하자. 그리고 대답해도 늦지 않다.</p>\n<h3>3. 결어</h3>\n<p>&nbsp;사실 뭐 그렇게 성공한 인생도 아닌데 후기를 적어도 되나 싶었지만... 블로그를 기록용으로 시작했기에 한번 적어 보았다. 지금 보니 참 당연한 이야기를 적은 것 같기도 하다... 그래도 누군가에게는 도움이 되었으면 좋겠다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;좋은 회사에 산업기능요원으로만 입사하면 인생이 행복해지겠지? 라는 생각을 가지고 살았지만, 결국 입사 후에도 끊임없이 공부해야하고 노력해야한다는 사실을 알게 되는 요즘이다. 그래도 가끔은 즐거운 순간들을 많이 만나 괜찮은 삶을 살고 있다고 생각한다. 회사애 계신 분들도 모두 착하셔서 돈받고 공부하고 있다고 느끼게 된다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;흔히 노예계약이라고 불리며 초과 근무와 낮은 연봉을 받는다는 이미지로 많은 분들이 생각하고 계시지만, 지금까지는 만족스럽게 다니고 있다. 초과근무는 해본적이 없다... ㅋㅋ 연봉도 만족하면서 다닌다. 맥북 PRO를 얼마전에 질러서 그렇지 돈도 조금씩 저축하고 있다. (비트코인 화이팅) 물론 회사마다 다르다는 것은 알고 있다. 그래서 많은 사람들이 노력하면서 좋은 회사를 원하는 것이 아닌가 싶다.</p>\n<p>&nbsp;</p>\n<p>&nbsp;첫 월급으로 구매한 맥북으로 작성한 첫 글이 산업기능요원 구직 후기라니 정말 기분이 묘하다... ㅎㅎ <span style=\"color: #333333; text-align: start;\">다음에는 정직원 개발자의 모습으로 후기를 작성했으면 좋겠다. 마지막으로 사내 휴게실 안마의자에서 자기직전 상태인 나의 두 다리를 올리며 후기를 마친다. 끝~!</span></p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"359\" src=\"https://blog.kakaocdn.net/dn/wEUdP/btsFQXaUn74/O6J6bCEjzvhxHJSMW0OZSK/img.jpg\" width=\"269\" /></span></figure>\n</p>\n<p><span style=\"color: #333333; text-align: start;\">&nbsp;</span></p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;</p>",
		"date": "Mar 16, 2024",
		"writer": "11기 성창규"
	},
	"feed-68": {
		"title": "[사고방식] &quot;설명해 보세요!&quot;",
		"link": "https://ub775.tistory.com/entry/%EC%84%A4%EB%AA%85%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img height=\"356\" src=\"https://blog.kakaocdn.net/dn/cmXsFm/btsF4YV7O6u/kTmKGU4lYk36LdA7WKKAx1/img.jpg\" width=\"458\" /></span><figcaption>\"설명해 보세요!\"</figcaption>\n</figure>\n</p>\n<p style=\"text-align: justify;\">과거부터 많은 자기소개와 경험을 소개하는 말들을 들어오면서 개인마다 쌓아온 지식의 양이 방대하다는 것을 느꼈다.<br />하지만 프로젝트 진입과 같이 이론을 응용하는 등의 상황을 만나면 대부분 허술한 모습을 보였다.<br />몇 번 조별과제나 프로젝트를 진행해 본 사람이라면 \"아, 그 XX 기억난다\" 하며 머리에 떠오르는 사람들이 있을 것이다.<br />실제로 나도 일부 \"그 XX\"에 해당하는 사람이기도 했다.<br />분명 공부를 했는데, 수업을 들었고 관련 실습도 분명히 했는데 왜 그런 상황이 발생하는 것일까?<br /><br /></p>\n<h3 style=\"text-align: justify;\">1. 설명할 줄 알아야 한다.</h3>\n<p style=\"text-align: justify;\">나는 설명할 줄 모르면 아는 것이 아니라고 판단한다.<br />다른 견해도 분명 있겠지만 이것은 나의 안정적인 성장을 위한 판단 기준이다.<br />당연히 설명은 단순한 개념 암기여선 안된다. 나만의 설명, 증명 과정을 이끌어낼 줄 아는 단계를 말한다.<br />&nbsp;</p>\n<h3 style=\"text-align: justify;\">2. 설명의 두 가지 유형</h3>\n<p style=\"text-align: justify;\">설명하는 행동은 다시 둘로 나눠지는데 하나는 사람에게 설명하는 것이고, 다른 하나는 컴퓨터에게 설명하는 것이다.<br />사람에게 설명은 흔히 표현하길 \"초등학생도 이해하게 설명해 봐라\"라고 할 정도로 쉽게 설명할 수 있어야 한다.<br />설명 과정은 일반적인 지식수준(상식)에서 전문적인 단계까지 내가 어떻게 오가는지 생각의 경로를 보여준다.<br />이는 마치, 내가 부산에 대해 알고 있고 부산을 방문한 경험이 있다면 서울에서 부산을 오가는 법도 아는 것과 같은 이치다.<br />&nbsp;<br />컴퓨터에게 설명은 구현이라고 할 수 있겠다.<br />내가 그 이론이 적용된 예제 코드를 작성할 수 있는가? 내가 개발하고 있는 코드에 그 이론을 녹여낼 수 있는가?<br />이것은 응용의 영역이고, 머리로 이해하는 것과는 다르게 충분한 노력이 요구된다.<br /><br /></p>\n<h3 style=\"text-align: justify;\">3. 마무리</h3>\n<p style=\"text-align: justify;\">요즘 양질의 강의 영상들을 유튜브를 통해 접할 수 있고, 좋은 서적들도 많이 나와 있다.<br />하지만 내가 그 영상을 보고, 그 책을 읽는다고 내 지식과 기술이 되지 않는다. 그것들은 보조적인 역할일 뿐이다.<br />&nbsp;<br />내 안에서 지식을 이끌어 낼 수 있을 때, 설명할 수 있을 때야말로 내 지식이고, 기술이 된다는 것을 기억하며 자기 자신에게 물어보도록 하자.<br />&nbsp;<br />\"설명해 보세요!\"</p>",
		"date": "Mar 16, 2024",
		"writer": "11기 강명균"
	},
	"feed-50": {
		"title": "[오류 해결] SQL ERROR 1406: Data too long for column at row 1",
		"link": "https://velog.io/@yunh03/%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0-SQL-ERROR-1406-Data-too-long-for-column-at-row-1",
		"description": "<h2 id=\"어쩌다-오류가-발생했는가\">어쩌다 오류가 발생했는가</h2>\n<p>GPT-4 응답 결과와 토큰 사용량에 대해 데이터베이스에 저장하려고 얼마 전에 코드를 수정했다. 수정 전에는 GPT-4에 대한 응답 결과를 따로 저장하지 않고 바로 응답 값을 출력하도록 해두었으나, 수정 후에 갑자기 500(Internal Server Error)가 발생한다는 소식에 확인을 시작했다.</p>\n<p>백엔드 코드를 확인해 보니 아래 오류가 발생한 것을 확인할 수 있었다.</p>\n<pre><code class=\"language-jsx\">2024-03-10 10:49:04.949 ERROR 1 --- [nio-8080-exec-5] o.h.engine.jdbc.spi.SqlExceptionHelper   : (conn=605) Data too long for column 'answer' at row 1\n2024-03-10 10:49:04.968 ERROR 1 --- [nio-8080-exec-5] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.InvalidDataAccessResourceUsageException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement] with root cause\n\njava.sql.SQLException: Data too long for column 'answer' at row 1\n    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readErrorPacket(AbstractQueryProtocol.java:1694) ~[mariadb-java-client-2.7.4.jar!/:na]\n    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readPacket(AbstractQueryProtocol.java:1556) ~[mariadb-java-client-2.7.4.jar!/:na]\n    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.getResult(AbstractQueryProtocol.java:1519) ~[mariadb-java-client-2.7.4.jar!/:na]</code></pre>\n<p>대충 해석하면 <code>answer</code> 컬럼에 데이터가 너무 길어서 저장을 못 한다는 것이다.</p>\n<hr />\n<h2 id=\"왜-오류가-발생했을까\">왜 오류가 발생했을까?</h2>\n<p>GPT-4 응답 결과를 저장하는 엔티티 중 <code>answer</code> 은 아래처럼 되어있다.</p>\n<pre><code class=\"language-java\">@Entity\npublic class AssistantLog {\n    ...\n\n    @Column(nullable = false)\n  private String answer;\n\n    ...\n}</code></pre>\n<p>MariaDB에 AssistantLog 테이블을 확인해 본 결과, <code>answer</code> 컬럼은 <code>VARCHAR (255)</code>로 설정되어 있었다.</p>\n<p>즉, String으로 선언된 컬럼은 JPA에서 <code>VARCHAR (255)</code> 로 변환시켜 주는 것이였고, <code>answer</code> 컬럼에는 255바이트, 즉 한국어 255자 정도까지만 입력될 수 있던 것이였다.</p>\n<p>그래서 내용이 긴 GPT-4의 응답은 255 바이트 설정에 걸려버렸기 때문에 저장될 수 없었던 것이다.</p>\n<hr />\n<h2 id=\"그럼-오류를-해결해-보자\">그럼 오류를 해결해 보자!</h2>\n<pre><code>TINYTEXT = 255 바이트\nTEXT = 64 킬로바이트\nMEDIUMTEXT = 16 메가바이트\nLONGTEXT = 4 기가바이트</code></pre><p><code>TINYTEXT</code>는 기존과 저장할 수 있는 용량이 동일하기 때문에 변경할 이유가 없고, <code>TEXT</code> 정도로만 변경하면 좋을 것 같다. <code>MEDIUMTEXT</code>나 <code>LONGTEXT</code>는 너무 용량이 크기 때문에 부담될 수 있다고 판단했기 때문이다.</p>\n<pre><code class=\"language-java\">@Entity\npublic class AssistantLog {\n    ...\n\n    @Column(nullable = false, columnDefinition = &quot;TEXT&quot;)\n  private String answer;\n\n    ...\n}</code></pre>\n<p>위와 같이 해주면, <code>TEXT</code>로 타입 설정이 완료된다.</p>\n<p>다른 타입 설정을 원한다면, <code>columnDefinition = &quot;TINYTEXT&quot;</code> 와, <code>columnDefinition = &quot;MEDIUMTEXT&quot;</code>를 사용하면 된다.</p>\n<p>만약, <code>LONGTEXT</code> 타입을 사용하고 싶다면 아래와 같이 수정해 주면 된다.</p>\n<pre><code class=\"language-java\">@Entity\npublic class AssistantLog {\n    ...\n\n    @Lob\n  private String answer;\n\n    ...\n}</code></pre>",
		"date": "Mar 11, 2024",
		"writer": "11기 전윤환"
	},
	"feed-20": {
		"title": "[DDD] chapter 11",
		"link": "https://apape1225.tistory.com/160",
		"description": "<h2>Chapter 11</h2>\n<h3>11.1 단일 모델의 단점</h3>\n<p>주문 내역 조회 기능을 구현하려면 여러 애그리거트에서데이터를 가져와야 한다. Order에서 주문 정보를 가져와야 하고, Product에서 상품 이름을 가져와야 하고, Member에서 회원 이름과 ID를 가져와야 한다.</p>\n<p>&nbsp;</p>\n<p>이러한 구현 복잡도 문제를 해결하려면 상태 변경을 위한 모델과 조회를 위한 모델을 분리하여 구현할 수 있다.</p>\n<h3>11.2 CQRS</h3>\n<p>Command Query Responsibility Segregation의 약자로 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴이다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"362\" src=\"https://blog.kakaocdn.net/dn/bgAH1T/btsFGVcI02h/Wa4vl9RqNFSck5sK8c5aKK/img.png\" width=\"657\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>CQRS는 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가난다.</p>\n<p>&nbsp;</p>\n<p>CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다. 명령 모델은 객체 지향에 기반한 JPA를 사용해서 구현하고, 조회 모델은 DB 테이블에서 SQL로 데이터를 조회할 때 좋은 MyBatis를 사용해서 구현하면 된다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/ckJWY0/btsFFnuNRTM/RlHItBtkehFHdJb0BV9B3k/img.jpg\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>이 예시에서는 데이터에 관한 로직에서 Event Handler를 사용한다. 또한 명령 모델과 조회 로직이 다른 Data structure를 사용하는 것을 볼 수 있다. 조회는 역시 MongoDB를 사용해야 하는 것인가 싶다...</p>\n<p>&nbsp;</p>\n<p>(그렇다면 결국 조회 서비스까지 다시 빼놔야 하는 것인가...? 인프라 팀이 죽어 나가겠구만...)</p>\n<h4>11.2.1 웹과 CQRS</h4>\n<p>일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 훨씬 많다.</p>\n<p>&nbsp;</p>\n<p>대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용하게 된다. 단지 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다. 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분한다.</p>\n<h4>11.2.2 CQRS 장단점</h4>\n<p>CQRS 패턴을 적용할 때 얻을 수 있는 장점은 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다는 점이다. 성능에 대한 부담이 덜한 상태로 작성할 수 있어 복잡도 또한 사라진다.</p>\n<p>&nbsp;</p>\n<p>단점은 구현해야 할 코드가 너무 많아 진다는 것이다. 도메인이 단순하거나 트래픽이 그렇게 많은 서비스가 아니라면 조회 전용 모델을 따로 만들 때 얻을 이점이 있는지 따져봐야 한다.</p>",
		"date": "Mar 09, 2024",
		"writer": "11기 성창규"
	},
	"feed-21": {
		"title": "[DDD] chapter 10",
		"link": "https://apape1225.tistory.com/159",
		"description": "<h2>Chapter 10</h2>\n<h3>10.1 시스템 간 강결합 문제</h3>\n<p>외부 서비스를 사용할 때 발생할 수 있는 문제점</p>\n<ul>\n<li>트랜잭션 처리가 애매해진다.</li>\n<li>성능이 비교적 감소한다. (외부 서비스 성능에 직접적인 영향을 받게 된다.)</li>\n</ul>\n<p>위의 문제를 해결하는 방법은 이벤트를 사용하는 것이다.</p>\n<h3>10.2 이벤트&nbsp; 개요</h3>\n<p>이벤트란?</p>\n<ul>\n<li>과거에 벌어진 어떤 것.\n<ul>\n<li>사용자가 암호를 변경했을 때 &gt; <span style=\"color: #c1bef9;\"><b>\"암호를 변경했음 이벤트\"</b></span>가 벌어졌다고 할 수 있다.</li>\n<li>사용자가 주문을 취소했을 때 &gt; <span style=\"color: #c1bef9;\"><b>\"주문을 취소했음 이벤트\"</b></span>가 벌어졌다고 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<p>도메인의 상태 변경과 관련된 요구사항들을 이벤트를 통해 구현할 수있다.</p>\n<ul>\n<li><span style=\"color: #c1bef9;\"><b>\"주문을 취소할 때 이메일을 보낸다.\"</b></span>라는 요구사항에서 <span style=\"color: #c1bef9;\"><b>\"주문을 취소할 때\"</b></span>는 주문이 취소 상태로 바뀌는 것을 의미하므로 <span style=\"color: #c1bef9;\"><b>\"주문 취소됨 이벤트\"</b></span>를 이용해서 구현할 수 있다.</li>\n</ul>\n<h4>10.2.1 이벤트 관련 구성요소</h4>\n<p>이벤트 구성요소</p>\n<ul>\n<li>이벤트 생성 주체</li>\n<li>이벤트 디스패처</li>\n<li>이벤트 핸들러</li>\n</ul>\n<p>도메인 모델에서의 이벤트 생성 주체</p>\n<ul>\n<li>엔티티</li>\n<li>벨류</li>\n<li>도메인 서비스</li>\n<li>모든 도메인 객체</li>\n</ul>\n<p>위의 이벤트 생성 주체는 도메인 로직을 실행해서 상태가 바뀌면, 관련 이벤트를 발생시킨다.</p>\n<p>&nbsp;</p>\n<p>이벤트 핸들러</p>\n<ul>\n<li>이벤트 생성 주체가 발생한 이벤트에 반응한다.</li>\n<li>생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.</li>\n</ul>\n<p>이벤트 디스패처</p>\n<ul>\n<li>이벤트 생성 주체와 이벤트 핸들러를 연결해주는 역할을 한다.</li>\n<li>디스패처는 이벤트 생성 주체가 생성한 이벤트를 받아 관련 핸들러에 뿌려주는 역할을 한다.</li>\n</ul>\n<p>(Kafka의 Consumer와 Producer가 생각난다...)</p>\n<h4>10.2.2 이벤트의 구성</h4>\n<p>이벤트가 포함하는 정보</p>\n<ul>\n<li>이벤트 종류: 클래스 이름으로 이벤트 종류를 표현</li>\n<li>이벤트 발생 시간&nbsp;</li>\n<li>추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보&nbsp;</li>\n</ul>\n<p>다음은 배송지를 변경할 때 발생하는 이벤트 클래스이다. (MSA 공부할 때 많이 보던 것이다...)</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709817929464\"><code>public class ShippingInfoChangedEvent {\n    private String orderNumber;\n    private  long timestamp;\n    private ShippingInfo  newShippingInfo;\n}</code></pre>\n<p>&nbsp;</p>\n<p>이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트 이름에는 과거 시제를 사용한다.</p>\n<p>&nbsp;</p>\n<p>다음은 Events.raise()를 사용하여 구현한 이벤트 주체의 이벤트 전달 기능 구현 방법이다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709818750796\"><code>public class Order {\n\n    public void changeShippingInfo(ShippingInfo newShippingInfo){\n        verifyNotYetShipped();\n        setShippingInfo(newShippingInfo);\n        Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo))\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>이벤트 핸들러는 이 이벤트(객체)를 받아 작업을 수행한다. 혹시 이벤트에 이러한 정보가 없다면 직접 정보를 읽어와야할 수 있다. 단, <span style=\"color: #c1bef9;\"><b>이벤트에 필요한 정보만을 읽어와야한다.</b></span></p>\n<p>&nbsp;</p>\n<h4>10.2.3 이벤트 용도</h4>\n<p>이벤트의 용도는 크게 두 가지가 있다.</p>\n<ul>\n<li>트리거\n<ul>\n<li>도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.</li>\n<li>&nbsp;주문에서는 주문 취소 이벤트를 트리거로 사용할 수 있다.\n<ul>\n<li>주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>시스템 간의 동기화\n<ul>\n<li>배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야한다. (DB도 다른걸 쓰는건가 지금...?)\n<ul>\n<li>주문 도메인은 배송지 변경 이벤트를 발생 시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>10.2.4 이벤트 장점</h4>\n<p>이벤트의 장점</p>\n<ul>\n<li>도메인 로직이 섞이는 것을 방지할 수 있다.<br />\n<ul>\n<li>Order로직에서 환불로직을 사용할 필요 없이 이벤트만 발생시킬 수 있다. (이건 진짜 미쳤다...)</li>\n</ul>\n</li>\n<li>기능 확장이 매우 용이하다. (천재다...)\n<ul>\n<li>구매 취소 시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하여 추가만 해주면 된다.</li>\n</ul>\n</li>\n</ul>\n<p>너무 감동 받아서 외부자료를 찾아보았는데... 무려 마이크로소프트에서 제공하는 예시가 있다...</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"320\" src=\"https://blog.kakaocdn.net/dn/cBzJgo/btsFEiTt29G/Qgqz6xiTlq67YJHmmU7kM1/img.png\" width=\"573\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<h3>10.3 이벤트, 핸들러, 디스패처 구현</h3>\n<h4>10.3.1 이벤트 클래스</h4>\n<p>이벤트 자체를 위한 상위 타입은 없다. 따라서 원하는 클래스를 작성하면 된다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709905420151\"><code>public class OrderCanceledEvent {\n    private String orderNumber;\n    \n    public OrderCanceledEvent(String number){\n        this.orderNumber = number;\n    }\n    \n    public String setOrderNumber(){return orderNumber;}\n}</code></pre>\n<p>&nbsp;</p>\n<p>모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709905528326\"><code>public class Event {\n    private long timestamp;\n    \n    public Event(){\n        this.timestamp = System.currentTimeMillis();\n    }\n    \n    public long getTimestamp(){\n        return timestamp;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<h4>10.3.2 Events 클래스와 ApplicationEventPublisher</h4>\n<p>이벤트 발생과 출판을 위해 Spring은 ApplicationEventPublisher를 사용한다.</p>\n<p>&nbsp;</p>\n<p>Events 클래스의 구현</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709905891201\"><code>public class Events {\n    private static ApplicationEventPublisher publisher;\n\n    static void setPublisher(ApplicationEventPublisher publisher){\n        Events.publisher = publisher;\n    }\n    \n    public static void raise(Object event){\n        if(publisher != null){\n            publisher.publishEvent(event);\n        }\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>Events.publisher = publisher; &gt; 이 문법이 잘 이해가 안 된다...</p>\n<h4>10.3.3 이벤트 발생과 이벤트 핸들러</h4>\n<p>&nbsp;이벤트를 발생시킬 코드는&nbsp; &nbsp;Events.raise() 메서들르 사용한다.</p>\n<p>&nbsp;</p>\n<p>다음은 Spring에서 제공하는 @EventListener 어노테이션을 사용하여 구현한 예이다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709906258901\"><code>@Service\npublic class OrderCanceledEventHandler {\n    private RefundService refundService;\n    \n    public OrderCanceledEventHandler(RefundService refundService){\n        this.refundService = refundService;\n    }\n    \n    @EventListener(OrderCanceledEvent.class)\n    public void handle(OrderCanceledEvent event){\n        refundService.refund(event.getOrderNumber());\n    }\n    \n}</code></pre>\n<p>&nbsp;</p>\n<p>만약 OrderCanceledEvent.class값을 가지는 이벤트가 발생하면 설정된 @EventListener() 어노테이션 안에&nbsp; Order CanceledEvent.class를 가지는 모든 메소드가 실행된다. (이정도면 카프카가 아닌가...?)</p>\n<p>&nbsp;</p>\n<p>좀 더 찾아보니 Kafka와 Spring의 EventListener는 관련이 없는 것 같다.</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;</p>\n<figure contenteditable=\"false\" id=\"og_1709906449652\"><a href=\"https://www.wool-dev.com/backend-engineering/spring/springboot-kafka-simple\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">SpringBoot에서 Kafka Event Message 보내고 받기</p>\n<p class=\"og-desc\">빅 데이터의 세계에서 안정적인 스트리밍 플랫폼은 필수이다. 현재 가장 주목받고있는 kafka 스트리핑 플랫폼과 SpringBoot를 활용해서 간단한 Event 메시지를 주고받는 작업을 해보자</p>\n<p class=\"og-host\">www.wool-dev.com</p>\n</div>\n</a></figure>\n<hr contenteditable=\"false\" />\n<h3>10.4 동기 이벤트 처리 문제</h3>\n<p>외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계하는 것이다.</p>\n<h3>10.5 비동기 이벤트 처리</h3>\n<p>\"A하면 B를 한다.\" 라는 방식의 요구사항은 대부분 \"A하면 <span style=\"color: #c1bef9;\"><b>일정기간 안에</b></span> B를 하라.\" 라는 경우가 많다. A를 이벤트의 관점으로 보면서 비동기 이벤트 처리를 구현할 수 있다.</p>\n<p>&nbsp;</p>\n<p>비동기 이벤트 처리의 구현방식</p>\n<ul>\n<li>로컬 핸들러 비동기로 실행하기</li>\n<li>메시지 큐를 사용하기</li>\n<li>이벤트 저장소와 이벤트 포워더 사용하기</li>\n<li>이벤트 저장소와 이벤트 제공 API 사용하기</li>\n</ul>\n<h4>10.5.1 로컬 핸들러 비동기 실행</h4>\n<p>이벤트 핸들러를 비동기로 실행하는 방법은 이벤트 핸들러를 별도 스레드로 실행하는 것이다.</p>\n<p>&nbsp;</p>\n<p>@EnableAsync 어노테이션을 사용하여 비동기를 활성화하고 이벤트 핸들러 메서드에 @Async 어노테이션을 붙이면 된다.</p>\n<h4>10.5.2 메시징 시스템을 이용한 비동기 구현</h4>\n<p>Kafka나 RabbitMQ를 사용하는 메시징 시스템을 사용하여 구현할 수 있다.</p>\n<p>&nbsp;</p>\n<p>메시징 시스템은 Dispatcher와 Handler사이에서 작동한다.&nbsp;</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"348\" src=\"https://blog.kakaocdn.net/dn/F0XKG/btsFGmVZhGO/skNLFoLwSfyNWATp74yTl0/img.png\" width=\"696\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<h4>10.5.3 이벤트 저장소를 이용한 비동기 처리</h4>\n<p>이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 방식으로 구현할 수 있다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"363\" src=\"https://blog.kakaocdn.net/dn/PeOtw/btsFFZNuAQ0/5vPy7dev0kQEs6Px0LBw81/img.png\" width=\"622\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>하나의 DB를 도메인과 포워더가 같이 사용하게 된다.</p>\n<p>&nbsp;</p>\n<p>구현 방식을 보니, 외부 API를 사용하는 경우 장점을 가질 것 같지만, 지금 나의 상황에서는 Kafka가 더 끌린다.</p>\n<h3>10.6 이벤트 적용 시 추가 고려 사항</h3>\n<p>이벤트 적용 시 고려애햐 할 사항</p>\n<ul>\n<li>이벤트 소스를 EventEntry에 추가할지에 대한 여부</li>\n<li>포워더의 전송 실패 허용 범위</li>\n<li>이벤트 손실</li>\n<li>이벤트 순서</li>\n<li>이벤트 재처리</li>\n</ul>\n<h4>10.6.1 이벤트 처리와 DB 트랜잭션 고려</h4>\n<p>주문 취소 기능의 이벤트와 흐름</p>\n<ul>\n<li>주문 취소 기능은 주문 취소 이벤트를 발생시킨다.</li>\n<li>주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.</li>\n<li>환불 서비스는 외부 API를 호출해서 결제를 취소한다.</li>\n</ul>\n<p>이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 한다. 그러나 경우의 수가 많아지므로, 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.</p>\n<p>&nbsp;</p>\n<p>스프링은 @TransactionalEventListener 어노테이션을 지원한다. 해당 어노테이션은 스프링 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1709973269867\"><code>@Service\npublic class OrderCanceledEventHandler {\n    private RefundService refundService;\n\n    public OrderCanceledEventHandler(RefundService refundService){\n        this.refundService = refundService;\n    }\n    \n    @TransactionalEventListener(\n            classes = OrderCanceledEvent.class;\n            phase = TransactionPhase.AFTER_COMMIT;\n    )\n    public void handle(OrderCanceledEvent event){\n        refundService.refund(event.getOrderNumber());\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>해당 설정을 사용하면 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행한다. 만약 중간에 에러가 발생되어 트랜잭션이 롤백 되면 핸들러 메소드를 실행하지 않는다.</p>",
		"date": "Mar 09, 2024",
		"writer": "11기 성창규"
	},
	"feed-51": {
		"title": "Spring, 테스트 코드는 왜 작성할까?",
		"link": "https://velog.io/@yunh03/Spring-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%9E%91%EC%84%B1%ED%95%A0%EA%B9%8C",
		"description": "<p>원래 필자는 PHP와 그 프레임워크인 Laravel을 이용하여 개발을 해왔다. 하지만, PHP의 인기도가 점점 낮아져가는 것도 사실이고, 다른 언어를 접해 보고자 PHP에서 Java와 Spring Boot로 주 개발 언어를 변경하였다. Spring Boot에 익숙해지고, 여러 커뮤니티를 보며 '테스트 코드'라는 게시글을 많이 접하게 되었다. 그래서 나도 원래는 테스트 코드를 작성하지 않았지만 <del>사실 귀찮아서..</del> 테스트 코드를 작성하는 방법과 그 이유에 대해서는 꼭 알고 넘어가고 싶기에 이 글을 작성했다.</p>\n<hr />\n<h3 id=\"테스트-코드를-왜-작성할까\">테스트 코드를 왜 작성할까?</h3>\n<h4 id=\"1-서버를-시작하여-직접-테스트하는-것-보다-시간을-단축시킬-수-있다\">1. 서버를 시작하여 직접 테스트하는 것 보다 시간을 단축시킬 수 있다.</h4>\n<p>소규모의 프로젝트는 모르겠지만, 중.대규모의 프로젝트를 진행하게 될 경우 개발되는 API의 수가 상당하다. API를 테스트하려고, Spring 프로젝트 서버를 시작하여 API를 직접 호출하거나 Swagger 같은 툴을 이용해 테스트하면, 값을 계속 입력해 주어야 하는 번거로움이 발생할 뿐 아니라 시간도 많이 소요된다. 하지만, 테스트 코드를 작성해 두면, 테스트 파일만 실행하여 모든 테스트를 손쉽게 마칠 수 있기 때문에 시간이 단축된다.</p>\n<h4 id=\"2-개발-과정에서-문제를-미리-발견할-수-있다\">2. 개발 과정에서 문제를 미리 발견할 수 있다.</h4>\n<p>API를 실제로 운영하며 발생할 수 있는 최대한의 Case에 맞춰 테스트 코드를 작성했다면 짜여진 코드의 잠재적인 문제를 개발 과정에서 발견할 수 있다. 오류가 발생할 수 있는 케이스에 관한 테스트 코드를 작성하여 예외 처리가 잘 되는지, 의도에 따라 API가 잘 작동되는지에 관해서도 미리 확인할 수 있다.</p>\n<h4 id=\"3-리펙토링-시-문제를-최소화할-수-있다\">3. 리펙토링 시 문제를 최소화할 수 있다.</h4>\n<p>API가 개발되고, 운영하며 보수, 수정, 추가되는 일이 허다한데, 이 과정에서 코드를 변경하다 보면 연관되어 있는 다른 코드에도 영향을 줄 수 있는 가능성이 높다. 이 과정에서 미리 작성해둔 테스트 코드를 통해 다른 코드에서 오류가 발생하는지에 대해 확인할 수 있고, 예기치 않은 오류에 미리 대비할 수 있다.</p>\n<hr />\n<p>이렇게 테스트 코드를 작성하는 이유에 대해 간단하게 알아보았다. 테스트 코드의 필요성에 대해 인지하고 현재 개발하고 있는 프로젝트에 테스트 코드를 작성하고 있는데 다음 글에서는 JUnit과 Mockito를 기반으로 테스트 코드를 어떠한 방식으로 작성하는 지에 간단하게 다뤄보려고 한다.</p>",
		"date": "Mar 07, 2024",
		"writer": "11기 전윤환"
	},
	"feed-22": {
		"title": "[DDD] chapter 9",
		"link": "https://apape1225.tistory.com/158",
		"description": "<h2>Chapter 9</h2>\n<h3>9.1 도메인 모델과 경계</h3>\n<p>한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.</p>\n<p>&nbsp;</p>\n<p>카탈로그에서 상품, 재고 관리에서 상품, 주문에서 상품, 배송에서 상품은 이름만 같지 실제로 의미하는 것이 다르다. 카탈로그에서의 상품은 상품 이미지와같은 상품 정보가 위주라면, 재고 관리에서는 실존하는 개별 객체를 추적하기 위한 목적으로 개별 객체를 추적하기 위한 목적으로 상품을 사용한다. 즉, 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러 개 존재할 수 있다.</p>\n<p>&nbsp;</p>\n<p>논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.카탈로그&nbsp; 도메인에서의 상품이 검색 모데인에서는 문서로 물리기도 한다. (이러면 너무 복잡해질 것 같은데... ㅠㅠ)</p>\n<p>&nbsp;</p>\n<p>이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에, 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.</p>\n<p>&nbsp;</p>\n<p>하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야한다. 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.</p>\n<p>&nbsp;</p>\n<p>모델은 특정한 컨텍스트 하에서 완전한 의미를 갖는다. 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다. 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트 라고 부른다.</p>\n<p>&nbsp;</p>\n<h3>9.2 바운디드 컨텍스트</h3>\n<p>바운디드 컨텍스트</p>\n<ul>\n<li>모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.</li>\n<li>바운디드 컨텍스트는 용어를 기준으로 구분한다.</li>\n<li>예시\n<ul>\n<li>카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.</li>\n</ul>\n</li>\n<li>실제로 사용자에게 기능을 제공하는 물리적 시스템이다.\n<ul>\n<li>도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.</li>\n</ul>\n</li>\n</ul>\n<h3>9.3 바운디드 컨텍스트 구현</h3>\n<p>바운디드 컨텍스트는 도메인 모델 만이 아닌, 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영억을 모두 포함한다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"374\" src=\"https://blog.kakaocdn.net/dn/dLdSnh/btsFkJxpB75/A4mFGVrVSf3wh6ujUNfhJK/img.png\" width=\"604\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>(개인적인 생각으로 context는 그냥 어어엄청 높은 수준의 도메인의 개념이 아닌가 싶다...)</p>\n<p>&nbsp;</p>\n<p>모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다. 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다. (하나의 기능을 컨텍스트로 묶는건가... 이러면 협업이 매우 편해질 것 같다. MSA의 단일 서버 느낌인 것 같다.)</p>\n<h3>9.3 바운디드 컨텍스트 간 통합</h3>\n<p>온라인 쇼핑 사이트에서 매출 증대를 위해 카탈로그 하위 도메인에 개인화 추천 기능을 도입하기로 했다고 하면, 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.</p>\n<p>&nbsp;</p>\n<p>만약 사용자가 카탈로그 바운디드 컨텍스트에 추천 제품 목록을 요청하면 카탈로그 바운디드 컨텍스트는 추천 바운디드 컨텍스트로부터 추천 정보를 읽어와 추천 제품 목록을 제공한다.</p>\n<p>&nbsp;</p>\n<p>카탈로그 시스템은 추천 시스템으로 부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기 보다는 카탈로그 도메인 모델을 사용해 추천 상품을 표현해야 한다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708958515595\"><code>public interface ProductRecommendationService {\n    List&lt;Product&gt; getRecommendationsOf(ProductId id);\n}</code></pre>\n<p>&nbsp;</p>\n<p>카탈로그의 모델을 기반으로 하는 도메인 서비스를 이용해서 상품 추천 기능을 표현해야 한다.</p>\n<p>&nbsp;</p>\n<p>여기서 외부 추천 시스템에 관련된 내용이 나오는데,&nbsp; 추천 상품을 구현하는 시스템을 외부에서 구현하고 해당 시스템의 결과를&nbsp; Rest API로 호출하는 방법이 나온다... (그렇게 되면 Rest API가 아닌 단일 서버는 어떻게 해야하나...?)</p>\n<h3>9.5 바운디드 컨텍스트 간 관계</h3>\n<p>&nbsp;바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 가지게 된다.</p>\n<p>&nbsp;</p>\n<h4>상류 하류의 관계</h4>\n<p>한 쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 관계이다.</p>\n<ul>\n<li>하류 컴포넌트는 상류 컴포넌트가 제공하는 데이터에 의존한다.</li>\n<li>상류 컴포넌트는 일종의 서비스 공급자 같은 역할을 한다.</li>\n<li>상류 컴포넌트가 변경되면 하류 컴포너트 까지 변경해야한다는 단점이 있다.</li>\n</ul>\n<p>공유 커널 구조</p>\n<ul>\n<li>중복을 줄여준다.</li>\n<li>하나의 컴포넌트에서 모델을 변경할 수 없으며, 변경하게 되면 복잡한 절차를 따르게 된다.</li>\n</ul>\n<p>독립 방식 구조</p>\n<ul>\n<li>수동으로 통합을 이루는 구조이다.</li>\n<li>규모가 커질수록 사용하기 불편하다는 단점이 있다.\n<ul>\n<li>따라서 별도의 시스템을 제작해 주어야한다.</li>\n</ul>\n</li>\n</ul>\n<h3>9.6 컨텍스트 맵</h3>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"404\" src=\"https://blog.kakaocdn.net/dn/bIlh8v/btsFmitaxBl/yr6x9n7fy1Iq6DkYj8syd1/img.jpg\" width=\"757\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>개별 바운디드 컨텍스트에 메몰되지 않게 전체적인 시각을 가지기에 용이하다.</p>",
		"date": "Feb 27, 2024",
		"writer": "11기 성창규"
	},
	"feed-52": {
		"title": "Spring Boot에서 ChatGPT 활용하기 #2: API로 GPT 응답 값 가져오기",
		"link": "https://velog.io/@yunh03/Spring-Boot%EC%97%90%EC%84%9C-ChatGPT-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-2-API%EB%A1%9C-GPT-%EC%9D%91%EB%8B%B5-%EA%B0%92-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0",
		"description": "<p><a href=\"https://velog.io/@yunh03/Spring-Boot%EC%97%90%EC%84%9C-ChatGPT-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-1-API-%EC%97%B0%EA%B2%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8\">Spring Boot에서 ChatGPT 활용하기 #1: API 연결 테스트</a>에 이어 이 글에서는 Spring Boot에서 만든 API 호출을 통해 GPT의 응답 값을 가져오는 코드를 작성해 볼 것이다.</p>\n<h3 id=\"구조\">구조</h3>\n<pre><code>gpt\nㄴ controller\n    ㄴ GptController.java\nㄴ service\n    ㄴ Impl\n        ㄴ GptServiceImpl.java\n    GptService.java\n\napplication.properties</code></pre><h3 id=\"applicationproperties\">application.properties</h3>\n<p><a href=\"https://platform.openai.com/api-keys\">https://platform.openai.com/api-keys</a> 여기에서 발급받은 Secret Key는 저장소에 올라가거나 공유되면 안 되기 때문에, <code>application.properties</code>에 따로 명시해 주었다.</p>\n<pre><code>openai.api.key=발급받은_키</code></pre><h3 id=\"service\">Service</h3>\n<p><code>GptService</code>의 코드는 다음과 같다.</p>\n<pre><code>ResponseEntity&lt;?&gt; getAssistantMsg(String userMsg) throws JsonProcessingException;</code></pre><p><code>GptServiceImpl</code>의 코드는 다음과 같다.</p>\n<pre><code>@Service\npublic class GptServiceImpl implements GptService {\n    @Value(&quot;${openai.api.key}&quot;)\n    private String apiKey;\n\n    public JsonNode callChatGpt(String userMsg) throws JsonProcessingException {\n        final String url = &quot;https://api.openai.com/v1/chat/completions&quot;;\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        headers.setBearerAuth(apiKey);\n\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        Map&lt;String, Object&gt; bodyMap = new HashMap&lt;&gt;();\n        bodyMap.put(&quot;model&quot;, &quot;gpt-4&quot;);\n\n        List&lt;Map&lt;String, String&gt;&gt; messages = new ArrayList&lt;&gt;();\n        Map&lt;String, String&gt; userMessage = new HashMap&lt;&gt;();\n        userMessage.put(&quot;role&quot;, &quot;user&quot;);\n        userMessage.put(&quot;content&quot;, userMsg);\n        messages.add(userMessage);\n\n        Map&lt;String, String&gt; assistantMessage = new HashMap&lt;&gt;();\n        assistantMessage.put(&quot;role&quot;, &quot;system&quot;);\n        assistantMessage.put(&quot;content&quot;, &quot;너는 친절한 AI야&quot;);\n        messages.add(assistantMessage);\n\n        bodyMap.put(&quot;messages&quot;, messages);\n\n        String body = objectMapper.writeValueAsString(bodyMap);\n\n        HttpEntity&lt;String&gt; request = new HttpEntity&lt;&gt;(body, headers);\n\n        RestTemplate restTemplate = new RestTemplate();\n        ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);\n\n        return objectMapper.readTree(response.getBody());\n    }\n\n    @Override\n    public ResponseEntity&lt;?&gt; getAssistantMsg(String userMsg) throws JsonProcessingException {\n        JsonNode jsonNode = callChatGpt(userMsg);\n        String content = jsonNode.path(&quot;choices&quot;).get(0).path(&quot;message&quot;).path(&quot;content&quot;).asText();\n\n        return ResponseEntity.status(HttpStatus.OK).body(content);\n    }\n}</code></pre><p>실제 API 호출하는 부분의 함수화를 통해 코드 분리를 진행시켰고, <code>callChatGpt(String userMsg)</code>에서 <code>userMsg</code> 부분에 사용자의 질문(요청) 사항을 입력할 수 있다.</p>\n<p>그리고, <code>getAssistantMsg</code> 부분에는 <code>callChatGpt()</code>가 반환한 JsonNode 객체에서 ChatGPT의 응답 값만 Body 값으로 출력하게 해주었다.</p>\n<h3 id=\"controller\">Controller</h3>\n<p><code>GptController</code>의 코드는 다음과 같다.</p>\n<pre><code>@RestController\n@RequestMapping(&quot;/api/v1/gpt&quot;)\npublic class GptController {\n    private final GptService gptService;\n\n    @Autowired\n    public GptController(GptService gptService) {\n        this.gptService = gptService;\n    }\n\n    @PostMapping(&quot;/&quot;)\n    public ResponseEntity&lt;?&gt; getAssistantMsg(@RequestParam String msg) throws JsonProcessingException {\n        return gptService.getAssistantMsg(msg);\n    }\n}</code></pre><p><code>GptController</code>에 <code>@Autowired</code> 어노테이션을 통해 <code>GptService</code> 의존성 주입을 해주고, <code>/api/v1/gpt</code> 주소로 POST 요청과 함께 파라미터 값으로 <code>msg</code>를 전달해 주면, <code>GptService</code>의 <code>getAssistanceMsg()</code> 에 <code>msg</code>를 전달하고, 값을 반환받는다.</p>\n<h3 id=\"실행-결과\">실행 결과</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/8b9c9296-6cb3-46b0-819e-76211efc3391/image.png\" />\nSwagger를 통한 API 실행 결과 <code>안녕</code> 이라고 요청을 보냈을 때 응답 반환 값에 <code>안녕하세요! 어떻게 도와드릴까요?</code> 라는 응답 결과가 돌아오는 것을 볼 수 있다.</p>\n<h3 id=\"마무리\">마무리</h3>\n<p>이 글까지는 Spring Boot를 통한 OpenAI ChatGPT API를 호출하는 방법에 대해 정리해 보았다. 다음 글에서는 간단한 React 작업을 통한 대화를 주고 받는 프론트엔드 단 개발을 마지막으로 이 시리즈를 마치려고 한다.</p>",
		"date": "Feb 26, 2024",
		"writer": "11기 전윤환"
	},
	"feed-23": {
		"title": "[DDD] chapter 8",
		"link": "https://apape1225.tistory.com/157",
		"description": "<h2>chapter 8</h2>\n<h3>8.1 애그리거트와 트랜잭션</h3>\n<p>한 주문 애그리거트에 대해 운영자는 배송 상태로 변경할 때 사용자는 배송지 주소를 변경하면 다음과 같은 일이 일어난다.</p>\n<p>&nbsp;</p>\n<table border=\"1\" style=\"border-collapse: collapse; width: 100%;\">\n<tbody>\n<tr>\n<td style=\"width: 50%;\">운영자 스레드</td>\n<td style=\"width: 50%;\">고객 스레드</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">주문 애그리거트 구함</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">주문 애그리거트 구함</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">배송 상태로 변경</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">배송지 변경</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">트랜잭션 커밋</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">트랜잭션 커밋</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 <b><span style=\"color: #c1bef9;\">운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.</span></b></p>\n<p>&nbsp;</p>\n<p>운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만 물리적으로 서로 다른 애그리거트 객체를 사용한다. 때문에 운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경 하더라도 고객 스레드가 사용하는 주문 애그리거트 객체에는 영향을 주지 않는다. 고객 스레드 입장에서 주문 에그리거트 객체는 아직 배송 상태 전이므로 배송지 정보를 변경할 수 있다.</p>\n<p>&nbsp;</p>\n<p>이 상황에서 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DB에 반영한다. 이 시점에 배송 상태로 바뀌고 배송지 정보도 바뀌게 된다. 이 순서의 문제점은 운영자는 기존 배송지 정보를 이용해서 배송 상태로 변경했는데 그 사이 고객은 배송지 정보를 변경했다는 점이다. 즉, 애그리거트의 일관성이 깨지는 것이다.</p>\n<p>&nbsp;</p>\n<p>일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두가지 중 하나를 해야한다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.</li>\n<li>운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.</li>\n</ul>\n<hr contenteditable=\"false\" />\n<p>이 두가지는 애그리거트 자체의 트랜잭션과 관련이 있다. DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다. 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.</p>\n<h3>8.2 선점 잠금</h3>\n<p>선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.</p>\n<p>&nbsp;</p>\n<table border=\"1\" style=\"border-collapse: collapse; width: 100%;\">\n<tbody>\n<tr>\n<td style=\"width: 50%;\">스레드 1</td>\n<td style=\"width: 50%;\">스레드 2</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">애그리거트 구함 (접근 잠금)</td>\n<td style=\"width: 50%;\">애그리거트 구함 시도 (잠금으로 대기)</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">애그리거트 수정</td>\n<td style=\"width: 50%;\">잠금된 동안 블로킹</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">트랜잭션 커밋 (잠금 해제)</td>\n<td style=\"width: 50%;\">애그리거트 구함(접근 잠금)</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">애그리거트 수정</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">트랜잭션 커밋 (잠금 해제)</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>위의 표에서 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구하고 있다. 이때 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 블로킹 된다.</p>\n<p>&nbsp;</p>\n<p>한 스레드가 애그리거틀 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.</p>\n<p>&nbsp;</p>\n<p>선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.</p>\n<p>&nbsp;</p>\n<p>JPA Entity Manager는 LockModeType을 인자로 받는 find() 메서드를 제공한다. LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 해당 엔티티와 매핑된 테이블을 이요해서 선점 잠금 방식을 적용할 수 있다.</p>\n<p>&nbsp;</p>\n<h4>8.2.1 선점 잠금과 교착 상태</h4>\n<p>선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 해야한다.</p>\n<hr contenteditable=\"false\" />\n<p>1. 스레드1: A 애그리거트에 대한 선점 잠금 구함</p>\n<p>2. 스레드2: B 애그리거트에 대한 선점 잠금 구함</p>\n<p>3. 스레드1: B애그리거트에 대한 선점 잠금 시도</p>\n<p>4. 스레드2: A 애그리거트에 대한 선점 잠금 시도</p>\n<hr contenteditable=\"false\" />\n<p>위의 순서에 따르면 스레드 1은 영원히 B애그리거트에 대한 선점 잠금을 구할 수 없다.</p>\n<p>&nbsp;</p>\n<p>선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가한다. 더 많은 스레드가 교착 상태에 빠질수록 시스템은 아무것도 할 수 없는 상태가 된다.</p>\n<p>&nbsp;</p>\n<p>이런 문제가 발생하지 않도록 잠금을 구할 때 최대 대기 시간을 지정해야 한다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708523535219\"><code>Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();\nhints.put(\"javax.persistence.lock.timeout\", 2000);\nOrder order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISIC_WRITE, hints);</code></pre>\n<p>&nbsp;</p>\n<p>JPA의 javax.persistence.lock.timeout 힌트는 잠금을 구하는 대기 시간을 밀리초 단위로 지정한다. 지정한 시간 이내에 잠금을 구하지 못하면 익셉션을 발생시킨다.</p>\n<p>&nbsp;</p>\n<h3>8.3 비선점 잠금</h3>\n<p>위의 예시에서&nbsp; 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 그&nbsp; 순간에 고객이 배송지를 변경하면 오류가 발생할 수 있다. 즉, 배송 상태 변경 전에 배송지를 한 번 더 확인하지 않으면 운영자는 다른 배송지로 물건을 발송하게 된다.</p>\n<p>&nbsp;</p>\n<p>이 문제는 비선점 잠금으로 해결할 수 있다.비선점 잠금은 동시에 점근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.</p>\n<p>&nbsp;</p>\n<table border=\"1\" style=\"border-collapse: collapse; width: 100%;\">\n<tbody>\n<tr>\n<td style=\"width: 50%;\">스레드1</td>\n<td style=\"width: 50%;\">스레드2</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">애그리거트 구함 (버전 1)</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">애그리거트 구함(버전 1)</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">애그리거트 수정</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">애그리거트 수정</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">트랜잭션 커밋 -&gt; 버전 1에서 2로 변경</td>\n<td style=\"width: 50%;\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"width: 50%;\">&nbsp;</td>\n<td style=\"width: 50%;\">트랜잭션 커밋 실패 버전 1을 커밋할 때 버전을 비교</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>(천재인가...?)</p>\n<p>&nbsp;</p>\n<p>연산이 많이 느는 것 같지도 않아 좋은 방법 같다.</p>\n<p>&nbsp;</p>\n<p>JPA는 비선점 잠금 기능을 지원한다. 다음과 같이 버전으로 사용할 필드에 @Version 애너테이션을 붙이고 매핑되는&nbsp; 테이블에 버전을 저장할 수있다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708524007448\"><code>@Entity\n@Table\npublic class Order {\n    @EmbeddedId\n    private OrderNo number;\n    \n    @Version\n    private long version;\n}</code></pre>\n<p>&nbsp;</p>\n<p>JPA Entity가 변경되어 Update 쿼리를 실행할 때 @Version에 명시한 필드를 사용해 잠금 쿼리를 실행한다.</p>\n<h3>8.4 오프라인 선점 잠금</h3>\n<p>오프라인 서점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다. 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고 마지막 트랜잭션에서 잠금을 해제한다.</p>\n<h4>8.4.1 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스</h4>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/eskzJG/btsE8NgLoB6/Ww49IKZFBLIaEZByakx8K1/img.png\" /></span></figure>\n</p>\n<hr contenteditable=\"false\" />\n<p>&nbsp;</p>",
		"date": "Feb 21, 2024",
		"writer": "11기 성창규"
	},
	"feed-53": {
		"title": "Spring Boot에서 ChatGPT 활용하기 #1: API 연결 테스트",
		"link": "https://velog.io/@yunh03/Spring-Boot%EC%97%90%EC%84%9C-ChatGPT-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-1-API-%EC%97%B0%EA%B2%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8",
		"description": "<h3 id=\"들어가며\">들어가며</h3>\n<p>OpenAI의 ChatGPT는 현재 전 세계에서 가장 주목받고 있는 기술이다. ChatGPT에 대한 이해가 깊어지면서, 이를 활용한 API 개발에 대한 생각이 점점 커졌다. 또한, 최근에 릴리즈된 Spring Boot 3.0을 아직 제대로 활용해보지 않았던 점을 고려하여, 이번 프로젝트는 Spring Boot 3.0 기반으로 진행하기로 결정했다.</p>\n<h3 id=\"chatgpt-api-호출\">ChatGPT API 호출</h3>\n<p><a href=\"https://platform.openai.com/docs/guides/text-generation\">ChatGPT 공식 문서</a>에 따라 Spring Boot에서 본격적으로 활용하기 전 Postman을 통해 API 호출을 먼저 해보았다. 이 글을 쓰는 오늘(2024년 2월 19일) 기준, GPT 모델에 따른 엔드포인트는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>Model Family</th>\n<th>Endpoint</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>gpt-4, gpt-4-turbo-preview,gpt-3.5-turbo</td>\n<td><a href=\"https://api.openai.com/v1/chat/completions\">https://api.openai.com/v1/chat/completions</a></td>\n</tr>\n<tr>\n<td>gpt-3.5-turbo-instruct, babbage-002,davinci-002</td>\n<td><a href=\"https://api.openai.com/v1/completions\">https://api.openai.com/v1/completions</a></td>\n</tr>\n</tbody></table>\n<p>필자는 공식 문서에 따라 <code>gpt-3.5-turbo</code> 모델을 사용하여 호출하였기 때문에 <code>https://api.openai.com/v1/chat/completions</code> 엔드포인트를 사용하였다.</p>\n<p><strong>Header</strong></p>\n<p>API 호출 시 헤더에 포함되는 항목들이다. <code>$OPENAI_API_KEY</code> 부분에는 <a href=\"https://platform.openai.com/api-keys\">ChatGPT API Keys</a>에서 발급받은 Secret Key를 입력해 주면 된다.</p>\n<pre><code class=\"language-json\">Content-Type: application/json\nAuthorization: Bearer $OPENAI_API_KEY</code></pre>\n<p><strong>Body</strong></p>\n<p>API 호출 시 바디에 포함되는 항목 들이다. <code>model</code>에는 원하는 모델을 선택하여 입력해 주면 된다.</p>\n<p>그리고 <code>messages</code> 부분에 들어갈 항목에 대해서 자세히 알아봐야 할 필요가 있다. 현재 아래 예제를 보면, 한 요청에 2가지 메시지를 전달하고 있고, 각각 역할이 다른 것을 볼 수 있다. 하나는 <code>system</code> 하나는 <code>user</code>이다.</p>\n<p>이 부분이 얼마 전 업데이트 된 부분이다. 단순하게 메시지만 전달하는 것이 아닌, 부가적인 요소를 삽입하여 더 구체적이고 이상적인 답변을 받아볼 수 있도록 하는 것이다.</p>\n<p>role에 들어갈 수 있는 값과 간단한 설명은 다음과 같다.</p>\n<ul>\n<li>system<ul>\n<li>어떻게 행동(답변)할 지 지정하는 역할</li>\n<li>주로 상황을 설정한다. → <code>Act as a ____</code></li>\n</ul>\n</li>\n<li>user<ul>\n<li>일반적으로 질문하는 역할</li>\n</ul>\n</li>\n<li>assistant<ul>\n<li>보조자 역할. 이전 대화를 저장하고, 대화의 연속성을 지정하기 위해 사용</li>\n</ul>\n</li>\n</ul>\n<p>더 자세한 내용은 <a href=\"https://platform.openai.com/docs/guides/text-generation/chat-completions-api\">ChatGPT Chat Completions API</a> 문서에서 확인할 수 있다.</p>\n<pre><code class=\"language-json\">{\n    &quot;model&quot;: &quot;gpt-3.5-turbo-0125&quot;,\n    &quot;response_format&quot;: { &quot;type&quot;: &quot;json_object&quot; },\n    &quot;messages&quot;: [\n      {\n        &quot;role&quot;: &quot;system&quot;,\n        &quot;content&quot;: &quot;You are a helpful assistant designed to output JSON.&quot;\n      },\n      {\n        &quot;role&quot;: &quot;user&quot;,\n        &quot;content&quot;: &quot;Who won the world series in 2020?&quot;\n      }\n    ]\n  }</code></pre>\n<p>위 Endpoint, Header, Body 값을 가지고 API를 호출하면 다음과 같은 결과 값을 얻을 수 있다.</p>\n<pre><code class=\"language-json\">{\n    &quot;id&quot;: &quot;chatcmpl-8tqujCfSEroJwUPlY6ABf0T8c1NgD&quot;,\n    &quot;object&quot;: &quot;chat.completion&quot;,\n    &quot;created&quot;: 1708322133,\n    &quot;model&quot;: &quot;gpt-3.5-turbo-0125&quot;,\n    &quot;choices&quot;: [\n        {\n            &quot;index&quot;: 0,\n            &quot;message&quot;: {\n                &quot;role&quot;: &quot;assistant&quot;,\n                &quot;content&quot;: &quot;{\\n    \\&quot;error\\&quot;: \\&quot;There was no World Series held in 2020 due to the COVID-19 pandemic.\\&quot;\\n}&quot;\n            },\n            &quot;logprobs&quot;: null,\n            &quot;finish_reason&quot;: &quot;stop&quot;\n        }\n    ],\n    &quot;usage&quot;: {\n        &quot;prompt_tokens&quot;: 31,\n        &quot;completion_tokens&quot;: 25,\n        &quot;total_tokens&quot;: 56\n    },\n    &quot;system_fingerprint&quot;: &quot;fp_6dd124df95&quot;\n}</code></pre>\n<p>그러면 Response 값에서 <code>choices</code> → <code>content</code> 부분에 아래와 같이 GPT 3.5의 답변이 표시됨을 확인할 수 있고, API를 정상적으로 호출할 수 있음을 확인할 수 있다.</p>\n<p>만약에 정상적으로 답변이 표시되지 않는다면 맨 아래 챕터 <code>오류 해결</code> 부분을 참고하기 바란다.</p>\n<pre><code class=\"language-json\">There was no World Series held in 2020 due to the COVID-19 pandemic.</code></pre>\n<hr />\n<h3 id=\"gpt-가격-정책\">GPT 가격 정책</h3>\n<p>하지만, 이런 식으로 API를 호출하여 GPT 모델을 사용하는 것은 비용이 부과된다. 위 Response 값에서 <code>usage</code> 부분을 다시 한 번 보자.</p>\n<pre><code class=\"language-json\">        &quot;usage&quot;: {\n        &quot;prompt_tokens&quot;: 31,\n        &quot;completion_tokens&quot;: 25,\n        &quot;total_tokens&quot;: 56\n    },</code></pre>\n<p><code>prompt_tokens</code> 즉, 질문(Input)에는 31 토큰이 사용되었고, <code>completion_tokens</code> 즉, 답변에는 25 토큰이 사용되었다. 이제, ChatGPT의 가격 정책에 대해 확인해 보자.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/0c6d2963-81f6-4226-bd90-bd28b6b20545/image.png\" /></p>\n<p>필자가 이 글에서 사용한 GPT 모델은 GPT-3.5 Turbo(gpt-3.5-turbo-0125) 모델이다. 이 모델의 가격 정책을 확인해 보면, Input(질문)은 1,000 토큰 당 0.0005$ , 한화 1원이 부과되고, Output(답변)은 1,000 토큰 당 0.0015$, 한화 2원 정도가 부과된다. 아래 표를 참고하여 글자 수 당 토큰이 책정되는지 확인하면 좋을 것 같다.</p>\n<table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Token</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>영어(약 0.75 단어, 약 4자)</td>\n<td>1 Token</td>\n</tr>\n<tr>\n<td>한국어(1자)</td>\n<td>1 Token</td>\n</tr>\n</tbody></table>\n<hr />\n<h3 id=\"오류-해결\">오류 해결</h3>\n<p>ChatGPT에서 아무런 설정도 하지 않은 채 Secret Key를 발급받고 API를 호출하니 다음과 같은 오류가 발생하였다.</p>\n<pre><code class=\"language-json\">{\n    &quot;error&quot;: {\n        &quot;message&quot;: &quot;You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.&quot;,\n        &quot;type&quot;: &quot;insufficient_quota&quot;,\n        &quot;param&quot;: null,\n        &quot;code&quot;: &quot;insufficient_quota&quot;\n    }\n}</code></pre>\n<p><code>You exceeded your current quota, please check your plan and billing details.</code> 결제 관련 정보들을 확인하라는 말인 것 같고, ChatGPT API가 유료임을 감안하여 생각해본 결과, 사전 충전된 크레딧이 없어 결제가 되지 않았던 것 같았다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/e46e0018-8578-45d0-a9bb-d301de7c08f1/image.png\" /></p>\n<p>ChatGPT Billing Settings 페이지에서 카드를 등록하고, 최소 충전 크레딧인 5$를 충전했다. 그리고 나서 API 호출을 다시 시도해 보니 정상적인 결과 값을 얻을 수 있었다.</p>\n<p>다른 오류는 <a href=\"https://platform.openai.com/docs/guides/error-codes/api-errors\">ChatGPT API Errors</a> 페이지에서 확인해 볼 수 있다.</p>",
		"date": "Feb 19, 2024",
		"writer": "11기 전윤환"
	},
	"feed-24": {
		"title": "[DDD] chapter 7",
		"link": "https://apape1225.tistory.com/156",
		"description": "<h2>Chapter 7</h2>\n<h3>7.1 여러 애그리거트가 필요한 기능</h3>\n<p>&nbsp;도메인 영역의 코드를 작성하다 보면, 한 애그리거트로 기능을 구현할 수 없을 때가 있다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>상품 애그리거트: 구매하는 상품의 가격이 필요하다. 또한 상품에 따라 배송비가 추가되기도 한다.</li>\n<li>주문 애그리거트: 상품별로 구매 개수가 필요하다.</li>\n<li>할인 쿠폰 애그리거트: 쿠폰별로 지정한 할인 금액이나 비율에 따라 주문 총 금액을 할인한다.\n<ul>\n<li>할인 쿠폰을 조건에 따라 중복 사용할 수 있다거나 지정한 카테고리의 상품에만 적용할 수 있다는 제약조건이 있을 수있다.</li>\n</ul>\n</li>\n<li>회원 애그리거트: 회원 등급에 따라 추가 할인이 가능하다.</li>\n</ul>\n<hr contenteditable=\"false\" />\n<p>이 상황에서 실제 결제 금액을 계산해야하는 주체는 주문 애그리거트일까? 그러나 총 주문 금액에서 할인 금액을 계산해야하는데 이 할인 금액을 구하는 것은 어떤 도메인에서 해야할까?</p>\n<p>&nbsp;</p>\n<p>일단 생각해 볼 수 있는 방법은 주문 애그리거트가 필요한 데이터를 모두 가지도록 한 뒤 할인 계산 책임을 주문 애그리거트에게 할당하는 것이다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708088862277\"><code>public class Order {\n    private Orderer orderer;\n    private Money totalAmounts;\n    private List&lt;OrderLine&gt; orderLines;\n    private List&lt;Cupon&gt; usedCupons;\n\n    private Money calculatePayAmount(){\n        Money discount = usedCupons.map(copon -&gt; calculateDiscount(cupon))\n                .reduce(Money(0), (v1, v2) -&gt; v1.add(v2));\n        Money membershipDiscount = calculateDiscount(orderer.getMember().getGrade());\n\n        return totalAmounts.minus(discount).minus(memberShipDiscount);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>그러나 이렇게 구현을 해도 추가적인 기능이 생긴다면, 도메인간의 경계가 모호해질 수 있다.</p>\n<p>&nbsp;</p>\n<p>예를 들어 특별 감사 세일로 전 품목에 대해 한 달간 2% 추가 할인을 하기로 했다고 해보자. 이 할인 정책은 주문 애그리거트가 각고 있는 구성요소와는 관련이 없음에도 불구하고 결제 금액 책임이 주문 애그리거트에 있다는 이유로 주문 애기르거트의 코드를 수정해야한다.</p>\n<p>&nbsp;</p>\n<p>이렇게 한 애그리거트에 넣기 애매한 도메인 기능을 억지로 특정 애그리거트에 구현하면 안된다. 억지로 구현하면 애그리거트는 자신의 책임 범위를 넘어서는 기능을 구현하기 때문에 코드가 길어지고 외부에 대한 의존이 높아지게 되며 코드를 복잡하게 만들 수 있다.</p>\n<p>&nbsp;</p>\n<p>따라서 이런 문제를 해결하려면 도메인 기능을 별도 서비스로 구현하는 것이다.</p>\n<p>&nbsp;</p>\n<h3>7.2 도메인 서비스</h3>\n<p>도메인 서비스는 도메인 영역에 위치한 도메인 로직을 표현할 때 사용한다. 주로 다음 상황에서 도메인 서비스를 사용한다.</p>\n<hr contenteditable=\"false\" />\n<ul>\n<li>계산 로직\n<ul>\n<li>여러 애그리거트가 필요한 계산 로직이나, 한 애그리거트에 넣기에는 다소 복잡한 계산 로직</li>\n</ul>\n</li>\n<li>외부 시스템 연동이 필요한 도메인 로직\n<ul>\n<li>구현하기 위해 타 시스템을 사용해야 하는 도메인 로직</li>\n</ul>\n</li>\n</ul>\n<hr contenteditable=\"false\" />\n<h4>7.2.1 계란 로직과 도메인 서비스</h4>\n<p>도메인 서비스는 상태 없이 로직만을 구현한다는 것이 가장 중요한 점이다.</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708091136957\"><code>public class DiscountCalculationService {\n    public Money calculateDiscountAmounts(\n            List&lt;OrderLine&gt; orderLines,\n            List&lt;Coupon&gt; coupons,\n            MemberGrade grade\n    ){\n        Money couponDiscount = cupons.stream()\n                .map(cupon -&gt; calculateDiscount(cupon))\n                .reduce(Money(0), (v1, v2) -&gt; v1.add(v2));\n\n        Money membershipDiscount = calculateDiscount(orderer.getMember().getGrade());\n        \n        return couponDiscount.add(membershipDiscount);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>DiscountCalculationService를 Order 도메인에서 전달받아 사용하면 사용 주체는 Order 도메인이 된다.(?)</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708091615408\"><code>public class Order {\n\n    public void calculateAmounts(DiscountCalculationService disCalSvc, MemberGrade grade){\n        Money totalAmounts = getTotalAmounts();\n        Money discountAmounts = disCalSvc.calculateDiscountAmounts(this.orderLines, this.coupons, grade);\n        this.paymentAmounts = totalAmounts.minus(discountAmounts);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>응용 서비스에서는 애그리거트 객체에게 도메인 서비스를 전달한다. (굳이 왜 전달하나 의문이긴 하다.)</p>\n<p>&nbsp;</p>\n<pre class=\"java\" id=\"code_1708091864179\"><code>public class TransferService {\n    public void transfer(Account fromAcc, Account toAcc, Money amounts){\n        fromAcc.withdraw(amounts);\n        toAcc.credit(amounts);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>이건 응용 서비스에서 불러주는 도메인 서비스이다. 흐음... 구분이 좀 복잡한 기분이 있긴하다.</p>\n<p>&nbsp;</p>\n<h4>7.2.2 외부 시스템 연동과 도메인 서비스</h4>\n<p>외부 시스템이나 타 도메인과의 연동 기능도 도메인 서비스가 될 수 있다.</p>\n<p>&nbsp;</p>\n<h4>7.2.3 도메인 서비스의 패키지 위치</h4>\n<p>도메인 서비스는 도메인 로직을 표현하므로 도메인 서비스의 위치는 다른 도메인 구성요소와 동일한 패키지에 위치한다.</p>\n<hr contenteditable=\"false\" />\n<p><figure class=\"imageblock alignCenter\"><span><img height=\"342\" src=\"https://blog.kakaocdn.net/dn/cVj5cU/btsEZBlTPtq/LOQXyiBVCRKNWfBFQHG73k/img.png\" width=\"662\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<hr contenteditable=\"false\" />\n<h4>7.2.4 도메인 서비스의 인터페이스와 클래스</h4>\n<p>도메인 서비스의 로직이 고정되어 있지 않은 경우 도메인 서비스 자체를 인터페이스로 구현하고 이를 구현한 클래스를 둘 수도 있다.</p>",
		"date": "Feb 16, 2024",
		"writer": "11기 성창규"
	},
	"feed-34": {
		"title": "[포트충돌해결] SpringBoot mariadb mysql 연동",
		"link": "https://velog.io/@handmk/ERROR-2002-HY000-Cant-connect-to-local-server-through-socket-tmpmysql.sock-2",
		"description": "<blockquote>\n<p>📌 버전 관리 📌\nOS :  macOS 14.2.1\nModel : M2 Chip\nSpring Boot V : 2.5.6</p>\n</blockquote>\n<h2 id=\"📌-문제-발생\">📌 문제 발생</h2>\n<p>기존에 MariaDB를 사용하다가 MariaDB와 MySQL을 같이 사용하고 싶어서 Homebrew 패키지 관리자로 MySQL 설치 했다.\n/etc/my.cnf 파일에 문서편집기 nano로 접근하여 [mysqld] port = 3307 로 설정 후 MariaDB에 접속하려는 순간 </p>\n<pre><code>ERROR 2002 (HY000): Can't connect to local server through socket '/tmp/mysql.sock' (2)</code></pre><p>이런 에러가 떴다.</p>\n<p>해당 에러의 원인을 구글링을 해봤는데, mysql 에서 pork 되어서 업그레이드 된 Database 가 MariaDB 이기에 사용하는 디폴트 포트가 동일한 이유였다..</p>\n<h2 id=\"해결\">해결</h2>\n<p>(저의 해결 방법이 정답이라곤 말 못하겠습니다 위에 명시된 것처럼 저와 목적성이 같으신 분만 글을 읽어주세요🙇🏻‍♂️)</p>\n<h3 id=\"1-첫번째-경우\">1. 첫번째 경우</h3>\n<p>(나의 경우 이 경우는 아니였다)</p>\n<p>구글링을 해보니 MariaDB Server 가 꺼져있으면 위에 에러가 뜬다고 해서</p>\n<pre><code>brew services list</code></pre><p>로 서버가 구동하고 있는지 확인했다. 서버는 잘 구동됐다.</p>\n<p>만약 이 글을 읽는 분들이 서버가 꺼져 있다면,</p>\n<pre><code>brew services restart mariadb\n또는\nbrew services stop mariadb\nbrew services start mariadb</code></pre><p>시도해보세요! (여기서 해결되면 다행)</p>\n<h3 id=\"2-두번째-경우\">2. 두번째 경우</h3>\n<p>(근본 해결 x)\n다시 port 원복 후, mysql을 지웠다.\n이젠 됐겠지 하고 mariadb를 접속하려고 했는데 똑같은 에러 메세지가 나왔다..</p>\n<p>이럴 땐 아예 다 지우고 다시 까는게 답인것 같아</p>\n<pre><code>brew services stop mariadb\nbrew unlink mariadb\nbrew remove mariadb\nbrew uninstall mariadb\nbrew cleanup</code></pre><p>후에</p>\n<pre><code>sudo rm -rf /usr/local/var/\nsudo rm -rf /usr/local/bin/mysql*\nsudo rm -rf /usr/local/Cellar/mariadb</code></pre><p>관련 디렉토리와 파일까지 싹 다 삭제 후 재설치 했는데,</p>\n<pre><code>Already downloaded: /Users/제이름/Library/Caches/Homebrew/downloads/e4b28094a97ef6969ef0f85ae740f70c06151edd06e3004cb29e8fc5b8072f6e--mariadb-11.2.2.bottle_manifest.json</code></pre><p>이미 존재 한다고 뜨고, service 를 재 시작 하라는 말만 떴다..</p>\n<p>구글링을 해보니 부팅 시 자동으로 서버가 돌아가게끔 설정해 두고 껐다 키면 해결 된다고 해서 껐다 켜보니 정말 거짓말처럼 접속이 됐다.\n[시스템 설정] -&gt; [일반] -&gt; [로그인항목] -&gt; mysqld_safe 허용\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/12358373-8f5f-47d7-9bf9-91d9f269d70d/image.png\" /></p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/c992bd70-0b0c-47a1-abee-239d299f63ca/image.png\" /></p>\n<p>하지만 나의 목표는 MySQL 과 MariaDB를 동시에 사용하는 것이기 때문에 더 찾아보았다.</p>\n<h3 id=\"3-세번째-경우\">3. 세번째 경우</h3>\n<p>좀 더 찾아보니 Homebrew로 MySQL 과 MariaDB를 포트만 다르게 환경설정 하는 것이 복잡하다고 한다.\nasdf, rbenv 같은 버전 관리 도구를 사용해서 MySQL과 MariaDB 버전을 다르게 해서 관리 하는 방법도 있으나 복잡한 걸 싫어하는 나는 Docker 로 독립된 환경에서 실행하여 동일한 바이너리를 가진 패키지 충돌을 막았다.</p>\n<p>방법은 간단하다.</p>\n<ol>\n<li><p>docker 설치\n<a href=\"https://www.docker.com/get-started/\">https://www.docker.com/get-started/</a>\ndocker.dmg 를 다운 받고 docker 어플리케이션을 실행시켜준다.</p>\n</li>\n<li><p>Docker 이미지 다운로드\nMariaDB 또는 MySQL 이 이미 설치가 됐다는 가정하에 새로 설치할 DB를 선택하여 이미지를 다운 받아준다.</p>\n<pre><code>docker pull mariadb 또는 mysql</code></pre><pre><code>docker images</code></pre><p>요런식으로 확인이 가능하다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/5139da36-d71b-4f8e-a565-108f13263ad9/image.png\" /></p>\n</li>\n<li><p>Docker 컨테이너 생성 및 실행\n현재 나는 HomeBrew로 MariaDB를 설치해서 3306port 를 사용중이다. 때문에 호스트의 3307포트 -&gt; docker container의 3306 포트로 포트포워딩을 해야한다.\n이미지를 다운 받았으면 컨테이너를 생성하고 port를 설정하여 컨테이너를 실행시킨다.</p>\n<pre><code>docker run --name 컨테이너이름 -e MYSQL(또는 MARIADB)_ROOT_PASSWORD=비밀번호 -p 3307:3306 -d mysql\n</code></pre></li>\n</ol>\n<pre><code>4. MySQL 또는 MariaDB 접속 확인</code></pre><p>mysql -h 127.0.0.1 -P 3307 -u root -p</p>\n<pre><code>\n추후에 접속 하려고 하는데 에러가 뜬다면 컨테이너가 멈춘것이다.\n이땐 컨테이너를 확인하자\n이렇게 consol 에서 확인할 수도 있고,</code></pre><p>docker ps // 실행중인 컨테이너 확인\ndocker ps -a // 전체 컨테이너 확인</p>\n<pre><code>\n![](https://velog.velcdn.com/images/handmk/post/e373dad7-a3cb-4a9c-a413-62cd2dd8aa97/image.png)\nDocker Desktop 에서도 확인 가능하다!\n\n### SpringBoot 연결\n**application.properties**</code></pre><p>spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3307/database\nspring.datasource.username=root\nspring.datasource.password=password</p>\n<p>spring.jpa.hibernate.ddl-auto=create\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true</p>\n<p>```</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/ea47e923-d8ad-4541-b089-1b80968a7d49/image.png\" /></p>\n<p>성공!</p>",
		"date": "Jan 29, 2024",
		"writer": "11기 손민기"
	},
	"feed-25": {
		"title": "스프링부트_02",
		"link": "https://starlikedh.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B802",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img height=\"326\" src=\"https://blog.kakaocdn.net/dn/w0n6r/btsD5v0Sus7/CEh9kKk6ZnJDszHOTaPMk1/img.png\" width=\"580\" /></span></figure>\n</p>\n<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard\" rel=\"noopener\" target=\"_blank\">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard</a></p>\n<figure contenteditable=\"false\" id=\"og_1706347259726\"><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard%EF%BB%BF</p>\n<p class=\"og-desc\">&nbsp;</p>\n<p class=\"og-host\">www.inflearn.com</p>\n</div>\n</a></figure>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 부트 스타터와 라이브러리 관리</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><b><span style=\"color: #8cb3be;\">라이브러리 직접 관리</span></b><br /></span><span style=\"font-family: 'Noto Sans Light';\">: build.gradle 파일의 dependencies에다가 라이브러리 직접 지정</span></p>\n<pre class=\"java\"><code>dependencies {\n  // 1. 라이브러리 직접 지정\n  // 스프링 웹 MVC\n  implementation 'org.springframework:spring-webmvc:6.0.4'\n  // 내장 톰캣\n  implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.5'\n  // JSON 처리\n  implementation 'com.fasterxml.jackson.core:jackson-databind:2.14.1'\n  // 스프링 부트 관련\n  implementation 'org.springframework.boot:spring-boot:3.0.2'\n  implementation 'org.springframework.boot:spring-boot-autoconfigure:3.0.2'\n  ...\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 각각의 라이브러리의 버전까지 골라서 선택해야 하는 문제점 존재<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 가장 어려운 문제는 각 라이브러리들 간에 서로 호환이 잘 되는 버전도 있지만 호환이 잘 안되는 버전도 있다는 점</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\">스프링 부트 라이브러리 버전 관리</span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: <i><b>원하는 라이브러리만 고르면 스프링 부트가 버전에 맞춘 최적화된 라이브러리 버전 선택</b></i><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 버전 관리 기능 사용을 위해 아래처럼 플러그인 추가</span></p>\n<pre class=\"java\" id=\"code_1706346987239\"><code>// build.gradle - plugins 수정 예시\nplugins {\n  id 'org.springframework.boot' version '3.0.2'\n  id 'io.spring.dependency-management' version '1.1.0' //추가\n  id 'java'\n}</code></pre>\n<pre class=\"java\" id=\"code_1706347019405\"><code>// build.gradle - dependencies 수정 예시\ndependencies {\n  // 2. 스프링 부트 라이브러리 버전 관리\n  // 스프링 웹, MVC\n  implementation 'org.springframework:spring-webmvc'\n  // 내장 톰캣\n  implementation 'org.apache.tomcat.embed:tomcat-embed-core'\n  // JSON 처리\n  implementation 'com.fasterxml.jackson.core:jackson-databind'\n  // 스프링 부트 관련\n  implementation 'org.springframework.boot:spring-boot'\n  implementation 'org.springframework.boot:spring-boot-autoconfigure'\n  ...\n}</code></pre>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">스프링 부트 스타터</span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:스프링 부트는 이런 문제를 해결하기 위해 <i><b>프로젝트를 시작하는데 필요한 관련 라이브러리를 모아둔 스프링 부트 스타터를 제공</b></i><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 아래 라이브러리 하나로 지금까지 우리가 직접 넣어주었던 모든 라이브러리가 포함<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 스프링과 웹을 사용하고 싶으면 spring-boot-starter-web<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 스프링과 JPA를 사용하고 싶으면 spring-boot-starter-data-jpa</span></p>\n<pre class=\"java\" id=\"code_1706347165671\"><code>// build.gradle - dependencies 수정\ndependencies {\n  // 3. 스프링 부트 스타터\n  implementation 'org.springframework.boot:spring-boot-starter-web'\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">라이브러리 버전 변경</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:외부 라이브러리의 버전을 변경하고 싶을때는 아래와 같은 형식으로 변경 가능<br /></span><span style=\"font-family: 'Noto Sans Light';\">:스프링 부트가 관리하는 외부 라이브러리 버전 변경에 필요한 속성 값</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/dependency-versions.html#appendix.dependency-versions\" rel=\"noopener\" target=\"_blank\">https://docs.spring.io/spring-boot/docs/current/reference/html/dependency-versions.html#appendix.dependency-versions</a></span><span style=\"font-family: 'Noto Sans Light';\"></span></p>\n<figure contenteditable=\"false\" id=\"og_1706347306627\"><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/dependency-versions.html#appendix.dependency-versions\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">Dependency Versions</p>\n<p class=\"og-desc\">&nbsp;</p>\n<p class=\"og-host\">docs.spring.io</p>\n</div>\n</a></figure>\n<pre class=\"prolog\"><code>ext['tomcat.version'] = '10.1.4'\n</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">스프링 부트가 관리하는 외부 라이브러리의 버전을 변경하는 일은 거의 없지만 만약을 위해서 알아두기</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">자동 구성(Auto Configuration</span><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">)</span></p>\n<pre class=\"java\" id=\"code_1709378344668\"><code>@Slf4j\n@Configuration\npublic class DbConfig {\n    ...\n    @Bean\n    public TransactionManager transactionManager() {\n        log.info(\"TransactionManager 빈 등록\");\n        return new JdbcTransactionManager(dataSource());\n    }\n\n    @Bean\n    public JdbcTemplate jdbcTemplate() {\n        log.info(\"JdbcTemplate 빈 등록\");\n        return new JdbcTemplate(dataSource());\n    }\n}</code></pre>\n<p><i><span style=\"font-family: 'Noto Sans Light';\">DbConfig 에서 빈 등록을 제거하는 방법은 2가지</span></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">1) @Configuration 을 주석처리해서 해당 설정 파일 자체를 스프링이 읽어들이지 않도록 하는 방법</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">2) @Bean 주석처리: @Bean 이 없으면 스프링 빈으로 등록하지 않음</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">스프링 부트는 자동 구성 기능 제공</span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">일반적으로 자주 사용하는 수 많은 빈들을 자동으로 등록해주는 기능</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">앞서 우리가 살펴보았던 JdbcTemplate , DataSource , TransactionManager 모두 스프링 부트가 자동 구성을 제공해서 자동으로 스프링 빈으로 등록</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">다음과 같은 자동 구성 기능들이 다음 빈들을 등록</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">1) JdbcTemplateAutoConfiguration : JdbcTemplate</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">2) DataSourceAutoConfiguration : DataSource</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">3) DataSourceTransactionManagerAutoConfiguration : TransactionManager</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">스프링 부트는 수 많은 자동 구성을 제공하고 spring-boot-autoconfigure 에 자동 구성을 모아둠</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">스프링 부트 프로젝트를 사용하면 spring-boot-autoconfigure 라이브러리는 기본적으로 사용</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">@Conditional</span></b></p>\n<p>사용하기 위해서는 Condition class를 상속받아야함</p>\n<pre class=\"java\" id=\"code_1709378648703\"><code>// 환경 정보가 memory=on 이라는 조건에 맞으면 동작하고, 그렇지 않으면 동작하지 않음\n@ConditionalOnProperty(name = \"memory\", havingValue = \"on\")</code></pre>\n<p>@ConditionalOnProperty</p>\n<pre class=\"java\" id=\"code_1709378670016\"><code>package org.springframework.boot.autoconfigure.condition;\n@Conditional(OnPropertyCondition.class)\npublic @interface ConditionalOnProperty {...}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">@ConditionalOnProperty 도 우리가 만든 것과 동일하게 내부에는 @Conditional 을 사용</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">그리고 그 안에 Condition 인터페이스를 구현한 OnPropertyCondition 를 가지고 있음</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">@<b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">ConditionalOnXxx</span></b></span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">1) @ConditionalOnClass , @ConditionalOnMissingClass <br />: 클래스가 있는 경우 동작한다. 나머지는 그 반대</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">2) @ConditionalOnBean , @ConditionalOnMissingBean <br />: 빈이 등록되어 있는 경우 동작한다. 나머지는 그 반대</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">3) @ConditionalOnProperty<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 환경 정보가 있는 경우 동작</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">4) @ConditionalOnWebApplication , @ConditionalOnNotWebApplication<br />: 웹 애플리케이션인 경우 동작</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">대표적인 것 이외에 나머지 것들은 아래 링크 공식 메뉴얼에서 확인<br /><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations\" rel=\"noopener\" target=\"_blank\">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations</a><br /></span></p>\n<figure contenteditable=\"false\" id=\"og_1709378775283\"><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">Core Features</p>\n<p class=\"og-desc\">In the absence of an Executor bean in the context, Spring Boot auto-configures an AsyncTaskExecutor. When virtual threads are enabled (using Java 21+ and spring.threads.virtual.enabled set to true) this will be a SimpleAsyncTaskExecutor that uses virtual t</p>\n<p class=\"og-host\">docs.spring.io</p>\n</div>\n</a></figure>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\"><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">자동 구성 대상 지정 및 동작 원리</span></b></span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">스프링 부트 자동 구성을 적용하려면, 다음 파일에 자동 구성 대상을 꼭 지정해주어야 함</span></p>\n<pre class=\"java\" id=\"code_1709378830484\"><code>/*\n 파일 생성 경로 \n : src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n*/\n\nmemory.MemoryAutoConfig</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">생략되었지만 앞서 만든 자동 구성인 memory.MemoryAutoConfig 를 패키지를 포함해서 지정<br /></span><span style=\"font-family: 'Noto Sans Light';\">스프링 부트는 시작 시점에 org.springframework.boot.autoconfigure.AutoConfiguration.imports 의 정보를 읽어서 자동 구성으로 사용<br /></span><span style=\"font-family: 'Noto Sans Light';\">따라서 내부에 있는 MemoryAutoConfig 가 자동으로 실행됨</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">동작 원리로는 @SpringBootApplication &rarr; @EnableAutoConfiguration &rarr; @Import(AutoConfigurationImportSelector.class)</span></b></i></p>\n<p>&nbsp;</p>\n<p><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\"><b><span style=\"color: #8cb3be; font-family: 'Noto Sans Light';\">@Import</span></b></span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">1) 정적인 방법: @Import (클래스) 이것은 정적. 코드에 대상이 딱 박혀 있음. 설정으로 사용할 대상을 동적으로 변경할 수 없음</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">2) 동적인 방법: @Import ( ImportSelector ) 코드로 프로그래밍해서 설정으로 사용할 대상을 동적으로 선택할 수 있음</span></p>\n<p>&nbsp;</p>",
		"date": "Jan 27, 2024",
		"writer": "6기 정다혜"
	},
	"feed-26": {
		"title": "스프링부트_01",
		"link": "https://starlikedh.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8",
		"description": "<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard\" rel=\"noopener&nbsp;noreferrer\" target=\"_blank\">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard</a></p>\n<figure contenteditable=\"false\" id=\"og_1706343997809\"><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9/dashboard\" rel=\"noopener\" target=\"_blank\">\n<div class=\"og-image\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\">스프링 부트 - 핵심 원리와 활용 강의 - 인프런</p>\n<p class=\"og-desc\">실무에 필요한 스프링 부트는 이 강의 하나로 모두 정리해드립니다., 백엔드 개발자를 위한 스프링 부트 끝판왕!&nbsp;실무에 필요한 내용을 모두 담았습니다.&nbsp; [임베딩 영상] 김영한의 스프링 완전</p>\n<p class=\"og-host\">www.inflearn.com</p>\n</div>\n</a></figure>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 부트 소개</span></p>\n<p><i><span style=\"font-family: 'Noto Sans Light';\"><b>BOOT</b></span></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:시작을 위한 복잡한 설정 과정은 스프링 부트가 해결<br /></span><span style=\"font-family: 'Noto Sans Light';\"><span style=\"color: #8cb3be;\">: 스프링을 편리하게 사용할 수 있도록 지원</span><b><br /></b></span><span style=\"font-family: 'Noto Sans Light';\">: 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">스프링 부트 핵심 기능</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><b>: was</b>&nbsp; - 웹 서버를 내장해서 별도의 웹 서버 설치 불필요<br /></span><span style=\"font-family: 'Noto Sans Light';\"><b>: 라이브러리 관리 -&nbsp; </b></span><span style=\"font-family: 'Noto Sans Light';\">손쉬운 빌드 구성을 위한 스타터 종속성 제공 및 </span><span style=\"font-family: 'Noto Sans Light';\">스프링과 외부 라이브러리의 버전을 자동으로 관리<br /></span><span style=\"font-family: 'Noto Sans Light';\"><b>: 자동 구성 - </b>프로젝트 시작에 필요한 스프링과 외부 라이브러리의 빈을 자동 등록<br /></span><span style=\"font-family: 'Noto Sans Light';\"><b>: 외부 설정 - </b>환경에 따라 달라져야 하는 외부 설정 공통화<br /></span><span style=\"font-family: 'Noto Sans Light';\"><b>: 프로덕션 준비</b> - 모니터링을 위한 메트릭, 상태 확인 기능 제공</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">웹 서버와 서블릿 컨테이너</span></p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">외장 서버 vs 내장 서버</span></b></i></p>\n<p><figure class=\"imageblock alignLeft\"><span><img height=\"197\" src=\"https://blog.kakaocdn.net/dn/pHdIu/btsD3JS5teC/e8HpgSYYYaNuvHoSnWWqVK/img.png\" width=\"560\" /></span></figure>\n</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">- 전통적인 방식</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 서버에 톰캣 같은 WAS 설치<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 그리고 WAS에서 동작하도록 서블릿 스펙에 맞춰서 코드 작성하고 빌드 해서 war 파일 생성<br /></span><span style=\"font-family: 'Noto Sans Light';\">: war파일 WAS 전달해서 배포하는 방식으로 전체 개발 주기 동작</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">- 최근 방식</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 코드를 작성하고 JAR 빌드 후 JAR 원하는 위치에서 실행히가민 하면 WAS도 함께 실행<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 더 쉽게 말해 개발자는 main() 메서드만 실행하면 됨</span><span style=\"font-family: 'Noto Sans Light';\"><i></i></span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">JAR, WAR</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">- JAR</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 자바는 여러 클래스와 리소스를 묶어서 JAR (Java Archive)라고 하는 압축 파일 생성<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 이 파일은 JVM 위에서 직접 실행되거나 또는 다른 곳에서 사용하는 라이브러리로 제공<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 직접 실행하는 경우 main() 메서드가 필요하고, MANIFEST.MF 파일에 실행할 메인 메서드가 있는 클래스를 지정해 두어야 함</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">- WAR</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 웹 애플리케이션 서버(WAS)에 배포할 때 사용하는 파일<br /></span><span style=\"font-family: 'Noto Sans Light';\">: HTML 같은 정적 리소스와 클래스 파일을 모두 함께 포함하기 때문에 JAR와 비교해서 구조가 더 복잡</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">WAR 빌드와 배포</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\"><b>프로젝트 빌드</b></span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">1) cmd창에서 프로젝트 폴더의 build로 이동<br /></span><span style=\"font-family: 'Noto Sans Light';\">2) gradlew build 실행<br /></span><span style=\"font-family: 'Noto Sans Light';\">3) WAR 파일 생성 확인<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp; &nbsp;build/libs/server-0.0.1-SNAPSHOT.war</span></p>\n<p><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\"><b>WAR 압축 풀기</b></span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">4) build/libs 폴더로 이동<br /></span><span style=\"font-family: 'Noto Sans Light';\">5) jar -xvf server-0.0.1-SNAPSHOT.war 명령어로 압축 풀기</span></p>\n<p><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\"><b>WAR를 푼 결과</b></span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">6) WEB-INF , classes , lib 같은 폴더들이 보이면 제대로 war 풀린 것</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">WEB-INF : 이폴더 하위는 자바 클래스와 라이브러리, 그리고 설정 정보가 들어가는 곳<br /></span><span style=\"font-family: 'Noto Sans Light';\">classes : 실행 클래스 모음<br /></span><span style=\"font-family: 'Noto Sans Light';\">lib : 라이브러리 모음<br /></span><span style=\"font-family: 'Noto Sans Light';\">web.xml : 웹 서버 배치 설정 파일(생략 가능)</span></p>\n<p><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\"><b>WAR 배포</b></span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">7) 톰캣 서버 종료 후 톰캣 폴더에 webapps 하위 폴더 일괄삭제<br /></span><span style=\"font-family: 'Noto Sans Light';\">8) 빌드된 war파일 ctrl + c, ctrl + v<br /></span><span style=\"font-family: 'Noto Sans Light';\">9) war파일 이름 ROOT.war로 변경 후 톰캣 서버 실행</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">서블릿 컨테이너 초기화</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">서블릿을 등록하는 두 가지 방법에는 @WebServlet 애노테이션 활용과 프로그래밍 방식 존재</span></p>\n<pre class=\"java\" id=\"code_1706345749919\"><code>// HelloServlet 이라는 서블릿을 서블릿 컨테이너 초기화 시점에 프로그래밍 방식으로 직접 등록\n// HTTP로 /hello-servlet 를 호출하면 HelloServlet\n\n//순수 서블릿 코드 등록\nServletRegistration.Dynamic helloServlet = servletContext.addServlet(\"helloServlet\", new HelloServlet());\nhelloServlet.addMapping(\"/hello-servlet\");</code></pre>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">스프링 컨테이너 등록</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">WAS와 스프링을 통합.</span></p>\n<pre class=\"reasonml\"><code>// 스프링 컨테이너 생성\nAnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();\nappContext.register(HelloConfig.class);\n\n// 스프링 MVC 디스패처 서블릿 생성, 스프링 컨테이너 연결\nDispatcherServlet dispatcher = new DispatcherServlet(appContext);\n\n// 디스패처 서블릿을 서블릿 컨테이너에 등록\nServletRegistration.Dynamic servlet = servletContext.addServlet(\"dispatcherV2\", dispatcher);\n\n// /spring/* 요청이 디스패처 서블릿을 통하도록 설정\nservlet.addMapping(\"/spring/*\");\n</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">AnnotationConfigWebApplicationContext 가 바로 스프링 컨테이너.<br /></span><span style=\"font-family: 'Noto Sans Light';\">디스패처 서블릿에 HTTP 요청이 오면 디스패처 서블릿은 해당 스프링 컨테이너에 들어있는 컨트롤러 빈들을 호출.<br /></span><span style=\"font-family: 'Noto Sans Light';\">addServlet으로 디스패처 서블릿을 서블릿 컨테이너에 등록.</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">스프링 MVC 서블릿 컨테이너 초기화 지원</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">스프링 MVC에서 서블릿 컨테이너 초기화 작업을 이미 만들어두었음.<br /></span><span style=\"font-family: 'Noto Sans Light';\">따라서 애플리케이션 초기화 코드만 작성하면 됨.</span></p>\n<pre class=\"java\"><code>@Override\npublic void onStartup(ServletContext servletContext) throws ServletException {\n    System.out.println(\"AppInitV3SpringMvc.onStartup\");\n\n    // 스프링 컨테이너 생성\n    AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();\n    appContext.register(HelloConfig.class);\n\n    // 스프링 MVC 디스패처 서블릿 생성, 스프링 컨테이너 연결\n    DispatcherServlet dispatcher = new DispatcherServlet(appContext);\n\n    // 디스패처 서블릿을 서블릿 컨테이너에 등록\n    ServletRegistration.Dynamic servlet = servletContext.addServlet(\"dispatcherV3\", dispatcher);\n\n    // 모든 요청이 디스패처 서블릿을 통하도록 설정\n    servlet.addMapping(\"/\");\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">WebApplicationInitializer 는 스프링이 이미 만들어둔 애플리케이션 초기화 인터페이스.<br /></span><span style=\"font-family: 'Noto Sans Light';\">servlet.addMapping(\"/\") 코드를 통해 모든 요청이 해당 서블릿을 타도록 함.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 부트와 내장 톰캣</span></p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light'; text-align: start;\">내장 톰캣에 스프링 연동</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 서블릿 컨테이너 초기화와 거의 같은 코드<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 시작점이 개발자가 main() 메서드를 직접 실행하는가, 서블릿 컨테이너가 제공하는 초기화 메서드를 통해서 실행하는지의 차이</span></p>\n<pre class=\"java\" id=\"code_1706346249526\"><code>// 스프링 컨테이너 생성\nAnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();\nappContext.register(HelloConfig.class);\n\n// 스프링 MVC 디스패처 서블릿 생성, 스프링 컨테이너 연결\nDispatcherServlet dispatcher = new DispatcherServlet(appContext);\n\n// 디스패처 서블릿 등록\nContext context = tomcat.addContext(\"\", \"/\");\n      \ntomcat.addServlet(\"\", \"dispatcher\", dispatcher);\ncontext.addServletMappingDecoded(\"/\", \"dispatcher\");\n\ntomcat.start();</code></pre>\n<p><i><b><span style=\"font-family: 'Noto Sans Light'; text-align: start;\">내장 톰캣 빌드와 배포</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: WAR와 다르게 JAR 파일은 내부에 라이브러리 역할을 하는 JAR 파일을 포함할 수 없음<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 대안으로는 라이브러리 jar 파일을 모두 구해서 MANIFEST 파일에 해당 경로를 적어주면 인식이 되지만 매우 번거롭기 때문에 권장 방법은 아님<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 그래서 또 다른 대안으로는 <span style=\"color: #8cb3be;\">fat jar 혹은 uber jar라고 불리는 방법</span><br /></span><span style=\"font-family: 'Noto Sans Light'; color: #8cb3be;\">: 라이브러리에 사용되는 jar 를 풀면 class 들이 나온다. 이 class 를 뽑아서 새로 만드는 jar 에 포함하는 것</span></p>\n<pre class=\"java\" id=\"code_1706346306329\"><code>// Fat Jar 생성, build.gradle - buildFatJar\n\ntask buildFatJar(type: Jar) {\n\tmanifest {\n    \tattributes 'Main-Class': 'hello.embed.EmbedTomcatSpringMain'\n\t}\n\tduplicatesStrategy = DuplicatesStrategy.WARN\n\tfrom { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }\n\twith jar\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">gradlew clean buildFatJar로 빌드해주고 jar파일 실행해주기.</span></p>\n<pre class=\"java\" id=\"code_1706346402083\"><code>... % java -jar embed-0.0.1-SNAPSHOT.jar\nEmbedTomcatSpringMain.main\n...\nINFO: Starting Servlet engine: [Apache Tomcat/9.0.65]\n...\nINFO: Starting ProtocolHandler [\"http-nio-8080\"]</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">build/libs 폴더로 가서 jar -xvf embed-0.0.1-SNAPSHOT.jar 명령어로 압축 풀기</span></p>\n<p><span style=\"color: #8cb3be;\"><b><span style=\"font-family: 'Noto Sans Light';\">Fat jar</span></b></span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: Fat Jar 덕분에 하나의 jar 파일에 필요한 라이브러리들을 내장할 수 있게 되었음<br /></span><span style=\"font-family: 'Noto Sans Light';\">:내장 톰캣 라이브러리를 jar 내부에 내장할 수 있게 되었음.<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 덕분에 하나의 jar 파일로 배포부터, 웹 서버 설치+실행까지 모든 것을 단순화 가능<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 하지만 어떤 라이브러리가 포함되어 있는지 확인하기 어려운 단점 존재<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 클래스나 리소스명이 같은 경우 하나를 포기해야 하는 파일명 중복 해결 불가 단점 존재</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light'; text-align: start;\">스프링 부트와 웹서버</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 내장 톰캣을 사용해서 빌드와 배포를 편리하게 함<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 빌드시 하나의 Jar를 사용하면서, 동시에 Fat Jar 문제도 해결<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 내장 톰캣 서버를 실행하기 위한 과정 자동 처리<br /></span><span style=\"font-family: 'Noto Sans Light';\"><u><span style=\"color: #8cb3be;\">: </span></u><span style=\"color: #8cb3be;\">spring-boot-starter-web 를 사용하면 내부에서 내장 톰캣을 사용</span><u><br /></u></span><span style=\"font-family: 'Noto Sans Light';\">:라이브러리 버전은&nbsp;</span><span style=\"font-family: 'Noto Sans Light';\">스프링 부트를 사용하면 라이브러리 뒤에 버전 정보가 없는 것을 확인 후,<br /></span><span style=\"font-family: 'Noto Sans Light';\">현재 부트 버전에 가장 적절한 외부 라이브러리 버전을 자동으로 선택</span></p>\n<pre class=\"java\" id=\"code_1706346132555\"><code>dependencies {\n\timplementation 'org.springframework.boot:spring-boot-starter-web'\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\n}</code></pre>",
		"date": "Jan 20, 2024",
		"writer": "6기 정다혜"
	},
	"feed-35": {
		"title": "[c++] 11660번 구간 합 구하기 5",
		"link": "https://velog.io/@handmk/c-%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0-2",
		"description": "<p><strong>시간제한 : 1초</strong></p>\n<h2 id=\"📕-문제\">📕 문제</h2>\n<p>N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.</p>\n<p>예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/5b12d559-08fd-4b2d-91ac-cd9d306b9963/image.png\" />\n여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.</p>\n<p>표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.</p>\n<h2 id=\"📙-입력\">📙 입력</h2>\n<p>첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)</p>\n<p><strong>예제 입력</strong></p>\n<pre><code>4 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\n4 5 6 7\n2 2 3 4\n3 4 3 4\n1 1 4 4</code></pre><h2 id=\"📗-출력\">📗 출력</h2>\n<p>총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.</p>\n<p><strong>예제 출력</strong></p>\n<pre><code>27\n6\n64</code></pre><h2 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h2>\n<p>구간 합에 대한 접근으로 문제를 풀 수 있습니다.</p>\n<blockquote>\n<p>구간 합이란?\nA {1,2,3,4} 배열이 있을 때 S{1,3,6,10} 으로 그 전 인덱스 값들을 다 더하는 것입니다.</p>\n</blockquote>\n<p>이렇게 하면, 좋은 점은 A[i] ~ A[j] 까지의 합을 구해야 할 때\n만약 i=0, j가 N 인 경우 시간 복잡도는 O(N)이 됩니다.</p>\n<p>구간 합을 구했을 경우에는 인덱스로 접근이 가능하기 때문에 O(1) 로 줄어들기 때문에 구간 합을 이용합니다.</p>\n<h3 id=\"구간-합을-이용한-풀이\">구간 합을 이용한 풀이</h3>\n<ol>\n<li><p>1행과 1열의 구간 합 배열을 머리속으로 그려줍니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/33ff563f-587f-4dd3-9c7e-285b07a15cd8/image.jpeg\" />\n1행의 구간 합은 rowS[1][i] = numA[1][i-1] + numA[1][i] 입니다. \n1열의 구간 합 또한 같은 원리로 colS[i][1] = numA[i-1][1] +numA[i][1] 입니다.</p>\n</li>\n<li><p>내부 구간 합을 채웁니다.\nS[2][2]를 구하는 원리는 다음과 같습니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/c1d9dc29-3aab-497b-a002-1cd7069281e4/image.jpeg\" />\nS[2][2] = S[2][1] + S[1][2] - S[1][1] + numA[2][2] = (1+2) + (1+2) - 1 + 3</p>\n</li>\n</ol>\n<p>이를 공식화 하면</p>\n<p>S[i][j] = S[i][j-1] + S[i-1][j] - S[i-1][j-1] + numA[i][j] 로 정형화 할 수 있습니다.</p>\n<ol start=\"3\">\n<li>구간 합을 구해줍니다.\n예시 입력 [2][2] ~ [3][4]을 보면\nS[3][4] -  S[3][1] - S[1][4] + S[1][1] 로 도출 할 수 있습니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/4a6207d2-9e9e-4a37-bbb0-aa308fdd4ba1/image.jpeg\" /></li>\n</ol>\n<blockquote>\n<p>S[3][4] : 파란색, S[3][1] 빨간색, S[1][4] 보라색, S[1][1] S[3][1] 과 S[1][4]의 공통부분</p>\n</blockquote>\n<p>해당 코드 입니다.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int N, M;\n\n    cin &gt;&gt; N &gt;&gt; M;\n\n    vector&lt;vector&lt;int&gt;&gt; S(N+1, vector&lt;int&gt;(N+1,0)); // 2차원 벡터 생성, 빈 공간 0으로 초기화\n\n    for(int i=1; i&lt;=N; i++){\n        for(int j=1; j&lt;=N; j++){\n            int number;\n            cin &gt;&gt; number;\n            S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + number; // 구간합으로 숫자 채우기\n        }\n    }\n\n    for(int i=0; i&lt;M; i++){\n        int X1, Y1, X2, Y2;\n        cin &gt;&gt; X1 &gt;&gt; Y1 &gt;&gt; X2 &gt;&gt; Y2;\n\n        cout &lt;&lt; S[X2][Y2] - S[X2][Y1-1] - S[X1-1][Y2] + S[X1-1][Y1-1] &lt;&lt; '\\n'; // 좌표로 구간합 도출\n    }\n\n    return 0;\n\n\n}</code></pre>",
		"date": "Jan 19, 2024",
		"writer": "11기 손민기"
	},
	"feed-36": {
		"title": "[Linux/Ubuntu] 가상 머신으로 실무 환경 구축(1)",
		"link": "https://velog.io/@handmk/LinuxUbuntu-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0%EC%9C%BC%EB%A1%9C-%EC%8B%A4%EB%AC%B4-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%951",
		"description": "<h2 id=\"요약\">요약</h2>\n<p>학부생 입장에서 백엔드 파트로 프로젝트를 참여하게 되면 아무래도 서버 비용이 만만치 않은데, 매번 AWS, GCP, NCP 등 플랫폼을 이용해서 서버를 열게 되면 비용적인 측면에서도 그렇고 제가 직접 공부해서 환경을 구축해보고 싶어서 공부한 내용을 적어 보려고 합니다.</p>\n<p>++ 참고 자료\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/eda49603-629f-4746-a707-0585a8228864/image.png\" /></p>\n<h2 id=\"본문\">본문</h2>\n<p>실제 실무 환경에서는 여러 대의 PC를 하나의 네트워크로 운영한다고 합니다.\n하지만 제가 가진 주식이 대박이 터지지 않는 이상 4대 이상의 PC를 가지고 있는 건 불가능하겠죠?</p>\n<p>그래서 <strong>가상머신 소프트웨어</strong> VMware를 사용하여 1대의 호스트 PC에서 4대의 <strong>가상머신</strong>을 구축할 것 입니다.</p>\n<blockquote>\n<p>가상머신이란?\n실제 존재하는 컴퓨터가 아닌 말 그대로 가상의 컴퓨터!\n가상머신에는 메모리, CPU, HDD, CD/DVD 등 하드웨어적인 부분들을 설정할 수도 있고,\nOS를 깔 수도 있는 실제 우리가 알고있는 컴퓨터와 동일한 기능을 합니다.\n이렇게 깐 OS는 가짜 컴퓨터인지 진짜 컴퓨터인지 구별을 못하고 충실히 운영돼요!</p>\n</blockquote>\n<p>이런 구조로\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/5c900ac1-9b22-4d74-bd57-3d72ec7b8ed3/image.png\" />\n1개의 Window OS로 Linux 3대와 Window 1대를 구축하여 실무와 유사한 환경을 구축하려 합니다.</p>\n<h3 id=\"사양-확인\">사양 확인</h3>\n<p>호스트 컴퓨터의 메모리와 CPU 코어수가 부족하게 되면 가상환경 구축 시 어려움이 있기 때문에 사양을 먼저 확인해야 합니다.\n<a href=\"http://www.grc.com/securable.htm\">http://www.grc.com/securable.htm</a> 에서 SecurAble 프로그램을 다운 받고 실행을 하면\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/850c0892-fdd4-4e87-a8b5-243c1fbd8987/image.png\" />\nCPU는 달라도 밑에 화면은 동일하게 나와야 이상적인 환경입니다.</p>\n<h3 id=\"vmware-workstation-설치\">VMware WorkStation 설치</h3>\n<p>사양이 확인 됐으면, 가상 소프트웨어(VMware WorkStatation)를 설치해줘야 합니다.</p>\n<blockquote>\n<p>상업용이라면 VMware Worksation Pro를 설치해야해요.\n<a href=\"https://www.vmware.com/products/workstation\">https://www.vmware.com/products/workstation</a></p>\n</blockquote>\n<p>이렇게 설치하고 프로그램을 실행하면,\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/31110956-343b-42ec-aa8f-929ed1ac9d79/image.png\" />\nWorkstation Home이 나옵니다.\n(저는 PRO를 써보고 싶어 평가판으로 설치했습니다.)</p>\n<h3 id=\"가상머신-생성\">가상머신 생성</h3>\n<p>왼쪽 상단에 File -&gt; New Virtual Machines\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/4364acbd-3c55-4f38-b047-93f1fbbc9186/image.png\" /></p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/8c577163-dc7b-43e1-acbb-a250a9fae8ad/image.png\" />\n생성 화면이 나오게 됩니다.\n기본적인 세팅으로 할 지 커스텀 세팅할 지에 대한 내용인데 일단 Typical로 체크하고 Next를 눌러줍니다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/311a7063-46ef-4a1f-95a7-2587011e4085/image.png\" />\n가상머신을 생성하면서 OS를 어떻게 설치할건지에 대한 내용인데 나중에 설치하는 방법으로 선택하고 Next를 눌러줍니다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/0ba1bdc0-49b6-4fa4-8003-c1ddc122f219/image.png\" />\n저는 Linux 게스트 가상머신을 생성할 것이기 때문에 Linux/Ubuntu 64-bit로 생성했습니다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/a9b2e294-bd7b-4f07-aa1e-39eef72c4e50/image.png\" />\n가상머신의 이름과 경로를 지정할 수 있어요. 여러대의 가상머신을 구축하는 것이라면 상위폴더 하나에 여러 가상머신 폴더를 생성하여 저장하는 것이 좋습니다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/a251bbbb-ffb1-4b7f-ac9e-1dd5176f5855/image.png\" />\n가상머신의 HDD 용량을 정할 수 있는데, 굳이 여기서 안해도? 생성 후 수정할 수 있습니다.</p>\n<blockquote>\n<p>가상머신의 HDD\n가상머신에서는 저 20GB를 실제 용량이라고 인식하지만, 사실은 호스트컴퓨터 입장에서 10MB 정도의 파일로 인식을 해요!\n그 이후에 가상머신에 OS를 설치하고 실제 공간이 필요해지게 되면 10MB -&gt; 점점 늘어나요</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/c48adfa4-f32e-4a0f-8ec6-8ba9cee21dc1/image.png\" />\n위 단계를 거치게 되면 사양에 대한 요약본이 뜹니다. 바로 Finish를 누르면\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/8d79a979-1162-4db2-ba6a-75916a566440/image.png\" />\n성공적으로 생성된 것을 보실 수 있습니다.</p>\n<h3 id=\"하드웨어-수정\">하드웨어 수정</h3>\n<p>아까 가상머신 생성 후에 하드웨어 사양을 수정할 수 있다고 했죠?\n위의 화면에서 Edit virtual machine settings를 누르면\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/202ffa1d-e0bb-473a-8de3-86dee6747196/image.png\" />\n수정 할 수 있는 화면이 나옵니다.</p>\n<p>현재 보시는 화면은 Memory 부분인데, Memory(RAM)은 호스트 컴퓨터의 실제 메모리를 가상머신들이 나눠 쓰는 구조입니다.\n예를 들어 제 컴퓨터가 16GB일때 생성한 가상머신이 4GB로 생성했다면? 가상머신 부팅 후 4GB를 때주고 호스트는 12GB만 사용합니다. (이래서 아까 사양을 검사했어요!)</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/220ef0f5-c00b-4d52-bfbb-4a37ec3d1e36/image.png\" />\n다음은 CPU인데, 가상머신에서는 성능이 크게 의미가 없기 때문에 그냥 1로 두는 것이 좋습니다.(물론 멀티코어 일 수록 좋긴 하지만, 호스트의 코어가 쿼드가 아닌 이상 안하시는걸..)</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/bec50f70-7a84-44c1-8b0e-df7a438ca295/image.png\" />\nHDD는 Remove를 하고 다시 Add를 하셔야 합니다!</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/0ab5b9bb-eef0-4f6e-8288-ed564d3a3773/image.png\" /></p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/5ac5bef2-1a5d-4d14-b62a-7e3ed2e934a6/image.png\" />\ndisk 타입인데 아무거나 상관없으나, 생성 할 가상머신들을 하나로 통일해주여야 합니다.</p>\n<p>디스크타입을 정해주면 어떻게 사용할 것인지 선택하는 창이 뜨는데\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/8c71381e-4db4-457a-9ba5-4092c9eaf64a/image.png\" /></p>\n<p>Create a new virtual disk : 새로 생성\nUse an existing virtual disk : 기존의 디스크 사용\nUse a physical disk : 진짜 물리적인 하드디스크를 가상머신에 장착</p>\n<p>본인의 사양에 맞게 선택하시면 됩니다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/34155a65-241d-4211-9085-c23d69804e4c/image.png\" />\nCD/DVD는 Connect at power on 에 꼭 체크해야 합니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/128eff11-5ce0-485f-90f5-008b3b97812d/image.png\" />\nNetwork는 NAT 방식으로 설정해야 하나의 네트워크로 묶는 효과를 낼 수 있습니다.</p>\n<p>최종적으로 다음과 같은 4대의 가상머신을 생성하였습니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/58338a15-52e8-4332-8b26-8c6d545d9ca7/image.jpg\" /></p>",
		"date": "Jan 16, 2024",
		"writer": "11기 손민기"
	},
	"feed-37": {
		"title": "[C++] 시간 복잡도 표기법",
		"link": "https://velog.io/@handmk/C-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%ED%91%9C%EA%B8%B0%EB%B2%95",
		"description": "<h3 id=\"📌-요약\">📌 요약</h3>\n<p>기업 코딩테스트를 준비하려고 하는데 전공 수업때 배운 알고리즘 내용이 있지만, 수업 때는 사실 진도를 따라가기 바빴고, 프로그래밍 언어 또한 바꼈기 때문에 책을 하나 샀습니다.\n<a href=\"https://book.interpark.com/product/BookDisplay.do?_method=detail&amp;sc.saNo=001&amp;sc.prdNo=356224381\">https://book.interpark.com/product/BookDisplay.do?_method=detail&amp;sc.saNo=001&amp;sc.prdNo=356224381</a>\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/389780d3-9a97-404f-8f4f-f2650ff9fdda/image.png\" /></p>\n<p>책 내용을 보면, 백준 문제로 구성이 됐고 문제에 대한 유튜브 강의 해설도 업로드 해주며 알고리즘 이론 내용이 포함돼 있어 저에게 필요한 내용들인 것 같아 이 책으로 공부해보려 합니다.</p>\n<h3 id=\"📗-본론\">📗 본론</h3>\n<h4 id=\"1-시간-복잡도-표기법-알아보기\">1. 시간 복잡도 표기법 알아보기</h4>\n<p>시간 복잡도의 종류</p>\n<ul>\n<li>빅 오메가(Ω(n)) : 최선일 때(best case) 연산 횟수</li>\n<li>빅 세타(Θ(n)) : 보통일 때(average case) 연산 횟수</li>\n<li>빅 오(O(n)) : 최악일 때(worst case) 연산 횟수</li>\n</ul>\n<blockquote>\n<p>c++ 에서는 1억번의 연산을 1초의 수행시간으로 예측합니다!</p>\n</blockquote>\n<p>왜 코딩테스트에서는 빅 오(O(n))를 기준으로 수행 시간을 계산 하냐?\n실제 테스트에서는 1개의 테스트 케이스로 합격, 불합격을 결정하지 않습니다.</p>\n<p>응시자가 작성한 프로그램으로 다양한 테스트 케이스를 돌려봤을 때 모두 통과해야 한다는 소리죠</p>\n<h4 id=\"2-시간-복잡도-활용\">2. 시간 복잡도 활용</h4>\n<p>이런 문제가 있다고 해보죠\n<strong>시간 제한 2초 이하</strong>\n<strong>문제</strong>\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.</p>\n<p><strong>입력</strong>\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.</p>\n<pre><code>5\n5\n2\n3\n4\n1</code></pre><p><strong>출력</strong>\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.</p>\n<pre><code>1\n2\n3\n4\n5</code></pre><p>버블정렬(O(n^2)) 과 병합정렬(O(nlogn)) 을 비교했을 때\n시간 제한이 2초 이하 == 2억번의 연산 이하 가 되게끔 알고리즘을 선택을 해야합니다.</p>\n<p>시간 복잡도는 항상 최악의 상황을 고려해야 하기 때문에 N이 1,000,000이 입력됐다고 하면</p>\n<p>버블정렬 = (1,000,000)^2 = 1,000,000,000,000 &gt; 200,000,000</p>\n<p>병합정렬 = 1,000,000log(1,000,000) = 약 20,000,000 &lt; 200,000,000</p>\n<p>이 문제에선 병합정렬 알고리즘을 구현하여 문제를 푸는게 합리적입니다.</p>\n<p>이처럼 데이터의 크기를 고려하여 알고리즘을 선택하는 것이 중요합니다.</p>\n<h4 id=\"3-시간-복잡도를-바탕으로-로직-개선\">3. 시간 복잡도를 바탕으로 로직 개선</h4>\n<p><strong>1.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int N = 1000;\n    int cnt = 1;\n\n    for(int i=0; i&lt;N; i++){\n        cout &lt;&lt; &quot;연산 횟수 :&quot; &lt;&lt; cnt++ &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n}</code></pre><p><strong>2.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int N = 1000;\n    int cnt = 1;\n\n    for(int i=0; i&lt;N; i++){\n        cout &lt;&lt; &quot;연산 횟수 :&quot; &lt;&lt; cnt++ &lt;&lt; &quot;\\n&quot;;\n    }\n    for(int i=0; i&lt;N; i++){\n        cout &lt;&lt; &quot;연산 횟수 :&quot; &lt;&lt; cnt++ &lt;&lt; &quot;\\n&quot;;\n    }\n    for(int i=0; i&lt;N; i++){\n        cout &lt;&lt; &quot;연산 횟수 :&quot; &lt;&lt; cnt++ &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n}</code></pre><p><strong>3.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int N = 1000;\n    int cnt = 1;\n\n    for(int i=0; i&lt;N; i++){\n        for(int j=0; j&lt;N; j++){\n            cout &lt;&lt; &quot;연산 횟수 :&quot; &lt;&lt; cnt++ &lt;&lt; &quot;\\n&quot;;\n        }\n    }\n    return 0;\n}</code></pre><p>3개의 코드가 있다고 할 때 시간복잡도를 살펴봅시다.</p>\n<p>시간복잡도를 도출하는 기준은 다음과 같아요</p>\n<blockquote>\n<ul>\n<li>상수는 시간 복잡도 계산에서 제외한다.</li>\n</ul>\n</blockquote>\n<ul>\n<li>가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.</li>\n</ul>\n<p>위에 기준에 견주어 1번을 보았을 때, N번 만큼 for 문이 도니까 O(N) 로 생각 할 수 있겠죠.\n2번은 for문이 3개 입니다. 연산 횟수가 1번에 비해 3배나 차이가 나네요. O(3N)\n하지만, 상수는 제외 하므로 1,2번 모두 시간 복잡도는 O(N)로 일치합니다.</p>\n<p>3번은 이중 for문이 있는데 가장 많이 중첩된 반복문의 수행 횟수가 기준이 되므로 O(N^2)이 되겠습니다.\n만약 이중 for문 다음에 일반 for문이 100개가 있다 하더라도 O(N^2 + 100N)이 되므로 시간 복잡도의 변화 없이 O(N^2)이 유지됩니다.</p>\n<p>이처럼 시간 복잡도를 도출 하면 코딩 테스트에서 시간 초과되어 문제를 틀렸을 때 문제가 되는 코드를 도출하는 시간을 줄일 수 있습니다.</p>",
		"date": "Jan 12, 2024",
		"writer": "11기 손민기"
	},
	"feed-27": {
		"title": "스프링 DB 데이터 접근 활용 기술_04",
		"link": "https://starlikedh.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-DB-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%ED%99%9C%EC%9A%A9-%EA%B8%B0%EC%88%A004",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/bP6Uxx/btsDiOUB7vn/qH4MZh8RRqOeQZjA5WQjO0/img.png\" /></span></figure>\n</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 트랜잭션 전파2 - 활용</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 함.</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 이 요구사항을 만족하기 위해서 로그와 관련된 물리 트랜잭션을 REQUIRES_NEW를 사용해서 별도로 분리.</span><span style=\"font-family: 'Noto Sans Light';\"></span><span style=\"font-family: 'Noto Sans Light';\"></span></p>\n<pre class=\"java\" id=\"code_1704858996301\"><code>/**\n * MemberService @Transactional:ON\n * MemberRepository @Transactional:ON\n * LogRepository @Transactional(REQUIRES_NEW) Exception\n */\n@Test\nvoid recoverException_success() {\n\t //given\n\t String username = \"로그예외_recoverException_success\";\n\n\t //when\n\t memberService.joinV2(username); //예외를 복구하는 memberService.joinV2()를 사용\n\n\t //then: member 저장, log 롤백\n\t assertTrue(memberRepository.find(username).isPresent());\n\t assertTrue(logRepository.find(username).isEmpty());\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: MemberRepository 는 REQUIRED 옵션을 사용한다. 따라서 기존 트랜잭션에 참여.</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: LogRepository 의 트랜잭션 옵션에 REQUIRES_NEW 를 사용.</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: REQUIRES_NEW 는 항상 새로운 트랜잭션을 만들기 때문에 해당 트랜잭션 안에서는 DB 커넥션도 별도로 사용.</span><span style=\"font-family: 'Noto Sans Light';\"></span></p>\n<p><figure class=\"imageblock alignLeft\"><span><img src=\"https://blog.kakaocdn.net/dn/JaM6N/btsDh6gV0E3/uF1u3nnF8VZpyiz2TRiaxK/img.png\" width=\"700\" /></span></figure>\n</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 논리 트랜잭션은 하나라도 롤백되면 관련된 물리 트랜잭션은 롤백되어 버림.</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 이 문제를 해결하려면 REQUIRES_NEW 를 사용해서 트랜잭션을 분리.</span></p>",
		"date": "Jan 10, 2024",
		"writer": "6기 정다혜"
	},
	"feed-28": {
		"title": "스프링 DB 데이터 접근 활용 기술_03",
		"link": "https://starlikedh.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-DB-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%ED%99%9C%EC%9A%A9-%EA%B8%B0%EC%88%A003",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/rpIKp/btsDbcpiVuG/59XrMAROcSt9psWFTBUsV1/img.png\" /></span></figure>\n</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 트랜잭션 이해</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 스프링은 PlatformTransactionManager 라는 인터페이스를 통해 트랜잭션을 추상화<br /></span><span style=\"font-family: 'Noto Sans Light';\">: PlatformTransactionManager 를 사용하는 방법은 크게 2가지로 구분<br /></span><span style=\"font-family: 'Noto Sans Light';\">1) 선언적 트랜잭션 관리<br /></span><span style=\"font-family: 'Noto Sans Light';\"><i><b>&nbsp; &nbsp; &nbsp;@Transactional 어노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용<br /></b></i></span><span style=\"font-family: 'Noto Sans Light';\">2)프로그래밍 방식 트랜잭션 관리 <br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp; 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: AopUtils.isAopProxy() 로 Aop 확인<br /></span><span style=\"font-family: 'Noto Sans Light';\">: TransactionSynchronizationManager.isActualTransactionActive() <br />&nbsp; &nbsp;현재 쓰레드에 트랜잭션이 적용되어 있는지 확인할 수 있는 기능</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Sans Light';\">: 스프링에서<i> 우선순위는 항상 더 구체적이고 자세한 것이 높은 우선순위.<br /></i></span></b><span style=\"font-family: 'Noto Sans Light';\">: 스프링의 @Transactional 은 다음 두 가지 규칙이 존재<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp;1) 우선순위 규칙<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp;2)클래스에 적용하면 메서드는 자동 적용</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: public이 아닌 곳에 @Transactional 사용 시 예외가 발생하지는 않고, 트랜잭션 적용만 무시 <br />(스프링 부트 3.0 부터는 protected , package-visible (default 접근제한자)에도 트랜잭션이 적용)</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 스프링 초기화 시점에 트랜잭션 사용하기<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; - ApplicationReadyEvent 이벤트를 사용<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; - 이 이벤트는 트랜잭션 AOP를 포함한 스프링이 컨테이너가 완전히 생성되고 난 다음에 이벤트가 붙은 메서드를 호출</span></p>\n<p>&nbsp;</p>\n<p><i><b><span style=\"font-family: 'Noto Sans Light';\">트랜잭션 옵션 소개</span></b></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><i><b>rollbackFor</b> <br />:</i> 이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백할 지 지정 <br />ex) @Transactional(rollbackFor = Exception.class) <br />이렇게 지정하면 체크 예외인 Exception이 발생해도 커밋 대신 롤백(자식 타입도 롤백됨)</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><br /></span><span style=\"font-family: 'Noto Sans Light';\"><i><b>noRollbackFor</b> <br />:</i> 기본 정책에 추가로 어떤 예외가 발생했을 때 롤백하면 안되는지 지정</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><i><b>isolation</b> <br />:</i> 트랜잭션 격리 수준 지정(일반적으로 많이 사용하는 READ COMMITTED-커밋된 읽기)</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><i><b>timeout</b> <br />:</i> 트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정</span></p>\n<p>&nbsp;</p>\n<p><b><i><span style=\"font-family: 'Noto Sans Light';\">readOnly=true 옵션을 사용하면 읽기 전용 트랜잭션이 생성</span></i></b></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><i><b>: 예외 발생 시 스프링 트랜잭션 AOP는 예외의 종류에 따라 트랜잭션을 커밋하거나 롤백</b></i><br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp; - 언체크 예외인 RuntimeException , Error 와 그 하위 예외가 발생하면 트랜잭션을 롤백<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp; - 체크 예외인 Exception 과 그 하위 예외가 발생하면 트랜잭션을 커밋<br /></span><span style=\"font-family: 'Noto Sans Light';\">&nbsp; &nbsp; - 정상 응답(리턴)하면 트랜잭션 커밋</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 비즈니스 의미가 있는 비즈니스 예외라는 것은??<br /></span><span style=\"font-family: 'Noto Sans Light';\">ex) 주문 시 결제 잔고가 부족하면 주문 데이터를 저장하고 결제 상태를 대기로 처리 이 경우 고객에게 잔고 부족을 알리고 별도의 계좌로 입금하도록 안내</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: JPA 테이블 자동 생성<br /></span><span style=\"font-family: 'Noto Sans Light';\">application.properties 에 spring.jpa.hibernate.ddl-auto 옵션 사용 (none이면 테이블 생성 x, create면 애플리케이션 시작 시점에 테이블 생성 )</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa; text-align: start;\">스프링 트랜잭션 전파1 - 기본</span></p>\n<p><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"> Commit<br /></span></b></p>\n<pre class=\"java\" id=\"code_1704853360151\"><code>TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());\n\nlog.info(\"트랜잭션 커밋 시작\");\ntxManager.commit(status);\nl-og.info(\"트랜잭션 커밋 완료\");</code></pre>\n<pre class=\"java\" id=\"code_1704853381488\"><code>// Commit() 실행 로그\nmain] hello.springtx.propagation.BasicTxTest   : 트랜잭션 커밋 시작\n o.s.j.d.DataSourceTransactionManager           : Initiating transaction commit\n main] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@903028779 wrapping conn0: url=jdbc:h2:mem:81400691-b69c-440c-af57-422ffadf0607 user=SA]\n main] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@903028779 wrapping conn0: url=jdbc:h2:mem:81400691-b69c-440c-af57-422ffadf0607 user=SA] after transaction\n main] hello.springtx.propagation.BasicTxTest   : 트랜잭션 커밋 완료</code></pre>\n<p><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"> <b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\">Rollback</span></b></span></b></p>\n<pre class=\"java\" id=\"code_1704853430774\"><code>TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());\n\nlog.info(\"트랜잭션 롤백 시작\");\ntxManager.rollback(status);\nlog.info(\"트랜잭션 롤백 완료\");</code></pre>\n<pre class=\"java\" id=\"code_1704853446538\"><code>// Rollback() 실행 로그\n\nhello.springtx.propagation.BasicTxTest   : 트랜잭션 롤백 시작\nmain] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback\nmain] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@903028779 wrapping conn0: url=jdbc:h2:mem:5f0a68a1-c6da-47c0-94da-ad5e2bee39f6 user=SA]\nmain] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection</code></pre>\n<p><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\">Double Commit Rollback</span></b></span></b></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><span style=\"font-family: 'Noto Sans Light';\">: 전체 트랜잭션을 묶지 않고 각각 관리했기 때문에, <br />트랜잭션1에서 저장한 데이터는 커밋되고 트랜잭션2에서 저장한 데이터는 롤백됨.</span></span></p>\n<pre class=\"java\" id=\"code_1704853482690\"><code>void double_commit_rollback() {\n\tlog.info(\"트랜잭션1 시작\");\n    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());\n    log.info(\"트랜잭션1 커밋\");\n    txManager.commit(tx1);\n\n    log.info(\"트랜잭션2 시작\");\n    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());\n    log.info(\"트랜잭션2 롤백\");\n    txManager.rollback(tx2);\n }</code></pre>\n<pre class=\"java\" id=\"code_1704853491796\"><code>// double_commit_rollback() 실행 로그\n \n: Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n : Acquired Connection [HikariProxyConnection@1554473375 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA] for JDBC transaction\n : Switching JDBC Connection [HikariProxyConnection@1554473375 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA] to manual commit\n : 트랜잭션1 커밋\n : Initiating transaction commit\n : Committing JDBC transaction on Connection [HikariProxyConnection@1554473375 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA]\n : Releasing JDBC Connection [HikariProxyConnection@1554473375 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA] after transaction\n : 트랜잭션2 시작\n : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n : Acquired Connection [HikariProxyConnection@1426420939 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA] for JDBC transaction\n : Switching JDBC Connection [HikariProxyConnection@1426420939 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA] to manual commit\n : 트랜잭션2 롤백\n : Initiating transaction rollback\n : Rolling back JDBC transaction on Connection [HikariProxyConnection@1426420939 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA]\n : Releasing JDBC Connection [HikariProxyConnection@1426420939 wrapping conn0: url=jdbc:h2:mem:6e1d9f3d-d663-4026-adf3-a54cea9ff5c2 user=SA]</code></pre>\n<p style=\"color: #333333; text-align: start;\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\">Inner Commit&nbsp;</span></b></span></b></p>\n<pre class=\"java\" id=\"code_1704853522622\"><code>void inner_commit() {\n\tlog.info(\"외부 트랜잭션 시작\");\n    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());\n    log.info(\"outer.isNewTransaction()={}\", outer.isNewTransaction());  // true\n\n    log.info(\"내부 트랜잭션 시작\");\n    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());\n    log.info(\"inner.isNewTransaction()={}\", inner.isNewTransaction());  // false\n    log.info(\"내부 트랜잭션 커밋\");\n    txManager.commit(inner);\n\n    log.info(\"외부 트랜잭션 커밋\");\n    txManager.commit(outer);\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 내부 트랜잭션을 시작하는 시점에는 이미 외부 트랜잭션이 진행중인 상태<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 이 경우 내부 트랜잭션은 외부 트랜잭션에 참여</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 뜻<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻<br />: 정리하면 외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶이는 것</span></p>\n<pre class=\"java\" id=\"code_1704853601299\"><code>// inner_commit() 실행 로그\n\n외부 트랜잭션 시작\nCreating new transaction with name [null]:PROPAGATION_REQUIRED,ISOLATION_DEFAULT\nAcquired Connection [HikariProxyConnection@1943867171 wrapping conn0] for JDBC transaction\nSwitching JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] to manual commit\nouter.isNewTransaction()=true\n내부 트랜잭션 시작\nParticipating in existing transaction\ninner.isNewTransaction()=false\n내부 트랜잭션 커밋\n외부 트랜잭션 커밋\nInitiating transaction commit\nCommitting JDBC transaction on Connection [HikariProxyConnection@1943867171wrapping conn0]\nReleasing JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] after transaction</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 내부 트랜잭션을 시작할 때 Participating in existing transaction 이라는 메시지를 확인할 수 있는데,<br />이 메시지는 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 만약 내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 끝나버리기 때문에 트랜잭션을 처음 시작한 외부 트랜잭션까지 이어갈 수 없음</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:따라서 내부 트랜잭션은 DB 커넥션을 통한 물리 트랜잭션을 커밋하면 안됨<br /></span><span style=\"font-family: 'Noto Sans Light';\">:스프링은 이렇게 여러 트랜잭션이 함께 사용되는 경우, 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리하도록 함</span></p>\n<p><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\">Inner Commit<br /></span></b></span></b></p>\n<p><figure class=\"imageblock alignLeft\"><span><img height=\"234\" src=\"https://blog.kakaocdn.net/dn/c9Clkg/btsDh7NAi9D/EKdrP1q1MxA9XHhJ82HJVK/img.png\" width=\"600\" /></span></figure>\n</p>\n<pre class=\"java\" id=\"code_1704853776012\"><code>void inner_rollback() {\n\tlog.info(\"외부 트랜잭션 시작\");\n\tTransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());\n\tlog.info(\"내부 트랜잭션 시작\");\n    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());\n\tlog.info(\"내부 트랜잭션 롤백\");\n    txManager.rollback(inner);\n    log.info(\"외부 트랜잭션 커밋\");\n    assertThatThrownBy(() -&gt; txManager.commit(outer))\n\t\t  .isInstanceOf(UnexpectedRollbackException.class);\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">:내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지는 않지만 기존 트랜잭션을 롤백 전용으로 표시<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 외부 트랜잭션 커밋을 호출했지만 내부 트랜잭션 롤백에서 기존 트랜잭션을 롤백 전용으로 표시했기 때문에 물리 트랜잭션을 롤백</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 논리 트랜잭션이 하나라도 롤백되면 물리 트랜잭션은 롤백<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 외부 트랜잭션을 커밋할 때 롤백 전용 마크를 확인해서 롤백 전용 마크가 표시되어 있으면 물리 트랜잭션을 롤백하고, UnexpectedRollbackException 예외를 던짐</span></p>\n<p><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"> <b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\"><b><span style=\"color: #006dd7; font-family: 'Noto Sans Light';\">Inner Rollback Requires New</span></b></span></b></span></b></span></b></p>\n<pre class=\"java\" id=\"code_1704853856468\"><code>void inner_rollback_requires_new() {\n\tlog.info(\"외부 트랜잭션 시작\");\n    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());\n    log.info(\"outer.isNewTransaction()={}\", outer.isNewTransaction());  // true\n\n    log.info(\"내부 트랜잭션 시작\");\n    DefaultTransactionAttribute definition = new DefaultTransactionAttribute();\n    definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n\t\t\n    TransactionStatus inner = txManager.getTransaction(definition); \n    log.info(\"inner.isNewTransaction()={}\", inner.isNewTransaction());  // true\n\n    log.info(\"내부 트랜잭션 롤백\");\n    txManager.rollback(inner);\n\n    log.info(\"외부 트랜잭션 커밋\");\n    txManager.commit(outer);\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 내부 트랜잭션을 시작 시 전파 옵션인 propagationBehavior 에PROPAGATION_REQUIRES_NEW 옵션 설정<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 이 전파 옵션을 사용하면 내부 트랜잭션을 시작할 때 기존 트랜잭션에 참여하는 것이 아니라 새로운 물리 트랜잭션을 만들어서 시작하게 됨<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 하지만 REQUIRES_NEW 를 사용하면 데이터베이스 커넥션이 동시에 2개 사용되어 성능 측면에서는 주의해야 함.</span></p>",
		"date": "Jan 10, 2024",
		"writer": "6기 정다혜"
	},
	"feed-54": {
		"title": "Spring Security: There is no PasswordEncoder mapped for the id \"null\" 오류 해결",
		"link": "https://velog.io/@yunh03/Spring-Security-There-is-no-PasswordEncoder-mapped-for-the-id-null-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0",
		"description": "<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/20a24365-2bc2-48a3-bfbc-700345128055/image.png\" /></p>\n<h3 id=\"상황\">상황</h3>\n<p>비밀번호 재설정 API를 개발하는 도중, 변경할 새로운 비밀번호가 기존 비밀번호와 일치하면 변경할 수 없도록 예외 처리를 진행하는 과정에서 <code>There is no PasswordEncoder mapped for the id &quot;null&quot;</code> 에러를 맞닥뜨렸다. 오류가 지시하고 있는 곳은 <code>SignServiceImpl</code>에서의 <code>passwordEncoder.matches()</code> 해당 부분이었다.</p>\n<h3 id=\"원인\">원인</h3>\n<pre><code>if(passwordEncoder.matches(user.get().getPassword(), resetPasswordRequestDto.getPassword())) {\n    ...\n}</code></pre><p>기존 등록된 사용자가 있다면 해당 사용자 객체의 비밀번호와 비밀번호 재설정 DTO에 입력된 비밀번호를 비교하여, 재설정할 비밀번호와 기존 비밀번호가 같다면 변경을 거부하는 코드이다.</p>\n<p>제대로 된 원인을 확인하기 전, PasswordEncoder의 matches 함수가 어떻게 구성되어 있는 지에 대해 먼저 확인해야 한다.</p>\n<pre><code>boolean matches(CharSequence var1, String var2);</code></pre><p>간단히 말하면 <code>var1</code>과 <code>var2</code>가 같다면 true를, 다르다면 false를 반환한다. 하지만, 간과한 점이 하나 있었다.</p>\n<p><code>var1</code>에는 rawPassword, 즉, 암호화 처리가 되기 전의 비밀번호가 입력되어야 하고 <code>var2</code>에는 encodedPassword, 즉, 암호화 된 비밀번호가 입력되어야 한다는 것이다. 간단히 정리하자면 다음과 같다.</p>\n<pre><code>boolean matches(CharSequence rawPassword, String encodedPassword);</code></pre><p>이제 기존의 코드를 확인해 보자.</p>\n<pre><code>passwordEncoder.matches(user.get().getPassword(), resetPasswordRequestDto.getPassword())</code></pre><p><code>user.get().getPassword()</code> 암호화 된 해시 값이 <code>var1</code>에 제시되었고, <code>resetPasswordRequestDto.getPassword()</code> 암호화 되지 않은 일반 문자열의 값이 <code>var2</code>에 제시되었다. 그렇기 때문에 이 부분에서 오류가 발생한 것이다.</p>\n<h3 id=\"해결\">해결</h3>\n<pre><code>if(passwordEncoder.matches(resetPasswordRequestDto.getPassword(), user.get().getPassword())) {\n    ...\n}</code></pre><p>위 코드와 같이, matches 함수에 맞춰 인코딩 되지 않은 비밀번호, 인코딩 된 비밀번호 순으로 값을 변경해 주었고, 그 결과 오류 없이 잘 작동되었다.</p>\n<p>해결하기 전에는 &quot;대체 뭘 잘 못한거지..&quot;라는 생각이었는데.. 막상 문제점을 찾고나니 너무 간단해서 허탈했다 ㅋㅋ.... 다음부터는 주의해서 개발하도록 다짐했다.</p>",
		"date": "Jan 10, 2024",
		"writer": "11기 전윤환"
	},
	"feed-29": {
		"title": "스프링 DB 데이터 접근 활용 기술_02",
		"link": "https://starlikedh.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-DB-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%ED%99%9C%EC%9A%A9-%EA%B8%B0%EC%88%A002",
		"description": "<p><figure class=\"imageblock alignCenter\"><span><img src=\"https://blog.kakaocdn.net/dn/d4bQUm/btsC9acEvZQ/dVeOTlKiQQNbBj8JLxgHak/img.png\" /></span></figure>\n</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa;\">데이터 접근 기술 - MyBatis</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">: mybatis.configuration.map-underscore-to-camel-case를 true로 설정 시 언더바를 카멜케이스로 자동 변경<br /><b>: XML</b>에서는 데이터 영역에 <b>&lt;, &gt;와 같은 특수문자 사용 불가</b>로 치환해서 쓰거나 CDATA 구문 활용</span><span style=\"font-family: 'Noto Sans Light';\"></span><span style=\"font-family: 'Noto Sans Light';\"></span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><i><b>동적 SQL</b></i><br /></span><span style=\"font-family: 'Noto Sans Light';\">- if<br /></span><span style=\"font-family: 'Noto Sans Light';\">- choose (when, otherwise)<br /></span><span style=\"font-family: 'Noto Sans Light';\">- trim (where, set)<br /></span><span style=\"font-family: 'Noto Sans Light';\">- foreach<br /></span><span style=\"font-family: 'Noto Sans Light';\">- &lt;sql&gt;로 SQL 재사용 가능, 불러오는거는 &lt;include refid=&rdquo;&rdquo;&gt;<br /></span><span style=\"font-family: 'Noto Sans Light';\">- 컬럼명과 프로퍼티 명 다를 시 별칭 사용하는 것 이외에도 resultMap 선언해서 사용 가능</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa;\">데이터 접근 기술 - JPA</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><b>: JPA는 Java Persistence API의 약자고 자바 진영의 ORM 기술 표준&nbsp;<br /></b></span><span style=\"font-family: 'Noto Sans Light';\">: ORM은 Object-relational mapping의 약자로 객체와 관계형 데이터베이스 매핑, 객체와 DB의 테이블이 매핑을 이루는 것<br /></span><span style=\"font-family: 'Noto Sans Light';\">: JPA에서 가장 중요한 부분은 <b>객체와 테이블을 매핑</b>하는 것<br /></span><span style=\"font-family: 'Noto Sans Light';\">: JPA는 <b>public 또는 protected 의 기본 생성자가 필수<br /></b></span></p>\n<pre class=\"java\" id=\"code_1704528105940\"><code>@Data\n@Entity //JPA가 사용하는 객체라는 뜻\npublic class Item {\n\n\t@Id @GeneratedValue(strategy = GenerationType.IDENTITY) // 테이블의 PK와 해당 필드 매핑\n\tprivate Long id;\n\t\n\t@Column(name = \"item_name\", length = 10)\n\tprivate String itemName;\n\t...\n\n\tpublic Item() {\n  }\n\t...\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 생성자를 보면 스프링을 통해 엔티티 매니저라는 것을 주입받은 것을 확인<br /></span><span style=\"font-family: 'Noto Sans Light';\">: JPA의 모든 동작은 엔티티 매니저를 통해서 이루어짐<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 엔티티 매니저는 내부에 데이터소스를 가지고 있고, 데이터베이스에 접근할 수 있음<br /></span><span style=\"font-family: 'Noto Sans Light';\">: JPA의 모든 데이터 변경(등록, 수정, 삭제)은 트랜잭션 안에서 이루어져야 하므로 Repository에 @Transactional 작성해주기<br /></span><span style=\"font-family: 'Noto Sans Light';\">: <b>JPA에서 객체를 테이블에 저장할 때는 엔티티 매니저가 제공하는 persist() 메서드 를 사용</b></span></p>\n<p>&nbsp;</p>\n<p><i><span style=\"font-family: 'Noto Sans Light';\"><b>JPQL</b></span></i></p>\n<p><span style=\"font-family: 'Noto Sans Light';\">:JPA는 JPQL(Java Persistence Query Language)이라는 <b>객체지향 쿼리 언어</b>를 제공<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 주로 여러 데이터를 복잡한 조건으로 조회할 때 사용</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa;\">데이터 접근 기술 - 스프링 데이터 JPA</span></p>\n<p><i><span style=\"font-family: 'Noto Sans Light';\"><b>:스프링 데이터 JPA는 JPA를 편리하게 사용할 수 있도록 도와주는 라이브러리<br /></b></span></i><span style=\"font-family: 'Noto Sans Light';\">- 공통 인터페이스 기능<br /></span><span style=\"font-family: 'Noto Sans Light';\">- 쿼리 메서드 기능</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Sans Light';\">JpaRepository 사용법</span></b></p>\n<pre class=\"java\" id=\"code_1704528310025\"><code>// JpaRepository 인터페이스를 인터페이스 상속 받고, 제네릭에 관리할 &lt;엔티티, 엔티티ID&gt;\npublic interface ItemRepository extends JpaRepository&lt;Item, Long&gt; {\n\t...\n\n\n\t...\n}</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">쿼리 메서드 기능 대신에 직접 JPQL을 사용하고 싶을 때는 @Query와 함께 JPQL을 작성.</span></p>\n<pre class=\"java\" id=\"code_1704528354685\"><code>// 쿼리 직접 실행\n// 파라미터 바인딩은 @Param(\"\")\n@Query(\"select i from Item i where i.itemName like :itemName and i.price &lt;= :price\")\nList&lt;Item&gt; findItems(@Param(\"itemName\") String itemName, @Param(\"price\") Integer price);</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light';\">: 스프링 데이터 JPA는 spring-boot-starter-data-jpa 라이브러리 build.gradle 추가<br /></span><span style=\"font-family: 'Noto Sans Light';\">: <b>JpaRepository 인터페이스를 인터페이스 상속 받으면 기본적인 CRUD 기능을 사용 가능</b><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 이름이나 가격으로 검색 기능은 공통으로 제공할 수 있는 기능이 아님<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 쿼리 메서드 기능 사용해서 구현<br /></span><span style=\"font-family: 'Noto Sans Light';\">: @Query로 직접 쿼리 실행</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa;\">데이터 접근 기술 - Querydsl</span></p>\n<p><i><span style=\"font-family: 'Noto Sans Light';\"><b>: 쿼리를 Java로 type-safe하게 개발할 수 있게 지원하는 프레임워크<br /></b></span></i><span style=\"font-family: 'Noto Sans Light';\">: 주로 JPA쿼리(JPQL)에 사용<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 단점으로는 Q코드 생성을 위한 APT를 설정해야함</span></p>\n<p>&nbsp;</p>\n<p><b><span style=\"font-family: 'Noto Sans Light';\">DSL(</span></b><span style=\"font-family: 'Noto Sans Light';\"><b>Domain Specific Language,도메인 특화 언어)</b><br /></span><span style=\"font-family: 'Noto Sans Light';\">: 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 특징으로는 단순하고 간결하다는 점</span></p>\n<pre class=\"java\" id=\"code_1704528425332\"><code>// 예시코드\nJPAQueryFactoryquery = newJPAQueryFactory(entityManager);\nQMemberm = QMember.member;\n\nList&lt;Member&gt; list = query\n\t.select(m)\n\t.from(m)\n\t.where(\n    \tm.age.between(20,40).and(m.name.like(\"김%\"))\n\t)\n\t.orderBy(m.age.desc())\n\t.limit(3)\n\t.fetch(m)</code></pre>\n<p><span style=\"font-family: 'Noto Sans Light'; background-color: #99cefa;\">데이터 접근 기술 - 활용 방안</span></p>\n<p><span style=\"font-family: 'Noto Sans Light';\"><b>트레이드 오프(구조의 안정성 vs 단순한 국조와 개발의 편리서 사이 선택)</b><br /></span><span style=\"font-family: 'Noto Sans Light';\">: DI, OCP를 지키기 위해 어댑터를 도입하고, 더 많은 코드를 유지<br /></span><span style=\"font-family: 'Noto Sans Light';\">: 어댑터를 제거하고 구조를 단순하게 가져가지만, DI, OCP를 포기</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>",
		"date": "Jan 06, 2024",
		"writer": "6기 정다혜"
	},
	"feed-38": {
		"title": "[SpringBoot] IoC, DI, AOP",
		"link": "https://velog.io/@handmk/SpringBoot-IoC-DI-AOP",
		"description": "<h3 id=\"👏-요약\">👏 요약</h3>\n<p>작년에 참여했던 🦁 11기 강남대학교 멋쟁이사자처럼 백엔드 파트🦁 에서 SpringBoot 를 공부하게 되었고, 현재 백엔드 개발자를 희망하는 지금 저의 주력 프레임워크가 됐으나 한번 개념적인 내용을 집고 넘어가고 싶어 이 글을 시작으로 요약해보려고 합니다.</p>\n<p>현재 이 포스팅에서는 다음과 같은 내용을 다뤄요</p>\n<ul>\n<li>Spring vs SpringBoot</li>\n<li>IoC</li>\n<li>DI</li>\n<li>AOP</li>\n</ul>\n<h3 id=\"📌-spring-vs-springboot\">📌 Spring vs SpringBoot</h3>\n<p>SpringBoot는 Spring 프레임워크의 단점을 보완하기 위해 나온 프레임 워크 입니다.\n그렇다면 어떤 점이 나은지 알아야겠죠?\n<strong>1. Spring의 설정의 복잡성</strong></p>\n<pre><code>&lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;\n    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/web_customer_tracker?useSSL=true&amp;amp;serverTimezone=Asia/Seoul&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;user&quot; value=&quot;springstudent&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;password&quot; value=&quot;springstudent&quot;&gt;&lt;/property&gt;\n\n    &lt;property name=&quot;minPoolSize&quot; value=&quot;5&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;maxIdleTime&quot; value=&quot;30000&quot;&gt;&lt;/property&gt;\n  &lt;/bean&gt;\n\n  &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;packagesToScan&quot; value=&quot;pe.pilseong.hibernateweb.entity&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;hibernateProperties&quot;&gt;\n      &lt;props&gt;\n        &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt;\n        &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;\n      &lt;/props&gt;\n    &lt;/property&gt;\n  &lt;/bean&gt;\n\n  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;\n    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;\n  &lt;/bean&gt;\n\n  &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;\n&lt;/beans&gt;</code></pre><p>지금 보시는 xml 코드는 spring에서 Hibernate 를 사용하기 위해 작성하는 설정파일의 일부입니다.\n지금은 객체 관계 매핑 프레임워크 하나라고 하지만 사용하는 모듈이 많아진다면....?\n버전관리도 해야하고..... 환경 설정하는 것부터 맥이 빠져버릴겁니다.😭</p>\n<p>이 상황을 대체하기 위해 SpringBoot는 <strong>spring-boot-stater</strong> 라는 Dependency를 추가하게 되면, 자주 사용하는 모듈들끼리 버전 호환까지 맞춰서 제공합니다.\n많이 사용되는 spring-boot-starter 라이브러리를 간략하게 소개하자면,</p>\n<ul>\n<li>spring-boot-stater-web : MVC를 사용하는 RESTful 어플리케이션을 개발하기 위한 의존성</li>\n<li>spring-boot-starter-test : JUnit 등 테스트용 라이브러리</li>\n<li>spring-boot-starter-jdbc : JDBC 기능 제공</li>\n<li>spring-boot-starter-security : 스프링 시큐리티 제공</li>\n<li>spring-boot-starter-data-jpa : 하이버네이트를 활용한 JPA 기능 </li>\n<li>spring-boot-starter-cache : 캐시 기능 지원</li>\n</ul>\n<p><strong>2. SpringBoot 자동 설정</strong>\nSpringBoot는 Spring의 기능을 사용하기 위한 자동설정(Auto Configuration)을 지원합니다.\n여기서 말하는 자동설정이란 <strong>추가된 라이브러리를 실행하는데 필요한 환경 설정을 알아서 찾아준다 라는 말인데요,</strong>\n다음은 SpringBoot 프로젝트를 생성하면 자동으로 생성되는 코드 입니다.</p>\n<pre><code>@SpringBootApplication\npublic class TestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Test.class, args);\n    }\n\n}</code></pre><p>위에 @SpringBootApplication는 어노테이션(Annotation)이라고 불리는데 3개의 어노테이션이 합해진 어노테이션입니다.</p>\n<ul>\n<li>@SpringBootConfiguration</li>\n<li>@EnableAutoConfiguration</li>\n<li>@ComponentScan</li>\n</ul>\n<p>만약 제가 작성한 코드로 SpringBootApplication을 실행시킬때, main 메서드가 돌아가는데 @SpringBootApplication안의 @ComponentScan이 @Component 시리즈의 어노테이션이 붙은 클래스들을 Spring Container 에 빈(Bean) 으로 등록합니다.</p>\n<blockquote>\n<p>@Componet 시리즈는 다음과 같아요</p>\n</blockquote>\n<ul>\n<li>@Controller</li>\n<li>@RestController</li>\n<li>@Service</li>\n<li>@Repository</li>\n<li>@Configuration</li>\n</ul>\n<p>이후 @EnableAutoConfiguration 어노테이션이 작동하여, spring-boot-autoconfigure 패키지 안에 spring.factories 파일 안에 있는 수많은 자동 설정들이 조건에 따라 적용됩니다.</p>\n<p><strong>3. SpringBoot 내장 WAS</strong>\n앞서 말했던, spring-boot-starter-web 모듈의 경우 내장 톰캣(Tomcat)을 제공합니다. 때문에 Web 어플리케이션을 개발하기 위해 Spring을 사용할 때 했던 여러 번거로운 짓을 하지 않아도 된다는 것이죠!</p>\n<p>여기까지 SpringBoot가 더 나은 점을 얘기했지만, 사실 SpringBoot는 Spring에서 나온 프레임워크이기에 Spring이 가지고 있는 장점 및 특징을 가지고 있어요. \n이에 대해 밑에서 부터 기술됩니다.</p>\n<h3 id=\"📕ioc-inversion-of-control\">📕IoC (Inversion of Control)</h3>\n<p><strong>제어의 역전</strong>이라고도 불리는데 단어 느낌만 봐도 먼가 <strong>주체가 아니다</strong> 라는 느낌이 나죠?</p>\n<p>앞서 Spring vs SpringBoot에 대해 얘기할 때 SpringBoot 어플리케이션을 실행하고 메인 클래스가 실행될 때 @ComponentScan이 작동하여 @Component 시리즈의 class들을 Spring Container에 Bean으로 등록한다! 라고 얘기한 내용이 있어요.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/21b6784c-8110-4585-9f8a-7207c55e64e2/image.jpeg\" />\n이런식으로 말이죠!</p>\n<p>그래서 Spring Container가 뭔데??🤔 라고 생각이 들어서 정리를 해봤습니다 :)</p>\n<p>Spring Container 는 <strong>객체들의 생명주기</strong>를 관리합니다!</p>\n<p>생명주기는 다음과 같은 단계를 거쳐요</p>\n<blockquote>\n<ul>\n<li>객체 생성</li>\n</ul>\n</blockquote>\n<ul>\n<li>의존성 주입</li>\n<li>초기화</li>\n<li>사용</li>\n<li>소멸</li>\n</ul>\n<p>코드로 한번 볼까요?</p>\n<pre><code>Myclass obj = new MyClass(); // 객체 생성\n\nMy Dependency dep = new MyDependency();\nobj.setDependency(dep); // 의존성 주입\n\nobj.init(); // 초기화\n\nobj.eat(); // 사용\n\nobj.close(); // 소멸\n</code></pre><p>한 객체를 생성하고 의존성을 주입하려면 개발자가 직접 관리를 해야 합니다.\n또한 new 생성자로 객체를 생성하고 class 간에 의존성을 높이게 되면 새로운 기능이 생겼을 때, 수작업으로 일일이 수정을 해야 하는 번거로운 상황이 발생합니다.\n이를 해결 하기 위해 <strong>Spring Container에 Bean으로 등록하여 직접 관리 하게끔 한다.</strong> 라고 하여\n<strong>제어의 역전</strong>이라고 합니다.</p>\n<h3 id=\"📗-di-dependency-injection\">📗 DI (Dependency Injection)</h3>\n<p>의존성 주입은 IoC에서 등록한 Bean을 class 에 주입하는 겁니다.</p>\n<pre><code>@RestController\npublic class TestController {\n\n    @Autowired\n    TestService testService;\n}</code></pre><p>이상한 점 못느끼셨나요?</p>\n<pre><code>@RestController\npublic class TestController {\n\n    TestService testService = new TestService();\n}</code></pre><p>원래라고 한다면 이렇게 객체를 선언 했겠지만 Spring에서는 IoC의 특징이 있기 때문에 개발자가 필요할 때마다 의존성을 Spring Container가 주입해주는 방식입니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/ff4c190d-c493-451e-bfde-3c53bd16ceb2/image.jpeg\" /></p>\n<p>이렇게 되면 class 간의 의존성이 느슨해지고 캡슐화를 높여 유지보수의 장점이 생겨요!</p>\n<h3 id=\"📙-aop-관점-지향-프로그래밍\">📙 AOP (관점 지향 프로그래밍)</h3>\n<p>AOP는 관점을 기준으로 묶어 개발하는 방식을 말합니다.</p>\n<p>어떤 기능을 구현할 때 <strong>핵심기능</strong> 과 <strong>부가기능</strong> 으로 구분해 각각을 하나의 관점으로 보는 것이죠.\n예를 들어 볼까요?</p>\n<pre><code>클라이언트로부터 상품 정보 등록 요청을 받고 DB에 저장, DB에서 그 상품 조회</code></pre><p>이 기능을 만들 때, (1) save(상품) (2)get(상품)이 기능의 핵심이죠?</p>\n<p>만약 이 로직들 사이에 로깅 처리를 하는 기능을 추가적으로 넣어야 한다면 일반적인 OOP라면\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/43272595-f2c6-4ecc-be5b-7fb65da7594a/image.jpeg\" />\n이렇게 흘러가겠죠\n하지만 여기서 공통적으로 사용되는 로깅 로직이 있다면?</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/6a762431-f6b2-4c59-81b0-015ed2772051/image.jpeg\" />\n반복되는 부가 기능을 하나의 공통 로직으로 처리하도록 모듈화해 삽입합니다.\n이 방식을 AOP 라고 합니다.</p>\n<h3 id=\"⭐️-정리\">⭐️ 정리</h3>\n<p>SpringBoot는 Spring에서 나온 프레임워크이기에 IoC, AOP, DI의 특징을 공통적으로 가지고, 추가적으로 WAS, 의존성관리와 같은 좋은 기능들이 SpringBoot의 큰 장점인 것 같습니다.\n아직 Auto-Configuration이나 Spring Container에 대한 내용이 좀 부족한 것 같아 직접 구현도 해보고 좀 더 깊게 공부하고 싶은 생각이 드네요..ㅎ</p>",
		"date": "Jan 06, 2024",
		"writer": "11기 손민기"
	},
	"feed-39": {
		"title": "[c++] 1181번 단어 정렬",
		"link": "https://velog.io/@handmk/c-1181%EB%B2%88-%EB%8B%A8%EC%96%B4-%EC%A0%95%EB%A0%AC",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</p>\n<ol>\n<li>길이가 짧은 것부터</li>\n<li>길이가 같으면 사전 순으로\n단, 중복된 단어는 하나만 남기고 제거해야 한다.</li>\n</ol>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.</p>\n<p><strong>예제 입력</strong></p>\n<pre><code>13\nbut\ni\nwont\nhesitate\nno\nmore\nno\nmore\nit\ncannot\nwait\nim\nyours</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p>조건에 따라 정렬하여 단어들을 출력한다.</p>\n<p><strong>예제 출력</strong></p>\n<pre><code>i\nim\nit\nno\nbut\nmore\nwait\nwont\nyours\ncannot\nhesitate</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nbool Comp(string a, string b){\n    if(a.length() != b.length()){ \n        return a.length() &lt; b.length(); // 길이가 다르면 길이로 오름차순\n    }else{\n        return a&lt;b; // 길이가 같으면 알파벳 순\n    }\n}\n\nint main(){\n    int N,i;\n    string W;\n    vector&lt;string&gt; V;\n\n    cin &gt;&gt; N;\n\n    for(i=0; i&lt;N; i++){\n        cin &gt;&gt; W;\n        V.push_back(W);\n    }\n\n    sort(V.begin(),V.end(),Comp);\n    V.erase(unique(V.begin(), V.end()),V.end()); // 중복 제거\n\n    for(string e : V){\n        cout &lt;&lt; e &lt;&lt; endl;\n    }\n\n    return 0;\n}</code></pre><h4 id=\"😃-알게-된-점\">😃 알게 된 점</h4>\n<blockquote>\n<ol>\n<li>algorithm 라이브러리 unique()는 begin() 부터 end()까지 <strong>연속으로</strong> 중복된 요소를 뒷부분으로 이동시킴. 그리고 중복 요소가 시작되는 쓰레기 인덱스를 반환함. {10,10,20,30,10} -&gt; {10,20,30,10} 이런식으로</li>\n<li>sort(시작, 끝, 비교인자) 가 들어가는데 algorithm 라이브러리 sort()는 내부적으로 동작할 때, 정렬해야 할 요소들을 두 개씩 가져와서 비교인자 함수에 넣어준다고 함..</li>\n</ol>\n</blockquote>",
		"date": "Dec 28, 2023",
		"writer": "11기 손민기"
	},
	"feed-40": {
		"title": "[SpringBoot] Web Socket을 이용한 실시간 주식 데이터",
		"link": "https://velog.io/@handmk/SpringBoot-Web-Socket%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%A3%BC%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0",
		"description": "<h4 id=\"💻-버전-관리\">💻 버전 관리</h4>\n<blockquote>\n<p>2023.12.27\nSpringBoot 2.5.6V\nJDK 11\nMaven</p>\n</blockquote>\n<h3 id=\"🤔-어쩌다-만들게-되었을까\">🤔 어쩌다 만들게 되었을까?</h3>\n<p><strong>모의 주식 거래 웹 서비스</strong> 프로젝트에 참여하면서 서비스 내부의 주식장을 형성해야 하는 역할을 맡았습니다.\n처음에 <strong>RESTFul</strong> 방식으로 <strong>쓰레드를</strong> 엄청 짧게 줘서 하려고 생각 해봤으나 이는 서버에 너무 큰 부하를 줘서 다른 방법을 생각해보다 WebSocket 을 알게되어 이를 통해 구현하였습니다.</p>\n<h3 id=\"websocket-이란\">WebSocket 이란?</h3>\n<p>저희가 자주 사용하는 HTTP 통신 즉, CRUD와 같은 API 는 REST한 API 로 클라이언트에서 서버로 reqeust를 하게 되면 서버에서는 이에 대한 요청이 유효한 지 확인 후 response 줍니다. 그 후에 바로 연결이 끊겨버립니다. 이런식으로 말이죠.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/f4ada180-2796-4159-80de-15eff6b7bd60/image.png\" /></p>\n<p>물론 HTTP 방식으로도 실시간을 유사하게 구현할 수 있습니다.\n<strong>Polling</strong>\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/e03a73f8-02e6-44cb-aac2-e7afe281b895/image.png\" /></p>\n<p>이 방식의 핵심은 클라이언트에서 서버로 주기적으로 '데이터 변경이 있나요?' 요청을 하고 변경(서버 이벤트)이 있다면 해당 데이터를 가져오는 것입니다. 만약 실시간이 아니라 데이터의 업데이트 간격이 길다면? 괜찮습니다.</p>\n<p><strong>Streaming</strong>\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/cc50149d-1473-4a6f-a848-34bb1312713d/image.png\" /></p>\n<p>스트리밍은 영상에서 많이 나오는 단어인데, 이 방법은 클라이언트가 서버로부터 한번에 다 받는 것이 아니라, 데이터를 작은 조각으로 나누어 순차적으로 받는 방식입니다. 입구가 열린 큐에 계속해서 데이터가 새로 들어오는 것이죠.</p>\n<p><strong>WebSocket</strong>\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/09d218a0-eb5b-4738-b7df-a68d8f5071b6/image.png\" /></p>\n<p>웹소켓은 클라이언트가 서버로 연결 Request(이땐, HTTP!) 를 하고 서버에서 유효성 검사 후 승인 하면 세션값이 바뀌지 않는 이상 현재의 세션 그대로 연결이 끊기지 않고 연결됩니다. 연결 된 상태에서는 클라이언트와 서버 간의 양방향 데이터 교류가 가능합니다.</p>\n<h3 id=\"websocket-구현\">WebSocket 구현</h3>\n<h4 id=\"dependency-설정\">Dependency 설정</h4>\n<p><strong>Maven</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p><strong>Gradle</strong></p>\n<pre><code>implementation group: 'org.springframework.boot', name: 'spring-boot-starter-websocket'\n</code></pre><h4 id=\"websockethandler\">WebSocketHandler</h4>\n<p>웹소켓 통신은 서버와 클라이언트가 1:N 관계를 맺습니다. 하나의 서버에 여러 클라이언트가 동시에 접근 할 수 있다는 소리죠. 이런 상황에서 연결이 에러가 나는 경우가 생기는데 이래서 필요한 것이 WebSocketHandler 입니다. \n클라이언트와 서버 간의 연결을 관리하고 데이터를 수신, 전송하는 역할을 합니다.</p>\n<pre><code>package org.springframework.web.socket;\n\npublic interface WebSocketHandler {\n    void afterConnectionEstablished(WebSocketSession session) throws Exception;\n    // 웹소켓 연결이 된 후에 호출\n\n    void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception;\n    // 웹소켓 메세지가 도착하면 호출\n\n    void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;\n    // 웹소켓 메세지 오류 처리\n\n    void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;\n    // 웹소켓 연결이 해제된 후에 호출\n\n    boolean supportsPartialMessages();\n    // 웹소켓 핸들러가 부분 메세지를 처리하는 지 여부\n}\n</code></pre><p>저는 텍스트 데이터를 기반으로 송수신할꺼라 WebSocketHandler 인터페이스를 구현하고 있는 TextWebSocketHandler 를 상속받아 구현하였습니다.</p>\n<p>☕️ <strong>StockWebSocketHandler.java</strong></p>\n<pre><code>@Slf4j\n@Component\npublic class StockWebSocketHandler extends TextWebSocketHandler {\n    private StockWebSocketService stockWebSocketService;\n    private final Map&lt;WebSocketSession, String&gt; sessionStockCodeMap = new ConcurrentHashMap&lt;&gt;();\n\n    @Autowired\n    public StockWebSocketHandler(StockWebSocketService stockWebSocketService){\n        this.stockWebSocketService = stockWebSocketService;\n    }\n    Map&lt;String, WebSocketSession&gt; sessionMap = new HashMap&lt;&gt;(); /*웹소켓 세션을 담아둘 맵*/\n\n    /* 클라이언트로부터 메시지 수신시 동작 */\n    @Override\n    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        String stockCode = message.getPayload(); /*stockCode &lt;- 클라이언트에서 입력한 message*/\n        log.info(&quot;===============Message=================&quot;);\n        log.info(&quot;Received stockCode : {}&quot;, stockCode);\n        log.info(&quot;===============Message=================&quot;);\n        synchronized (sessionMap) {\n            sessionStockCodeMap.put(session, stockCode);\n        }\n    }\n\n    /* 클라이언트가 소켓 연결시 동작 */\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n        log.info(&quot;Web Socket Connected&quot;);\n        log.info(&quot;session id : {}&quot;,session.getId());\n        super.afterConnectionEstablished(session);\n        synchronized (sessionMap) { // 여러 클라이언트의 동시 접근하여 Map의 SessionID가 변경되는 것을 막기위해\n            sessionMap.put(session.getId(), session);\n        }\n        System.out.println(&quot;sessionMap :&quot; + sessionMap.toString());\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(&quot;sessionId&quot;,session.getId());\n\n        session.sendMessage(new TextMessage(jsonObject.toString()));\n    }\n\n    /* 클라이언트가 소켓 종료시 동작 */\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n        log.info(&quot;Web Socket DisConnected&quot;);\n        log.info(&quot;session id : {}&quot;, session.getId());\n        synchronized (sessionMap) { // 여러 클라이언트의 동시 접근하여 Map의 SessionID가 변경되는 것을 막기위해\n            sessionMap.remove(session.getId());\n        }\n        super.afterConnectionClosed(session,status); /*실제로 closed*/\n    }\n\n    @Scheduled(fixedRate = 5000)\n    public void sendStockCode() throws JSONException, IOException {\n        synchronized (sessionMap){\n            for (WebSocketSession session : sessionMap.values()){\n                String stockCode = sessionStockCodeMap.get(session);\n                if(stockCode!=null) {\n                    try { // 주식 데이터를 가져오는 로직이 길어 service 단에 설계\n                        StockPriceResponseDto stockPriceResponseDto = stockWebSocketService.getStock(stockCode);\n                        if (stockPriceResponseDto != null) {\n                            String response = new ObjectMapper().writeValueAsString(stockPriceResponseDto);\n                            log.info(&quot;Sending stock data : {}&quot;, response);\n                            try {\n                                session.sendMessage(new TextMessage(response));\n                                // Message 보내기\n                            }catch (IllegalStateException ex){\n                                log.warn(&quot;Failed to send message, ignoring: {}&quot;,ex.getMessage());\n                            }\n                        } else {\n                            log.warn(&quot;No stock data found for stockCode : {}&quot;, stockCode);\n                        }\n                    } catch (Exception e) {\n                        log.error(&quot;Error while sending stock data : {}&quot;, e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n}\n</code></pre><blockquote>\n<p>여기서의 핵심은 HashMap을 생성하여 웹소켓 연결 접근 시 sessionID 를 Map에 넣어주고 연결 / 해제 시 sessionID가 동시에 접근해오는 클라이언트들에 의해 변경되지 않기 위해 synchronized() 하여 lock을 거는 것입니다.</p>\n</blockquote>\n<h3 id=\"websocketconfig\">WebSocketConfig</h3>\n<p>앞서 봤던 WebSocketHandler 가 데이터를 처리하는 역할이였다고 한다면, WebSocketConfig는 WebSocket의 설정을 담당하는 역할이라고 생각하시면 편해요.\nHandler를 이용해 WebSocket을 활성화 하기 위해 WebSocketConfigurer 인터페이스를 구현하여 만들었습니다.</p>\n<pre><code>@Configuration\n@EnableWebSocket // 웹소켓 활성화 어노테이션\npublic class StockWebSocketConfig implements WebSocketConfigurer {\n    private final StockWebSocketHandler stockWebSocketHandler;\n    @Autowired\n    public StockWebSocketConfig(StockWebSocketHandler stockWebSocketHandler) {\n        this.stockWebSocketHandler = stockWebSocketHandler;\n    }\n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry){\n        /*webSocketHandler 를 추가*/\n        registry.addHandler(stockWebSocketHandler, &quot;/stock&quot;).setAllowedOrigins(&quot;*&quot;); // endpoint 설정과 CORS 설정(*)\n    }\n}</code></pre><h3 id=\"✏️-test\">✏️ Test</h3>\n<p>저는 포스트맨을 사용하여 WebSocket을 테스트 하였고, 테스트 시 WebSocket 프로토콜을 사용하여 테스트 하셔야 합니다!(기껏 만들어 놓고 삽질해서.....ㅎ)\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/dea80eca-b21c-49cd-b838-eedfe13c46a0/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/4615b217-1c43-4d3a-b56f-0e5fd5945234/image.png\" /></p>\n<p>영롱하다...\n<img alt=\"업로드중..\" src=\"blob:https://velog.io/cf69b922-47dc-401d-94a1-d8b44d59ef1f\" /></p>",
		"date": "Dec 27, 2023",
		"writer": "11기 손민기"
	},
	"feed-55": {
		"title": "nGrinder 성능 테스트 #2 - 'Performance Test' 설정 속성 알아보기",
		"link": "https://velog.io/@yunh03/nGrinder-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-2-Performance-Test-%EC%84%A4%EC%A0%95-%EC%86%8D%EC%84%B1-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0",
		"description": "<h3 id=\"시작하기\">시작하기</h3>\n<p><a href=\"https://velog.io/@yunh03/nGrinder-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-1-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\">nGrinder 성능 테스트 #1</a>에 이어, 이 글에서는 nGrinder 컨트롤러에서 Performance Test 기능의 설정에 대한 속성에 대해 알아보려고 한다. nGrinder 테스트를 실행하는 Script 작성에 관해서는 이 다음 글인 로컬 테스트 진행 때 다루려 하기에 이 글에는 추가하지 않았다.</p>\n<h3 id=\"performance-test-설정-속성-알아보기\">Performance Test 설정 속성 알아보기</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/df17474d-3ab6-4064-91dd-abbc1e85ae23/image.png\" />\nnGrinder Controller(<a href=\"http://localhost:8300/)%EC%97%90%EC%84%9C\">http://localhost:8300/)에서</a> 상단에 위치한 헤더 메뉴에서 <code>Performance Test</code> 메뉴를 눌러보면 위 사진과 같은 화면이 표시된다. 가이드라인 대로라면 Script를 작성하고, Test 설정을 해야하지만, Script가 없어도 설정 화면 접근 자체는 가능하기에 Test를 생성해 보겠다. 우측 메뉴에서 <code>Create Test</code> 버튼을 클릭하여 새로운 테스트를 생성해 준다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/afa58bc0-df42-4a48-9001-acb0705b5f4e/image.png\" />\n그러면 위와 같은 새로운 테스트를 생성할 수 있는 화면이 표시된다. 나눠져 있는 섹션 별로 메뉴를 자세히 알아보도록 하겠다.</p>\n<h3 id=\"테스트-기본-정보-설정\">테스트 기본 정보 설정</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/29865af4-e891-4f2b-9740-f5739a8faf18/image.png\" />\n<strong>테스트 기본 정보</strong>를 설정하는 섹션이다.</p>\n<ul>\n<li><strong>Test Name</strong>: 테스트 구분을 위한 이름 설정</li>\n<li><strong>Tags</strong>: 테스트 태그 설정 (추후 쉬운 구분을 위한 태그 설정이 있는 것으로 보임)</li>\n<li><strong>Description</strong>: 테스트 설명 입력</li>\n</ul>\n<h3 id=\"basic-configuration\">Basic Configuration</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/ada23158-5cca-43ec-84a2-c40d48170aac/image.png\" /></p>\n<p><code>Basic Configuration</code>의 설정이 nGrinder의 가장 핵심이라고 생각한다. 성능 테스트를 하는 이유가 <code>동시 접속이 이루어 졌을 때 얼마 만큼의 성능을 낼 수 있는지</code> 테스트 하는 것인데, 이 부분에서 가상의 유저(동시 접속을 요청하는 사용자)를 설정할 수 있기 때문이다.</p>\n<ul>\n<li><p><strong>Agent</strong>: 성능 측정에 사용할 Agent 개수\n→ Agent는 컨트롤러의 명령을 받아 실행한다.</p>\n</li>\n<li><p><strong>Vuser per agent</strong>: Agent 당 설정할 가상 사용자 수\n→ 동시에 API 요청을 하는 (가상) 사용자 수</p>\n</li>\n<li><p><strong>Processes, Threads</strong>: 하나의 Agent에서 생성할 Proccess와 Thread 개수\n→ 입력해 보면 쉽게 알 수 있겠지만, <code>Processess * Threads * Agent</code>가 <code>Vuser per agent</code>의 값이 된다.</p>\n</li>\n<li><p><strong>Script</strong>: 테스트 실행 시 사용할 Script 선택</p>\n</li>\n</ul>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/ea968162-a795-4bea-b199-e9bd3e6ef65a/image.png\" /></p>\n<ul>\n<li><p><strong>Duration</strong>: 테스트를 진행할 시간</p>\n</li>\n<li><p><strong>Run Count</strong>: Thread 당 테스트 코드를 수행하는 횟수</p>\n</li>\n</ul>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/419c1360-9200-421d-8d7b-d35e5e4d88a1/image.png\" /></p>\n<ul>\n<li><p><strong>Enable Ramp-Up</strong>: 테스트 진행 시 가상 사용자(Vuser)을 점진적으로 증가</p>\n</li>\n<li><p><strong>Initial Count</strong>: 처음 시작 가상 사용자(Vuser) 수</p>\n</li>\n<li><p><strong>Initial Sleep Time</strong>: 테스트 시작 시간(ms 단위)</p>\n</li>\n<li><p><strong>Incremental Step</strong>:  Process 또는 Thread를 증가시키는 개수</p>\n</li>\n<li><p><strong>Interval</strong>: Process 또는 Thread를 증가시키는 시간 간격</p>\n</li>\n</ul>\n<h3 id=\"주의해야-할-점\">주의해야 할 점</h3>\n<p>부하 테스트를 진행하게 되면 많은 API 요청을 보내게 된다. 이 때, Amazon RDS나 Amazon S3 같은 외부 서비스를 함께 사용하는 API(과금이 발생되는)를 호출 시, 과금이 발생하기 때문에 이에 대한 예측과 충분한 판단 하에 테스트를 진행해야 한다.</p>",
		"date": "Dec 27, 2023",
		"writer": "11기 전윤환"
	},
	"feed-41": {
		"title": "[c++] 2609번 최대공약수와 최소공배수",
		"link": "https://velog.io/@handmk/c-2609%EB%B2%88-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p>두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.</p>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.</p>\n<p><strong>예제 입력 1</strong></p>\n<pre><code>24 18</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p>첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.</p>\n<p><strong>예제 출력 1</strong></p>\n<pre><code>6\n72</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n    int N;\n    int M;\n    int minNum;\n    int greatestCommonDivisor;\n    int leastCommonMultiple; // 변수 선언\n\n    cin &gt;&gt; N;\n    cin &gt;&gt; M; // 입력\n\n    minNum = min(N,M);\n\n    for(int i=1; i&lt;=minNum; i++){\n        if((N % i == 0) &amp;&amp; (M % i == 0)){\n            greatestCommonDivisor = i; // 최대공약수\n        }\n    }\n\n    leastCommonMultiple = (N * M) / greatestCommonDivisor; // 최소공배수 = 두수의 곱 / 최대공약수\n\n    cout &lt;&lt; greatestCommonDivisor &lt;&lt; endl &lt;&lt; leastCommonMultiple &lt;&lt; endl;\n\n    return 0;\n}</code></pre>",
		"date": "Dec 26, 2023",
		"writer": "11기 손민기"
	},
	"feed-56": {
		"title": "nGrinder 성능 테스트 #1 - 시작하기",
		"link": "https://velog.io/@yunh03/nGrinder-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-1-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0",
		"description": "<h3 id=\"ngrinder란\">nGrinder란?</h3>\n<p>nGrinder는 네이버에서 제공하는 서버 부하 테스트 프로그램이며, 오픈 소스 프로젝트이다. 애플리케이션을 개발하고 발생할 수 있는 가상 시나리오를 만들어 사용자가 급증하여 트래픽에 몰렸을 때 하드웨어에서 요청을 처리하는 성능을 측정할 수 있도록 도와준다.</p>\n<h3 id=\"ngrinder-구조\">nGrinder 구조</h3>\n<ul>\n<li>Controller : 테스트를 위한 스크립트를 생성할 수 있고 이 스크립트를 실행하고 성능을 측정할 수 있는 웹 인터페이스를 제공하며 테스트 결과를 수집해 통계를 보여준다.</li>\n<li>Agent : 컨트롤러의 명령을 받아 작업을 수행하며 프로세스 및 스레드를 실행시켜 테스트 타겟이 되는 애플리케이션에 부하를 발생시킨다.</li>\n</ul>\n<h3 id=\"설치하기-controller\">설치하기: Controller</h3>\n<p>nGrinder는 <a href=\"https://naver.github.io/ngrinder/\">공식 홈페이지</a>에서 다운로드 받을 수 있다. 공식 홈페이지에 접속할 수 없다면 <a href=\"https://github.com/naver/ngrinder/releases\">깃허브 레포지토리</a>에서 직접 다운로드 받는 방법도 존재한다. 2023년 12월 8일 기준, 최신 버전은 3.5.8 버전이다.</p>\n<p>다운로드 한 파일은 원활한 사용을 위해 따로 폴더 안에 저장하여 사용하는 것을 권장한다.</p>\n<pre><code>java -jar ngrinder-controller-3.5.8.war --port=8300</code></pre><p>만약 3.5.8 버전의 nGrinder를 다운로드 받았다면, <code>ngrinder-controller-3.5.8.war</code> 파일을 다운로드 받았을 것이다. 이 컨트롤러를 실행하는 명령어는 다음과 같다. 사용을 희망하는 포트가 있다면 <code>--port=8300</code> 부분을 수정하여 실행해 주면 된다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/71add99a-2a9e-4637-b375-25ba1edd9f4f/image.png\" /></p>\n<p><code>StartupInfoLogger.java:61 : Started NGrinderControllerStarter in 14.488 seconds (JVM running for 16.04)</code> 라는 문구가 맨 마지막으로 표시되고, 실행이 멈췄다면 nGrinder 컨트롤러 실행이 완료된 것이다. 그러면, 브라우저에서 <a href=\"http://localhost:8300\">http://localhost:8300</a> 에 접근하면 아래와 같은 화면이 표시된다. <strong>만약 실행이 정상적으로 완료되지 않는다면, 글 맨 아래 ‘설치 중 발생한 에러 및 해결 과정’을 확인해 보는 것을 추천한다.</strong></p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/825224fa-e2af-4214-bd63-f3c6c235b4ee/image.png\" /></p>\n<p>아이디와 비밀번호는 모두 <code>admin</code> 으로 동일하다. 이제 nGrinder 설치가 모두 완료되었으니, Agent를 설치해 주면 된다.</p>\n<h3 id=\"설치하기-agent\">설치하기: Agent</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/c9d925fe-6bb5-407e-ab1b-6e3ade028348/image.png\" />\nnGrinder Agent는 위 단계에서 진행한 Controller에서 다운로드 받을 수 있다. 우측 상단에 <code>admin</code> 계정의 드롭다운 메뉴를 클릭한 후 <code>Download Agent</code> 버튼을 클릭하면 즉시 다운로드가 완료된다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/6be78520-d3a4-4e96-bee9-d6e7da920327/image.png\" />\n그 후, 다운로드가 완료된 <code>.tar</code> 파일의 압축을 위 사진과 같이 해제하여 준다. 우리는 <code>run_agent.sh</code> 파일을 실행해 주어야 한다. 위 단계에서 진행한 Controller의 터미널을 닫거나 실행을 중지하지 않고, 새 터미널을 열어 sh 파일을 실행한다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/8a60fe41-70e7-4e9b-9d7d-8d17ca35127d/image.png\" /></p>\n<pre><code>cd /Users/yunhwan/Desktop/develop/ngrinder-agent\nsh run_agent.sh</code></pre><p>위 명령어와 같이, <code>ngrinder-agent</code> 폴더의 위치를 <code>cd</code> 명령어를 이용하여 마운트 후, 그 다음 명령어인 <code>sh run_agent.sh</code> 명령어를 실행하면 위 사진과 같이 Agent가 실행된다. 필자가 Agent를 실행할 때 특이한 에러가 발생하지 않았기에 아래 <code>설치 중 발생한 에러 및 해결 과정</code>에는 추가하지 않았다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/998607a7-a54d-4d47-9834-e11537a3b1ce/image.png\" />\nAgent를 다운로드하고, 실행까지의 과정을 마쳤다면 웹 브라우저로 돌아와서 Agent가 잘 실행되었는지 확인할 수 있다. 우측 상단의 <code>admin</code> 드롭다운 메뉴를 클릭한 후, <code>Agent Management</code> 메뉴를 클릭한다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/062de734-6dfc-4f84-baab-bb0e2006e154/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/b69e9fa5-7e86-4661-a0c4-c7b33b7bcb71/image.png\" />\n방금 실행한 Agent가 잘 실행되고 있음을 <code>Status</code> 칸에서 확인할 수 있고, 로컬에서 실행되고 있기에 <code>IP | Domain</code>란에 내부 아이피가 표시됨을 확인할 수 있다. 아이피 부분을 눌러보면 CPU 사용량이나 RAM 사용량을 확인할 수도 있다. 이렇게 잘 확인된다면 Agent가 잘 설치된 것이다.</p>\n<h3 id=\"설치-중-발생한-에러-및-해결-과정\">설치 중 발생한 에러 및 해결 과정</h3>\n<pre><code>!!! ERROR\nPlease set `java.io.tmpdir` property like following. tmpdir should be different from the OS default tmpdir.\n`java -Djava.io.tmpdir=${NGRINDER_HOME}/lib -jar ngrinder-controller.war`</code></pre><p>nGrinder 실행 시 필요한 임시 파일의 저장 경로를 명시하지 않아서 나는 에러이다. 따라서 실행 시 아래와 같이 임시 파일을 생성할 위치를 명시해주면 된다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/ad7c140e-6665-4bdc-8b84-c195262c8ec9/image.png\" /></p>\n<p>해결을 위해 임시 파일을 저장할 수 있는 <code>temp</code> 폴더를 만들어 주었고, 최종적인 경로는 <code>/Users/yunhwan/Desktop/develop/temp</code> 이다. 이 경로를 이용하여 수정된 명령어는 아래와 같다.</p>\n<pre><code>java -Djava.io.tmpdir=/Users/yunhwan/Desktop/develop/temp -jar ngrinder-controller-3.5.8.war --port=8300</code></pre><h3 id=\"마무리\">마무리</h3>\n<p>이렇게 nGrinder Controller와 Agent 설치까지 마무리되었다. 아마 다음 글에서는 간단한 RESTful API를 Spring Boot를 활용하여 제작한 후, 맥북에서의 API 성능을 간단하게 테스트해볼 것 같고, 그 다음으로는 AWS 서버에서의 실제 테스트를 할 것으로 예상된다.</p>",
		"date": "Dec 24, 2023",
		"writer": "11기 전윤환"
	},
	"feed-42": {
		"title": "[c++] 1546번 평균",
		"link": "https://velog.io/@handmk/c-1546%EB%B2%88-%ED%8F%89%EA%B7%A0",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p>세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.</p>\n<p>예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.</p>\n<p>세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.</p>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.</p>\n<p><strong>예제 입력</strong></p>\n<pre><code>3\n40 80 60</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p>첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.</p>\n<p><strong>예제 출력</strong></p>\n<pre><code>75.0</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint checkMaxNum(const vector&lt;int&gt;&amp; V){ \n    int M = V[0];\n\n    for(int i=1; i&lt;V.size(); i++){\n        M = max(M,V[i]); // algorithm 라이브러리 max() 사용\n    }\n    return M;\n}\n\nfloat avg(const vector&lt;int&gt;&amp; V){ // const 참조로 변경 없이 매개 변수 전달\n    int M = checkMaxNum(V);\n    float total=0;\n\n    for(int e : V){\n        total += (float)e/M*100;\n    }\n    return total / V.size();\n}\n\nint main(){\n    int N;\n    int i;\n    int Num; // 변수 선언\n    cin &gt;&gt; N;\n    vector&lt;int&gt; V; // 벡터 선언\n\n    for(i=0; i&lt;N; i++){ // 벡터에 입력\n        cin &gt;&gt; Num;\n        V.push_back(Num);\n    }\n\n    float rst = avg(V); // 평균 구하기\n    cout &lt;&lt; rst;\n    return 0;\n}</code></pre>",
		"date": "Dec 22, 2023",
		"writer": "11기 손민기"
	},
	"feed-43": {
		"title": "[c++] 1259번 팰린드롬수",
		"link": "https://velog.io/@handmk/c-1259%EB%B2%88-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC%EC%88%98",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p>어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.</p>\n<p>수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.</p>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.</p>\n<p><strong>예제 입력 1</strong></p>\n<pre><code>121\n1231\n12421\n0</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p><strong>예제 출력 1</strong></p>\n<pre><code>yes\nno\nyes</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main(){ // 문자열로 입력받아 algorithm 라이브러리의 reverse 함수와 string 의 compare 함수로 역순 비교하여 문제 해결\n    string N;\n    vector&lt;string&gt; V;\n    string M;\n\n    while(true){\n        cin &gt;&gt; N;\n        if(N == &quot;0&quot;){ // 0 입력 받기 전까지 반복\n            break;\n        }else{\n            V.push_back(N); // 벡터에 push\n        }\n    }\n\n    for(auto e : V){\n        M = e; // M 에 복사\n        reverse(M.begin(),M.end()); // M reverse\n        if(!e.compare(M)){ // string.compare 시 동일한 문자열일때 return 0;, 다른 문자열일 때 return 1; 이기에 !\n            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;\n        }else{\n            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\n        }\n    }\n\n    return 0;\n}\n</code></pre>",
		"date": "Dec 21, 2023",
		"writer": "11기 손민기"
	},
	"feed-44": {
		"title": "[c++] 1978번 소수찾기",
		"link": "https://velog.io/@handmk/c-1978%EB%B2%88-%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p>주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.</p>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.</p>\n<p><strong>예제 입력 1</strong></p>\n<pre><code>4\n1 3 5 7</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p>주어진 수들 중 소수의 개수를 출력한다.</p>\n<p><strong>예제 출력 1</strong></p>\n<pre><code>3</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main(){\n    int n;\n    int i;\n    int j;\n    int num;\n    int cnt=0;\n    int rst=0;\n    cin &gt;&gt; n; // 입력\n\n    int ary[n];\n\n    for(i=0;i&lt;n;i++){ // 배열 생성\n        cin &gt;&gt; ary[i];\n    }\n\n    for(i=0; i&lt;n; i++){\n        num = ary[i];\n        cnt = 0;\n\n        for(j=1; j&lt;=num; j++){ // 소수 검정\n            if(num % j == 0){\n                 cnt += 1;\n            }\n        }\n         if(cnt == 2){ // 소수 시 rst = rst + 1\n            rst += 1;\n        }\n    }\n    cout &lt;&lt; rst &lt;&lt; endl;\n    return 0;\n}</code></pre>",
		"date": "Dec 20, 2023",
		"writer": "11기 손민기"
	},
	"feed-45": {
		"title": "[c++] 2798번 블랙잭",
		"link": "https://velog.io/@handmk/c-2798%EB%B2%88-%EB%B8%94%EB%9E%99%EC%9E%AD-qoge3jbx",
		"description": "<h3 id=\"📕-문제\">📕 문제</h3>\n<p> 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 다양한 규정이 있다.</p>\n<p>한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.</p>\n<p>김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.</p>\n<p>이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.</p>\n<p>N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.</p>\n<h3 id=\"📗-입력\">📗 입력</h3>\n<p>첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.</p>\n<p>합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.\n<strong>예제 입력 1</strong></p>\n<pre><code>5 21\n5 6 7 8 9</code></pre><p><strong>예제 입력 2</strong></p>\n<pre><code>10 500\n93 181 245 214 315 36 185 138 216 295</code></pre><h3 id=\"📙-출력\">📙 출력</h3>\n<p>첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.</p>\n<p><strong>예제 출력 1</strong></p>\n<pre><code>21</code></pre><p><strong>예제 출력 2</strong></p>\n<pre><code>497</code></pre><h3 id=\"⭐️-정답-풀이\">⭐️ 정답 풀이</h3>\n<pre><code>int main(){\n    int N;\n    int M;\n    int i;\n    int j;\n    int k;\n    int num;\n    int total = 0; // 변수 선언\n\n    cin &gt;&gt; N;\n    cin &gt;&gt; M;\n    int ary[N+1];\n\n    for (i = 0; i&lt;N; i++){\n        cin &gt;&gt; ary[i]; // ary 배열에 카드 숫자 입력\n    }\n\n    for(i=0; i&lt;N; i++){ // 브루트포스 알고리즘으로 total 값을 M을 초과하지 않는 근사치의 세 수의 합으로 변경\n        for(j=i+1; j&lt;N; j++){\n            for(k=j+1; k&lt;N; k++){\n                if((total &lt; ary[i] + ary[j] + ary[k]) &amp;&amp; (ary[i] + ary[j] + ary[k] &lt;= M)){\n                    total = ary[i] + ary[j] + ary[k];\n                }else{\n                    continue;\n                }\n            }\n        }\n    }\n    cout &lt;&lt; total; // total 출력\n    return 0;\n}</code></pre>",
		"date": "Dec 20, 2023",
		"writer": "11기 손민기"
	},
	"feed-46": {
		"title": "[SpringBoot]  메일인증 회원가입 구현",
		"link": "https://velog.io/@handmk/Springboot-%EB%A9%94%EC%9D%BC%EC%9D%B8%EC%A6%9D-%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-%EA%B5%AC%ED%98%84",
		"description": "<p>🤔 <strong>준비물</strong></p>\n<blockquote>\n<p> Google 계정\nGmail SMTP 설정</p>\n</blockquote>\n<p>💻 <strong>버전 관리</strong></p>\n<blockquote>\n<p>2023 . 11. 27 일 기준\nSpring Boot 2.5.6 V\nJDK 11\nMaven\n실제로 실무에서는 다른 메일 서버를 사용하겠지만<em>(Gmail은 일일 2000개로 한정이기 때문)</em>, 학부생 입장에서 ToyProject 진행 시 인증번호 인증 후 회원가입에 필요한 Gmail SMTP 설정에 대한 내용이에요.</p>\n</blockquote>\n<h3 id=\"1-smtp란\">1. SMTP란?</h3>\n<p>SMTP(Simple Mail Transfer Protocal)은 인터넷을 통해 이메일을 보내고 받는데 사용되는 통신 프로토콜이에요. \n25/TCP 또는 587/TCP를 사용합니다.</p>\n<h3 id=\"2-smtps란\">2. SMTPS란?</h3>\n<p>SMTPS는 SMTP에 SSL(보안 소켓 계층) 또는 TLS(전송 계층 보안)와 같은 암호화 프로토콜을 사용해서 메일내용을 암호화 하여 전송하는 거에요. \n465/TCP를 사용합니다!</p>\n<p>이러한 이유로 SMTP보다는 SMTPS 프로토콜을 사용하는 것이 기밀성과 무결성을 보장하고 일반적으로 사용해요 😃</p>\n<h3 id=\"3-전반적인-flow\">3. 전반적인 FLOW</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/3b6ea086-ced0-4921-b502-844cdb02a37d/image.png\" /></p>\n<p>1) 클라이언트에서 SpringBoot 서버로 POST 메서드로 본인 email을 전송</p>\n<p>2) SpringBoot 서버에서 송신 이메일 : {}, 수신 이메일 : {}, 내용 Body 값 : {}, 인증번호(6자리 난수) : {} 를 세팅</p>\n<p>3) 2)에서 세팅한 내용을 갖고 Gmail SMTP 465/TCP를 이용하여 수신 이메일로 메일 내용 전송</p>\n<p>4) if 다시 클라이언트에서 입력한 인증번호 내용이 서버에서 가지고 있는 인증번호와 일치하면? 회원가입 성공\nelse 회원가입 실패</p>\n<h3 id=\"4-사용할-google-계정-선택-또는-생성\">4. 사용할 Google 계정 선택 또는 생성</h3>\n<p>Gmail SMTP를 사용하려면 Google 계정이 필요해요!\n또한, 일반적인 경우 인증번호는 사용자가 송신자에게 추가적인 메일을 보낼 일이 없겠죠?\n이러한 이유로 no-reply 또는 noreply @ domain 으로 계정을 생성하는게 일반적입니다!\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/cd498a8f-087a-4cf8-a2f8-797321918bb6/image.png\" /></p>\n<p>이런식으로 말이죠.🤓</p>\n<p>만약 새로 구글 계정을 생성해야 한다면?\n<a href=\"https://support.google.com/mail/answer/56256?hl=ko\">Google 계정 새로 생성!</a> 이 내용을 참고하세요.</p>\n<p>구글 계정을 선택했다면 SMTP 설정을 할 수 있어요!</p>\n<h3 id=\"5-gmail-smtp-설정\">5. Gmail SMTP 설정</h3>\n<ol>\n<li><p>Gmail 페이지로 이동 후 오른쪽 상단 톱니바퀴 클릭\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/245df4ac-018a-424e-b29a-55544095c5bd/image.png\" /></p>\n</li>\n<li><p>모든 설정 보기 클릭\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/dda7b882-822a-45df-976b-1fa6f4577936/image.png\" /></p>\n</li>\n<li><p>[전달 및 POP/IMAP]탭 -&gt; IMAP 액세스 사용 체크 -&gt; 저장\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/9224ab87-d4c3-4ec5-a656-65eb7e4dc437/image.png\" /></p>\n<blockquote>\n<p>POP vs IMAP\nPOP -&gt; 메일 서버에서 메일을 받아오는 프로토콜 중 하나로, 메일이 PC 로컬 저장소에 저장됩니다. 즉, 로컬 PC 저장소에 저장된 후에 메일 서버에선 사라집니다.(메일 서버의 용량이 적을 때)\nIMAP -&gt; 동일하게 메일을 받아오는 프로토콜이지만, 메일 서버와 동기화가 이뤄지기 때문에 모든 장치에서 동일한 이메일을 확인 할 수 있습니다.(메일 서버의 용량이 많을 때)</p>\n</blockquote>\n</li>\n<li><p>Google 계정 보안 설정 페이지로 이동\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/8b07894b-59d4-4c0c-8076-fd9de3d9387a/image.png\" /></p>\n</li>\n<li><p>왼쪽 보안 탭 -&gt; 2단계 인증을 해줍니다. (저는 이거 쓰느라고 중지 한거에요 🥲)\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/a7e99abc-d217-4ccb-a17b-a3378f5af336/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/03316ba0-554e-4d74-84a0-b1b73b4ea4a2/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/e7660ee0-a458-4669-b359-aa5fc238994d/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/27efae40-a35c-4f8b-9392-395b2c5bc9f8/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/e419a9f2-f40f-4e97-be22-dea0b2258475/image.png\" />\n각 단계를 거치면?\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/e0ad0d00-3f52-4b38-9a26-906c4cacc5c4/image.png\" />\n다시 인증 페이지로 들어가준다.</p>\n</li>\n<li><p>앱 비밀번호 발급\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/e55ad251-0efb-41cd-bd6e-177290b4e97e/image.png\" /></p>\n</li>\n<li><p>사용 용도에 적당한 이름으로 작성 후 만들기\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/731f2536-496f-4ec9-9f85-f158a0ead786/image.png\" />\n<img alt=\"\" src=\"https://velog.velcdn.com/images/handmk/post/462ba6da-ae3d-4b3d-a324-60be256d0822/image.png\" />\n앱 비밀번호가 생성됐습니다! <strong>(비밀번호는 다시 볼 수 없으니 메모장에 적어두어야 합니다‼️)</strong></p>\n</li>\n</ol>\n<h3 id=\"6-dependency-또는-yml-설정\">6. dependency 또는 yml 설정</h3>\n<p>저는 Spring-Boot-Starter-Mail을 사용하였습니다.\n<strong>maven</strong></p>\n<pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\n        &lt;/dependency&gt;</code></pre><p><strong>gradle</strong></p>\n<pre><code>implementation group: 'org.springframework.boot', name: 'spring-boot-starter-mail'\n</code></pre><h3 id=\"7-applicationproperties-설정\">7. application.properties 설정</h3>\n<pre><code># SMTP port setting(필수)\nspring.mail.host=smtp.gmail.com\nspring.mail.port=465\nspring.mail.username= 송신자 이메일\nspring.mail.password= 앱 비밀번호\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.protocol=smtps\n\n# SMTP sending time setting(timeou과 관련된 세팅으로 필수적이지 않음)\nspring.mail.properties.mail.smtp.timeout=20000\nspring.mail.properties.mail.smtp.connectiontimeout=20000\nspring.mail.properties.mail.smtp.writetimeout=20000</code></pre><ul>\n<li>spring.mail.protocol=smtps : SMTP 프로토콜을 사용하겠다. 라는 내용입니다.</li>\n<li>spring.mail.properties.mail.smtp.auth = true : SMTP 인증을 사용하도록 지시하는 내용입니다.</li>\n</ul>\n<p>밑에 timeout 관련 세팅은 메일 내용과 서버의 속도에 따라 입맛에 맞추어 사용하시면 좋아요!😃\n저 같은 경우는 mail의 body 값이 생각보다 무거워서 TimeException이 발생해서 2초로 여유 간격을 주었습니다 :)</p>\n<h3 id=\"8-mailservicejava-구현\">8. MailService.java 구현</h3>\n<ol>\n<li>인증번호 생성<pre><code>private static String number;\n</code></pre></li>\n</ol>\n<p>public static void createNumber(){\n        Random random = new Random();\n        StringBuffer key = new StringBuffer();</p>\n<pre><code>    for(int i=0; i&lt;8; i++) { // 총 8자리 인증 번호 생성      \n        int idx = random.nextInt(3); // 0~2 사이의 값을 랜덤하게 받아와 idx에 집어넣습니다\n\n        // 0,1,2 값을 switchcase를 통해 꼬아버립니다.\n        // 숫자와 ASCII 코드를 이용합니다.\n        switch (idx) {\n            case 0 :\n                // 0일 때, a~z 까지 랜덤 생성 후 key에 추가\n                key.append((char) (random.nextInt(26) + 97));\n                break;\n            case 1:\n                // 1일 때, A~Z 까지 랜덤 생성 후 key에 추가\n                key.append((char) (random.nextInt(26) + 65));\n                break;\n            case 2:\n                // 2일 때, 0~9 까지 랜덤 생성 후 key에 추가\n                key.append(random.nextInt(9));\n                break;\n        }\n    }\n    number = key.toString();\n}</code></pre><pre><code>\n2. 메일 생성\nSpring Boot에서 제공하는 메일 인터페이스들을 이용해 구현을 하였는데요,\n&gt; - MailSender : 이메일을 보내는데 사용되는 클래스들의 최상위 클래스\n&gt; - JavaMailSender : MailSender의 하위 인터페이스이고, MIME 메세지(우리가 생각하는 메일 내용)를 생성하고 보낼 수 있습니다.\n&gt; - MimeMessageHelper : MIME 메세지를 생성을 위해 사용되는 클래스인데, Helper를 사용하면, 이미지파일, 텍스트, 파일 등 html 형식으로 작성할 수 있습니다.\n</code></pre><p>public MimeMessage createMessage(String email){\n        createNumber();\n        log.info(&quot;Number : {}&quot;,number);\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage(); \n        try{\n            MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage, true); // Helper 사용\n            messageHelper.setFrom(senderEmail);\n            messageHelper.setTo(email);\n            messageHelper.setSubject(&quot;[Challengers] 이메일 인증 번호 발송&quot;);</p>\n<pre><code>        String body = &quot;&lt;html&gt;&lt;body style='background-color: #000000 !important; margin: 0 auto; max-width: 600px; word-break: break-all; padding-top: 50px; color: #ffffff;'&gt;&quot;;\n        body += &quot;&lt;img class='logo' src='cid:image'&gt;&quot;;\n        body += &quot;&lt;h1 style='padding-top: 50px; font-size: 30px;'&gt;이메일 주소 인증&lt;/h1&gt;&quot;;\n        body += &quot;&lt;p style='padding-top: 20px; font-size: 18px; opacity: 0.6; line-height: 30px; font-weight: 400;'&gt;안녕하세요? Challengers 관리자 입니다.&lt;br /&gt;&quot;;\n        body += &quot;Challengers 서비스 사용을 위해 회원가입시 고객님께서 입력하신 이메일 주소의 인증이 필요합니다.&lt;br /&gt;&quot;;\n        body += &quot;하단의 인증 번호로 이메일 인증을 완료하시면, 정상적으로 Challengers 서비스를 이용하실 수 있습니다.&lt;br /&gt;&quot;;\n        body += &quot;항상 최선의 노력을 다하는 Challengers가 되겠습니다.&lt;br /&gt;&quot;;\n        body += &quot;감사합니다.&lt;/p&gt;&quot;;\n        body += &quot;&lt;div class='code-box' style='margin-top: 50px; padding-top: 20px; color: #000000; padding-bottom: 20px; font-size: 25px; text-align: center; background-color: #f4f4f4; border-radius: 10px;'&gt;&quot; + number + &quot;&lt;/div&gt;&quot;;\n        body += &quot;&lt;/body&gt;&lt;/html&gt;&quot;;\n        messageHelper.setText(body, true);\n        ClassPathResource image = new ClassPathResource(&quot;img/challengers.png&quot;);\n        messageHelper.addInline(&quot;image&quot;, image);\n    }catch (MessagingException e){\n        e.printStackTrace();\n    }\n    return mimeMessage;\n}</code></pre><pre><code>\n\n3. MimeMessage 를 통해 메일 전송</code></pre><p>public String sendMail(String email) {\n        MimeMessage mimeMessage = createMessage(email);\n        log.info(&quot;[Mail 전송 시작]&quot;);\n        javaMailSender.send(mimeMessage);\n        log.info(&quot;[Mail 전송 완료]&quot;);\n        return number;\n    }</p>\n<pre><code>\n### 9. Controller 구현</code></pre><p>@PostMapping(value = &quot;/request-sign-up&quot;)\n    public ResponseEntity&lt;?&gt; requestSignUp(@RequestBody SignUpRequestDto signUpRequestDto){\n        return ResponseEntity.ok(signService.sendCode(signUpRequestDto));\n    }</p>\n<pre><code>\n### 10. 결과\n![](https://velog.velcdn.com/images/handmk/post/ec3535de-3670-4fe7-acfb-5b60a2cff3fb/image.png)\n\n\n![](https://velog.velcdn.com/images/handmk/post/b2b8b668-92f6-4924-9598-7b1c9a676ae7/image.png)\n\n성공!✌️\n\n\n\n\n</code></pre>",
		"date": "Nov 27, 2023",
		"writer": "11기 손민기"
	},
	"feed-57": {
		"title": "[AWS] RDS에서 외부 접속이 되지 않을 때 (Connection timed out)",
		"link": "https://velog.io/@yunh03/AWS-RDS%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EC%A0%91%EC%86%8D%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C-Connection-timed-out",
		"description": "<p>AWS에서 예전에 한 번 RDS를 사용해서 데이터베이스를 구축해 본 경험이 있었는데, 꽤 오래 전이였고 지금의 AWS는 너무 많이 업데이트가 진행되었다. 이번에 RDS를 다룰 일이 있어서 MariaDB 데이터베이스를 생성했는데, 외부 접속 연결이나 인바운드 설정을 모두 했음에도 불구하고 외부에서 연결이 되지 않아 애를 먹었다..</p>\n<h3 id=\"외부-접속을-위해-확인해-본-것들\">외부 접속을 위해 확인해 본 것들</h3>\n<p>외부 접속을 위해 아래 2가지를 먼저 확인해 보았다.</p>\n<ol>\n<li>Inbound(인바운드) 규칙 확인</li>\n<li>퍼블릭 엑세스 설정 확인<h4 id=\"inbound인바운드-규칙-확인\">Inbound(인바운드) 규칙 확인</h4>\n기본적으로 RDS에서 보안 규칙에 대해 아무것도 설정하지 않았다면, 내부에서 데이터베이스를 접근하는 것만 허용되어 있고, 외부에서 3306 포트로 요청에 대한 규칙은 허용되어 있지 않다. 외부에서 접속하려면, Inbound 규칙을 추가해 주어야 한다.</li>\n</ol>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/9c649a31-075b-4643-ae19-03b82c9ff766/image.png\" />\n<code>네트워크 및 보안 - 보안 그룹</code>에서 RDS에 할당되어 있는 보안 그룹을 찾는다. RDS에 할당되어 있는 보안 그룹을 클릭하면 위 페이지로 바로 이동할 수 있다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/5cfb1f3a-6f2d-47fa-95b7-da08eae320af/image.png\" />\n그리고 아래에 내려보면, <code>인바운드 규칙</code> 메뉴가 있고, 우측에 <code>인바운드 규칙 편집</code> 메뉴가 보이는데, 클릭해 준다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/953abb88-4e09-45df-909f-dc7583346628/image.png\" />\n위 사진과 같이 3306 포트를, IPv4 모든 아이피(0.0.0.0/0)에 대해 허용해 주고, <code>규칙 저장</code>을 클릭한다.</p>\n<h4 id=\"퍼블릭-엑세스-설정-확인\">퍼블릭 엑세스 설정 확인</h4>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/8d61781b-b726-4ce7-b10e-07ec95998513/image.png\" /></p>\n<p>생성한 RDS 데이터베이스의 수정 페이지에 접근하면, 위와 같은 설정 페이지가 표시된다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/8733eb8a-9b60-43f2-a1db-99ba6b604e82/image.png\" /></p>\n<p><code>연결 - 추가 구성 - 퍼블릭 엑세스</code>에서 <code>퍼블릭 엑세스 가능</code>으로 설정해 준다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/4cdeecd7-69f7-4033-8469-8997b3fe8bfc/image.png\" /></p>\n<p>+: 수정된 사항을 저장할 때 <code>수정 예약</code> 섹션이 있는데, <code>예약된 다음 유지 관리 기간에 적용</code>을 선택하면 지금 바로 저장되지 않고, 현재 유지 관리 기간에 적혀있는 기간에 설정이 수정되니 <code>즉시 적용</code>을 선택해 바로 수정해 준다.</p>\n<h3 id=\"하지만\">하지만</h3>\n<p>하지만, 이래도 나는 외부에서 AWS RDS에서 생성한 데이터베이스에 접속할 수 없었다. RDS에서 데이터베이스를 생성할 때의 설정 화면이 업데이트되었는지 설정을 놓친 것 같기도 하다. 그래서 검색을 통해 문제점을 알아냈다. RDS에 설정되어 있는 서브넷이 private으로 되어 있어서, AWS 내부에서만 접근할 수 있어서 외부에서 접근할 수 없었던 것이다. 이제 이걸 해결하려면 public으로 변경해 주면 된다.</p>\n<h3 id=\"해결하기\">해결하기</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/1d020a3c-b2fc-4e32-88eb-5d5dbdcbb090/image.png\" /></p>\n<p>AWS 콘솔의 검색에서 <code>라우팅 테이블</code>을 검색해서 라우팅 설정 페이지에 들어가던가, <code>Vitual private cloud - Route tables</code> 메뉴로 들어가면 된다. 나는 RDS에 설정되어 있는 라우팅 테이블의 이름이 <code>RDS-Pvt-rt</code> 인데, 각자마다 다르니 RDS에 설정되어 있는 라우팅 테이블을 찾아 클릭한다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/0be5af3e-2d9d-4899-ac83-614c7971062e/image.png\" /></p>\n<p>그러면 위와 같이 아래에 라우팅 설정이 표시되는데, <code>라우팅 편집</code> 메뉴를 클릭한다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/da049322-cd79-4295-8363-23ba1e1c301a/image.png\" /></p>\n<p>위와 같이 <code>0.0.0.0/0</code> 전체 아이피에 대해 허용하고, 대상은 <code>인터넷 게이트웨이</code>를 선택한다. 아래 이름은 자동으로 채워진다. 수정을 완료했다면, <code>변경사항 저장</code> 버튼을 클릭해 완료한다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/d00cc613-827a-4d28-8ab0-9ee45eacf594/image.png\" /></p>\n<p>그러면 엔드포인트와 포트, 설정한 사용자 이름, 비밀번호를 이용해 데이터베이스에 접속해 보면 위와 같이 정상적으로 접근하는 것을 확인할 수 있다!</p>",
		"date": "Oct 16, 2023",
		"writer": "11기 전윤환"
	},
	"feed-58": {
		"title": "CI/CD란 무엇일까?",
		"link": "https://velog.io/@yunh03/CICD%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C",
		"description": "<h3 id=\"들어가며\">들어가며</h3>\n<p>지난 해커톤, 배포로 인한 많은 불편과.. 걱정을 겪고 Docker를 이용한 배포 방법과 GitHub Actions를 이용한 자동화 배포를 진행하는 방법을 열심히 공부하면서 마침내 CI/CD 구축을 완료하였다. 간단히 설명하자면 <code>develop</code> 브런치에서 테스트가 완료된 커밋들을 PR을 통해 <code>main</code> 브런치에 머지 작업을 완료하면 자동으로 빌드가 진행되며, 도커 이미지를 만들고 Ubuntu 서버에 배포하는 작업을 자동화하였다. 그래서 일단 구현은 했고, CI/CD가 어떤 의미, 개념을 가지고 있는지 알아보고 싶기 때문에 이 글을 작성하게 되었다.</p>\n<h3 id=\"cicontinuous-integration\">CI(Continuous Integration)</h3>\n<blockquote>\n<p>빌드, 테스트의 자동화</p>\n</blockquote>\n<p>CI/CD에서 CI는 Continuous Integration의 줄임말로, 지속적 통합을 의미한다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/50459ac3-a5c2-4416-b948-e27daf1e6183/image.png\" />\n개발을 진행할 때 충돌의 위험과 여러가지 이유의 위험성을 덜기 위해 각각의 branch를 나누고, 본인의 branch 안에서 작업하게 되는데, 충돌의 위험을 덜기 위해 자주 PR(Pull Request)과 Merge를 진행하다. CI/CD에서 CI도 어떤 자동화의 일종인 줄 알았지만, 이런 사람이 하는 행위 자체가 CI인 것이다.</p>\n<p>정리하자면, 작업을 할 때마다 자주 PR(Pull Request)과 Merge를 하는 이런 행위 자체가 CI라는 것이다.</p>\n<h3 id=\"cdcontinuous-deployment\">CD(Continuous Deployment)</h3>\n<blockquote>\n<p>배포의 자동화</p>\n</blockquote>\n<p>CI/CD에서 CD는 Continuous Deployment의 줄임말로, 지속적인 배포를 의미한다. CI와 다르게 CD는 명확하게 이해할 수 있다.</p>\n<p>개발을 하다 보면, 새로운 API를 개발하거나 기존의 API의 오류 수정 등의 이슈가 자주 일어나기 마련이다. 새로운 API를 개발하여 배포만 한다면 자동화 배포가 구현되어 있지 않아도 그렇게 큰 불편함은 없지만, 만일 중대한 API 오류 같은 문제점이 있다면 끊임없이, 바로바로 패치를 해주어야 한다.</p>\n<p>배포하는 과정이 까다롭고, 오래걸리기에 어플리케이션이 자동으로 이 배포 과정을 수행하여 최종적으로 서버에 배포를 완료하는 것이다. 이 과정을 CD(Continuous Deployment)라고 한다.</p>",
		"date": "Oct 15, 2023",
		"writer": "11기 전윤환"
	},
	"feed-59": {
		"title": "Cookie, Session, Token(JWT) 정리하기",
		"link": "https://velog.io/@yunh03/Cookie-Session-TokenJWT-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0",
		"description": "<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/c5ee5ccb-df63-4fbf-aa59-3385c13f6f53/image.png\" />\n프로젝트를 진행하면서 백엔드(Spring Boot)에서는 유효 기간이 존재하는 접근 토큰을 발급하고, React에서는 그 토큰을 받아 클라이언트의 localStorage에 저장하여 특정 행위를 할 때 사용자임을 인증하는 방식으로 JWT 방법을 사용했었는데, 사용을 하기만 할 뿐 개념이나 쿠키, 세션 방식과의 차이점은 정확히 이해하지 못 했다. 이 글에서는 사용자 인증 방식 중 쿠키, 세션, 토큰 방식의 차이점에 대해 이해하고 공부하면서 정리한 것들을 적어보려 한다.</p>\n<h3 id=\"http의-특성\">HTTP의 특성</h3>\n<blockquote>\n<p>HTTP: 인터넷 상에서 데이터를 주고 받기 위해 서버 또는 클라이언트 모델을 따르는 프로토콜</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/90fb5be2-38ab-455b-bde6-c31d929313ec/image.jpg\" />\nHTTP는 위 사진과 같이 서버로 데이터 요청을 하자마자 연결을 끊어버리기 때문에 상태 정보나 통신 상태 같은 정보가 클라이언트에게 남아있지 않다. HTTP는 그림과 아래 내용과 같이 2가지 특성을 가지고 있다.</p>\n<ol>\n<li>비연결성</li>\n<li>무상태성</li>\n</ol>\n<p>비연결성의 장점은 서버의 불필요한 자원 낭비를 줄일 수 있다는 것이다. 트래픽이 계속해서 발생되는 것이 아닌 일회성 요청으로 끝나기 때문이다. 이와 같은 장점 반면에, 일회성으로 요청하고 끝나기 때문에 <strong>클라이언트를 식별할 수 없다는 것</strong>이다. 그래서 웬만한 웹 페이지에서는 로그인과 회원가입 기능이 필수적으로 존재하는데, 비연결성 때문에 클라이언트 식별이 불가능해져 사용자 인증이 불가능한 것이다.</p>\n<p>이와 같은 단점(?)을 해결하기 위해 우리는 Session(세션)과 Cookie(쿠키)를 사용한다.</p>\n<h3 id=\"session세션\">Session(세션)</h3>\n<h4 id=\"세션-인증\">세션 인증</h4>\n<p>세션은 사용자의 인증 정보를 Cookie에 저장하는 것이 아닌, 서버에 저장하고 관리한다. 대략적인 세션의 흐름을 보면 아래 이미지와 같다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/e698cdce-1a28-446f-ad44-eb38f98dfca3/image.jpg\" /></p>\n<h4 id=\"장점\">장점</h4>\n<ol>\n<li>클라이언트의 웹 브라우저에 의존하지 않아도 됨.</li>\n<li>요청이 외부에 노출되더라도, 민감 정보가 포함되지 않음.</li>\n<li>요청이 들어올 때마다 사용자 정보를 확인하지 않아도 됨.</li>\n</ol>\n<h4 id=\"단점\">단점</h4>\n<ol>\n<li>해커가 중간에 sessionId를 탈취하여 위장할 수 있음.</li>\n<li>세션을 생성해 메모리에 저장하기 때문에 사용자가 많아지면 서버에 부하가 생길 수 있음.</li>\n</ol>\n<h3 id=\"cookie쿠키\">Cookie(쿠키)</h3>\n<h4 id=\"쿠키-인증\">쿠키 인증</h4>\n<p>쿠키는 웹 서버가 생성하여 웹 브라우저로 전송하는 작은 정보 파일이다. 웹 브라우저는 수신한 쿠키를 미리 정해진 기간 동안 또는 웹 사이트에서의 사용자 세션 기간 동안 저장한다. 클라이언트에서 서버에 요청을 보낼 때 쿠키의 정보를 헤더에 함께 추가하여 서버에서는 쿠키의 정보로 사용자를 구분할 수 있다.</p>\n<h4 id=\"장점-1\">장점</h4>\n<ol>\n<li>별도 인증 과정을 거치지 않고 서버에서 사용자를 구별할 수 있다.</li>\n</ol>\n<h4 id=\"단점-1\">단점</h4>\n<ol>\n<li>보안에 매우 취약하다. 요청 시 쿠키에 포함된 민감 정보를 보내기 때문에, 중간에 해커가 탈취하게 될 경우 유출될 수 있는 위험도가 크다.</li>\n<li>브라우저 마다 쿠키에 대해 지원 형태가 다르다.</li>\n<li>쿠키에 저장된 정보가 많아질 수록, 부하가 심해진다.</li>\n<li>저장할 수 있는 쿠키 파일의 크기가 한정되어 있다.</li>\n</ol>\n<h3 id=\"jwtjson-web-token\">JWT(JSON Web Token)</h3>\n<h4 id=\"토큰-기반-인증-jwtjson-web-token\">토큰 기반 인증 JWT(JSON Web Token)</h4>\n<p>JWT(JSON Web Token)은 사용자 인증에 필요한 정보를 암호화 시킨 토큰이다. 이 방식도 Session과 Cookie 방식과 동일하게 헤더에 Token을 포함해 요청을 보낸다. JWT는 Header, Payload, Signature 3가지를 <code>.</code>으로 구분해 조합하여 생성된다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/1d496853-502d-46b9-9dc4-6ea350b4665a/image.jpg\" /></p>\n<h4 id=\"header\">Header</h4>\n<p>Header 부분에는 아래 2가지 내용이 포함된다.</p>\n<ol>\n<li>서명 알고리즘(SHA256, RSA)</li>\n<li>사용된 토큰의 타입<pre><code>{\n &quot;alg&quot;: &quot;SHA256&quot;,\n &quot;typ&quot;: &quot;JWT&quot;\n}</code></pre></li>\n</ol>\n<h4 id=\"payload\">Payload</h4>\n<p>Payload 부분에는 실제로 토큰에 담길 사용자의 정보가 담겨있다. 주로 클라이언트의 아이디와 유효 기간 등이 담겨있다. 아래 정보는 Base64Url로 인코딩된다.</p>\n<pre><code>{\n  &quot;sub&quot;: &quot;1234567890&quot;,\n  &quot;name&quot;: &quot;John Doe&quot;,\n  &quot;admin&quot;: true\n}</code></pre><h4 id=\"signature\">Signature</h4>\n<p>Signature은 인코딩된 Header와 Payload를 합친 뒤, 비밀 키로 암호화하여 생성된다. Header와 Payload는 단순히 인코딩 된 값에 불과하기에 해커가 정보를 빼나갈 수 있지만, Signature의 경우에는 서버에서 관리하고 제공하는 비밀 키가 없으면 복호화가 불가능하다. 그래서 Signature은 토큰의 위변조 여부를 확인한다.</p>\n<pre><code>HMACSHA256(\n  base64UrlEncode(header) + &quot;.&quot; +\n  base64UrlEncode(payload),\n  secret123)</code></pre><h4 id=\"jwt-인증-과정\">JWT 인증 과정</h4>\n<ol>\n<li>클라이언트에서 로그인 요청이 들어오면, 서버에서는 로그인 요청이 유효한지 확인 후 클라이언트 고유 ID 등의 정보를 Payload에 저장한다.</li>\n<li>암호화 할 Secret Key를 사용하여 암호화 한 뒤 클라이언트에게 JWT(JSON Web Token)를 제공한다.</li>\n<li>클라이언트 측에서는 발급 받은 토큰을 API 요청을 할 때마다 Header(Authorization)에 포함시켜 요청한다.</li>\n<li>서버는 반환 값을 제공하기 전, 전달 받은 토큰을 Secret Key로 복호화하여 토큰이 유효한지 먼저 확인한다.</li>\n<li>토큰이 유효하다면, 요청에 응답한다.</li>\n</ol>\n<h4 id=\"장점-2\">장점</h4>\n<ol>\n<li>Header와 Payload를 통해 Signature을 생성하기 떄문에 토큰의 위변조 위험도가 적다.</li>\n<li>Session 방식과 다르게 별도의 저장 공간이나 메모리가 필요하지 않다.</li>\n<li>확장성이 좋다.</li>\n</ol>\n<h4 id=\"단점-2\">단점</h4>\n<ol>\n<li>Session 방식과 Cookie 방식과 달리 토큰의 길이가 길기 때문에 많은 요청이 발생할 경우 네트워크 부하가 심해질 수 있다.</li>\n<li>토큰이 만료되기 이전에는 특정 사용자의 접속을 강제로 차단할 수 없다. 그렇다고 토큰의 유효 기간을 짧게 설정하면 재로그인이 필요한 주기가 짧아져 사용자의 불편을 야기할 수 있다.</li>\n</ol>\n<h4 id=\"refresh-token\">Refresh Token</h4>\n<p>유효 기간이 비교적 짧은 Access Token의 불편함 보완을 위해 Refresh Token을 사용한다. Refresh Token은 Access Token의 재발급을 도와주기 때문에 유효 기간이 더 길다. (대략 1-2주)</p>\n<p>즉, Access Token은 사용자 인증 과정에 실질적으로 사용되는 토큰이고 Refresh Token은 이 Access Token의 재발급을 도와주기 때문에 사용자가 잦은 재로그인을 경험하지 않도록 해준다.</p>\n<p>Refresh Token을 관리하는 방법에는 여러가지가 있지만, 데이터베이스에 Refresh Token 값을 저장하고, 비교하여 유효성이 검증된다면 Access Token을 발급한다. 만일 Refresh Token 까지도 만료되었다면, 어쩔 수 없이 재로그인이 필요하다.</p>\n<p>JWT의 장점 부분에서 Session과 다르게 별도의 저장 공간이나 메모리가 필요하지 않다고 언급하였는데, Refresh Token을 사용하게 되면 어쩔 수 없이 추가 공간이 필요해진다.</p>\n<hr />\n<h3 id=\"결론\">결론</h3>\n<p>최근 Cookie나 Session 방식 보다 토큰 인증 방식으로 JWT를 많이 이용하고 있다. &quot;반드시 JWT를 써야해!&quot;는 아니지만, 각각의 서비스에 맞는 방식을 선택하여 사용하면 좋을 것 같다.</p>",
		"date": "Oct 13, 2023",
		"writer": "11기 전윤환"
	},
	"feed-60": {
		"title": "'Spring Boot + React' 카카오 소셜 로그인 도입하기 (2)",
		"link": "https://velog.io/@yunh03/Spring-Boot-React-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-2",
		"description": "<p><a href=\"https://velog.io/@yunh03/Spring-Boot-React-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-1\">지난 글</a>에 이어서 이번 글에서는 Spring Boot에서 카카오 소셜 로그인을 위해 어떤 작업을 해야하는지에 대해 적어보려 한다. Spring Boot에서 카카오 소셜 로그인을 구현하려면 아래와 같은 간단한 과정만 구현하면 된다.</p>\n<ol>\n<li>프론트엔드에서 전달받은 인가코드로, 접근 토큰 받아오기 (카카오 API 사용)</li>\n<li>접근 토큰으로 카카오 계정 정보 불러오기 (카카오 API 사용)</li>\n<li>불러온 카카오 계정 정보로 우리 서비스 회원에 등록하기</li>\n</ol>\n<p>위 과정에서 2번까지만 구현한다면, 3번의 과정은 기존 JWT를 이용한 회원가입 과정과 동일하다.</p>\n<h3 id=\"인가코드로-접근-토큰-받아오기\">인가코드로 접근 토큰 받아오기</h3>\n<p>프론트엔드에서 <a href=\"https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-code\">인가코드를 받아올 수 있는 카카오 로그인 API</a>를 사용해서 백엔드로 인가코드를 넘겨주었다면, 우리는 받은 인가코드로 접근 토큰을 받아오는 API를 먼저 사용한다. 인가코드로는 카카오 계정에서의 정보를 불러올 수 없고, 접근 토큰을 받아야 카카오 계정에서의 정보를 가져올 수 있기 때문이다. 인가코드로 접근 토큰을 받아오는 API에 관한 문서는 <a href=\"https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-token\">여기</a>에서 확인할 수 있다.</p>\n<p>문서를 확인해 보면 아래와 같은 요청이 필요한 것을 알 수 있다. 필수가 아닌 요청 값은 보내줄 필요가 없고, 필수인 값들만 보내주면 된다.</p>\n<ol>\n<li><code>https://kauth.kakao.com/oauth/token</code> 에 <code>POST</code> 요청</li>\n<li>Header: <code>Content-type: application/x-www-form-urlencoded;charset=utf-8</code></li>\n<li>Parameter: <code>grant_type</code>에 <code>authorization_code</code></li>\n<li>Parameter: <code>client_id</code>에 카카오 개발자 센터에서 등록한 앱의 클라이언트 ID 값</li>\n<li>Parameter: <code>redirect_uri</code>에 카카오 로그인 성공 다음 리다이렉트 될 URL 주소</li>\n<li>Parameter: <code>code</code>에 프론트엔드에서 전달받은 인가코드</li>\n</ol>\n<blockquote>\n<p>여기서 주의할 점은 위 내용 중 하나라도 등록된 정보와 일치하지 않거나, 올바르지 않은 값으로 요청한다면 접근 토큰을 받아올 수 없다.</p>\n</blockquote>\n<p>위 내용을 코드로 구현하면 아래와 같다.</p>\n<p><em>SignServiceImpl.java</em></p>\n<pre><code>public String createKakaoToken(String code) throws IOException, InterruptedException {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(&quot;https://kauth.kakao.com/oauth/token&quot;))\n                .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n                .POST(HttpRequest.BodyPublishers.ofString(\n                        &quot;grant_type=&quot; + &quot;authorization_code&quot; +\n                                &quot;&amp;client_id=&quot; + kakaoClientId +\n                                &quot;&amp;redirect_uri=&quot; + kakaoRedirectUri +\n                                &quot;&amp;code=&quot; + code\n                ))\n                .build();\n\n        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        JSONObject jsonObject = new JSONObject(response.body());\n\n        return jsonObject.getString(&quot;access_token&quot;);\n    }</code></pre><p><em>SignController.java</em></p>\n<pre><code>@PostMapping(value = &quot;/social/kakao&quot;)\n    public ResponseEntity&lt;SignInResultDto&gt; kakaoLogin(@RequestParam String code) throws IOException, InterruptedException {\n        return ResponseEntity.ok(signService.kakaoLogin(code));\n    }</code></pre><p><code>/social/kakao</code> 주소로 POST 요청을 보낼 때 파라미터 값으로 인가코드를 넘겨주면, <code>createKakaoToken</code>은 카카오 로그인 API를 호출해서 접근 토큰만 빼내와 값을 반환한다.</p>\n<h3 id=\"접근-토큰으로-카카오-계정-정보-불러오기\">접근 토큰으로 카카오 계정 정보 불러오기</h3>\n<p>이제 인가 코드로 접근 토큰을 가져왔다면, 접근 토큰으로 카카오 계정 정보를 불러올 수 있다. 설정에 따라 불러올 수 있는 값은 달라지는데, 필자는 아래 3가지 정보를 사용자에게 요청했다. 만약 아래 3가지 정보보다 더 필요하다면, Postman이나 API 요청을 보낼 수 있는 툴을 이용해 API 요청을 보내서 JSON 값을 확인하고 아래 코드에서 추가해 사용하면 된다.</p>\n<ol>\n<li>이름(닉네임)</li>\n<li>이메일 주소</li>\n<li>프로필 사진</li>\n</ol>\n<p><a href=\"https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info\">접근 토큰으로 카카오 계정 정보를 불러오는 API의 문서</a>를 확인해 보면, 아래와 같은 요청이 필요한 것을 확인할 수 있다.</p>\n<ol>\n<li><code>https://kapi.kakao.com/v2/user/me</code> 에 <code>POST</code> 또는 <code>GET</code> 요청</li>\n<li>Header: <code>Content-type: application/x-www-form-urlencoded;charset=utf-8</code></li>\n<li>Header: <code>Authorization: Bearer ${ACCESS_TOKEN}</code></li>\n</ol>\n<blockquote>\n<p>이 API도 마찬가지로, 접근 토큰이 유효하지 않으면 정보를 불러올 수 없다.</p>\n</blockquote>\n<p>위 내용을 코드로 구현하면 아래와 같다.</p>\n<p><em>SignServiceImpl.java</em></p>\n<pre><code>public KakaoUser getKakaoInfo(String accessToken) throws IOException, InterruptedException {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(&quot;https://kapi.kakao.com/v2/user/me&quot;))\n                .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded;charset=utf-8&quot;)\n                .header(&quot;Authorization&quot;, &quot;Bearer &quot; + accessToken)\n                .build();\n\n        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        JSONObject jsonObject = new JSONObject(response.body());\n\n        JSONObject kakao_account = jsonObject.getJSONObject(&quot;kakao_account&quot;);\n        JSONObject profile = kakao_account.getJSONObject(&quot;profile&quot;);\n\n        KakaoUser kakaoUser = new KakaoUser();\n        kakaoUser.setEmail(kakao_account.getString(&quot;email&quot;));\n        kakaoUser.setNickname(profile.getString(&quot;nickname&quot;));\n        kakaoUser.setProfileImageUrl(profile.getString(&quot;profile_image_url&quot;));\n\n        return kakaoUser;\n    }</code></pre><p><em>KakaoUser.java</em></p>\n<pre><code>public class KakaoUser {\n    private String profileImageUrl;\n    private String nickname;\n    private String email;\n}</code></pre><p>불러온 접근 토큰과 헤더 설정으로 API에 요청을 보낸 값을 <code>KakaoUser</code>라는 객체에 저장하고, <code>KakaoUser</code> 객체를 반환하는 코드다. <code>KakaoUser</code>라는 객체에는 이메일과 닉네임, 프로필 사진 URL을 주입할 수 있다.</p>\n<h3 id=\"불러온-카카오-계정-정보로-서비스-회원에-등록하기\">불러온 카카오 계정 정보로 서비스 회원에 등록하기</h3>\n<p><em>SignServiceImpl.java</em></p>\n<pre><code>public String getRandomPwd() {\n        String CHAR_LOWER = &quot;abcdefghijklmnopqrstuvwxyz&quot;;\n        String CHAR_UPPER = CHAR_LOWER.toUpperCase();\n        String NUMBER = &quot;0123456789&quot;;\n\n        String DATA_FOR_RANDOM_STRING = CHAR_LOWER + CHAR_UPPER + NUMBER;\n        SecureRandom random = new SecureRandom();\n\n        StringBuilder sb = new StringBuilder(16);\n        for (int i = 0; i &lt; 16; i++) {\n            int rndCharAt = random.nextInt(DATA_FOR_RANDOM_STRING.length());\n            char rndChar = DATA_FOR_RANDOM_STRING.charAt(rndCharAt);\n\n            sb.append(rndChar);\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public SignInResultDto kakaoLogin(String code) throws RuntimeException, IOException, InterruptedException {\n        String kakaoUserToken = createKakaoToken(code);\n        KakaoUser kakaoUser = getKakaoInfo(kakaoUserToken);\n\n//        카카오톡 로그인 시, 이미 가입된 회원이라면\n        if(userRepository.getByUid(kakaoUser.getEmail()) != null) {\n            User user = userRepository.getByUid(kakaoUser.getEmail());\n\n            user.setRecentLoggedIn(LocalDateTime.now());\n            userRepository.save(user);\n\n            SignInResultDto signInResultDto = SignInResultDto.builder()\n                    .token(jwtTokenProvider.createAccessToken(String.valueOf(user.getUid()), user.getRoles()))\n                    .refreshToken(jwtTokenProvider.createRefreshToken(String.valueOf(user.getUid())))\n                    .uid(user.getUid())\n                    .name(user.getName())\n                    .build();\n\n            setSuccessResult(signInResultDto);\n\n            return signInResultDto;\n        } else {\n//            카카오 프로필 이미지를 가져올 수 없을 때, 서비스 기본 프로필 사용\n            if(kakaoUser.getProfileImageUrl() == null) {\n                kakaoUser.setProfileImageUrl(DEFAULT_PROFILE);\n            }\n\n            if(kakaoUser.getEmail() == null || kakaoUser.getNickname() == null) {\n                throw new RuntimeException(&quot;카카오 정보에서 이메일 또는 닉네임을 가져올 수 없습니다&quot;);\n            }\n\n            User user = User.builder()\n                    .uid(kakaoUser.getEmail())\n                    .name(kakaoUser.getNickname())\n                    .createdAt(LocalDateTime.now())\n                    .useAble(true)\n                    .registerType(RegisterType.KAKAO)\n                    .profileUrl(kakaoUser.getProfileImageUrl())\n                    .password(passwordEncoder.encode(getRandomPassword()))\n                    .roles(Collections.singletonList(&quot;ROLE_USER&quot;))\n                    .build();\n\n            if(!validateUid(user.getUid())) {\n                throw new RuntimeException(&quot;이메일 주소 형식이 아닙니다.&quot;);\n            } else if(userRepository.getByUid(kakaoUser.getEmail()) != null) {\n                throw new RuntimeException(&quot;이미 존재하는 회원입니다.&quot;);\n            } else {\n                userRepository.save(user);\n            }\n\n//            회원가입 후 로그인 정보 반환\n            SignInResultDto signInResultDto = SignInResultDto.builder()\n                    .token(jwtTokenProvider.createAccessToken(String.valueOf(user.getUid()), user.getRoles()))\n                    .refreshToken(jwtTokenProvider.createRefreshToken(String.valueOf(user.getUid())))\n                    .uid(user.getUid())\n                    .name(user.getName())\n                    .build();\n\n            setSuccessResult(signInResultDto);\n\n            return signInResultDto;\n        }\n    }</code></pre><p>기존 JWT를 활용한 회원가입 방식과 같다. 약간의 특이사항이 있다면, 소셜 로그인을 할 때에는 보통 비밀번호를 입력하지 않기 때문에 비밀번호에 입력할 값이 없는데, <code>getRandomPassword</code> 함수를 따로 만들어 주어, 영어와 숫자를 섞어 랜덤으로 16자리 비밀번호를 생성해 비밀번호를 설정해 주었다. 어차피 소셜 로그인을 진행할 때에는 비밀번호를 입력하지 않고, 로그인 시에 이메일만 일치하는지 확인하기 때문에 비밀번호는 중요하지 않다.</p>\n<hr />\n<p>이렇게 카카오 로그인을 실제 코드로 구현하는 과정에 대해 적어보았다. 다른 소셜 로그인도 이 카카오 로그인 방식과 동일하게 활용하면 좋을 것 같다. 아직 카카오만 해보고 구글이나 네이버는 안 해봐서 나중에 시도해 보고 또 적어보려 한다.</p>",
		"date": "Oct 10, 2023",
		"writer": "11기 전윤환"
	},
	"feed-61": {
		"title": "'Spring Boot + React' 카카오 소셜 로그인 도입하기 (1)",
		"link": "https://velog.io/@yunh03/Spring-Boot-React-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-1",
		"description": "<p>해커톤에서 진행하던 프로젝트를 이어서 개발하고 있는데, 소셜 로그인을 구현하기로 계획했다. 소셜 로그인 같은 경우에는 처음 개발해 보기 때문에 어떤 과정으로 개발을 해야하는지 처음에는 이해가 잘 되지 않았다. 그래서 정리도 할 겸,, 백엔드는 Spring Boot, 프론트엔드는 React를 사용하고 로그인 방식은 JWT 인증 방식을 사용하는 과정에서 카카오 소셜 로그인을 구현한 방법에 대해 적어보려 한다.</p>\n<blockquote>\n<p>Spring Boot: 2.5.6\nJava 11, JDK 11</p>\n</blockquote>\n<h3 id=\"flow-이해하기\">Flow 이해하기</h3>\n<p><img alt=\"https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-code-info\" src=\"https://velog.velcdn.com/images/yunh03/post/686a99f6-cf01-40a9-9e0d-82173a43766c/image.png\" />\n처음에 카카오 소셜 로그인을 도입하기 위해서 Kakao Developer에서 확인했던 사진이다. 지금 보면 어떤 과정을 이야기하는 것인지 이해할 수 있지만 카카오 소셜 로그인을 완성하기 전까지는 이해하기 어려웠다. 심지어 카카오 로그인만 이용하는 것이 아닌 자체 서비스의 로그인 기능도 있었기 때문에 자체 서비스 로그인 토큰을 발급하게 하고 싶었기 때문이다.</p>\n<p>또한, 프론트엔드에서 할 일과 백엔드에서 해야 할 일을 정확하게 구분지을 수 없어서 더더욱 헷갈렸다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/5fc97d0e-2ac5-4c6d-b3b3-0f03034f3cbf/image.jpeg\" />\n그래서 많은 검색을 하고 질문을 하고 카카오 소셜 로그인을 구현한 후 정리한 과정은 위 사진과 같고 간략하게 정리하면 다음과 같다.</p>\n<blockquote>\n<ol>\n<li>프론트엔드에서 인가코드 발급 API를 사용하여 인가코드를 백엔드에 전달한다.</li>\n<li>백엔드는 받은 인가코드로 토큰을 발급받는다.</li>\n<li>발급 받은 토큰으로 사용자 정보 API를 사용하여 카카오 사용자 정보를 추출한다.</li>\n<li>추출한 사용자 정보로 우리 서비스의 회원에 등록한다.</li>\n<li>원래 서비스에 로그인하는 방식과 동일하게 Access Token을 프론트엔드에 전달한다.</li>\n<li>프론트엔드에서는 원래와 같이 Access Token으로 로그인 과정을 진행한다.</li>\n</ol>\n</blockquote>\n<p>위 과정에서 4번부터는 일반 JWT를 이용한 로그인 과정과 동일하기 때문에 어렵지 않게 개발할 수 있었고 1<del>3번 과정을 알아내는데 시간이 조금 걸렸다. ~</del>지금 보면 쉬운데..~~</p>\n<p>이 다음 글에서는 카카오 로그인 API를 백엔드에서 사용하는 방법과 사용자 등록 과정에 대해 더 자세히 적어보려한다.</p>",
		"date": "Sep 27, 2023",
		"writer": "11기 전윤환"
	},
	"feed-62": {
		"title": "2023 멋쟁이사자처럼 대학 11기 해커톤 후기",
		"link": "https://velog.io/@yunh03/2023-%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC-%EB%8C%80%ED%95%99-11%EA%B8%B0-%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9B%84%EA%B8%B0",
		"description": "<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/73c63577-7a13-4df0-a455-9a1ac00a92e6/image.jpeg\" /></p>\n<h3 id=\"20230717-해커톤-주제-발표\">2023.07.17 해커톤 주제 발표</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/0a6b1f8b-b1eb-4350-9e7a-f6f58d8a091a/image.png\" /></p>\n<p>해커톤 1달 전 7월 17일에 해커톤의 주제가 발표됐다. 주제는 '디지털 격차' 였는데, 사실 바로 든 생각이 디지털 격차를.. 어떻게 디지털로 해결할까라는 생각이었다. 하지만 문제가 있었다. 디지털 격차는 노인 분들께만 적용된다라는 안일한 생각이었다. 젊은 우리가 키오스크를 사용할 때도 어려움을 느끼는 것도 디지털 격차이고 AI를 사용할 줄 아는 사람, 모르는 사람도 디지털 격차의 범주에 포함되는 것이었다. 그래서 생각을 조금 바꿔 아이디어를 다시 생각했다.</p>\n<h3 id=\"해커톤-주제-결정\">해커톤 주제 결정</h3>\n<p>해커톤 주제는 팀원들과 Notion으로 의논했다. 이커머스, 소셜미디어, 공공 서비스, 블록체인 서비스의 4가지 주제에 대한 아이디어를 최소 1가지씩 생각하여 작성했다. 처음 결정한 아이디어는 '출발지부터 도착지까지의 가장 빠른 대중교통 경로 찾기'였지만 길 찾기 앱이었다. 하지만, 아이디어에서 독창성이 조금 부족할 뿐만 아니라, 네이버 지도나 카카오맵처럼 특출난 기능이 없었기에 다른 아이디어를 생각해 보기로 결정했다. 그 이후 어르신을 위한 쉬운 배달 어플, 모든 웹 페이지에 적용 가능한 인증 서비스, 디지털 격차를 해결할 수 있는 어플 소개 서비스, 디지털 기기 재활용 및 기부 플랫폼 등 여러가지 아이디어가 나왔지만, 결론적으로 최종 결정된 아이디어는 블록체인이 더해진 '모의 주식' 서비스였다.</p>\n<p>서비스 대상은 청소년으로, 주식에 접근하기 어렵고 계좌 개설이 어려운 청소년을 위해 블록체인을 이용한 가상의 코인으로 실제 주식을 거래할 수 있는 서비스이다.</p>\n<h3 id=\"프로덕트-개발\">프로덕트 개발</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/6432043b-379a-49ae-a5b4-d700001695dc/image.png\" /></p>\n<p>디자이너 1명, 프론트엔드 2명, 백엔드 3명으로 이 프로젝트를 개발하기로 결정했다.</p>\n<blockquote>\n<p>Design: Figma, Adobe Illustrator XD\nFront-end: React\nBack-End: Spring Boot, MariaDB\nDeploy: Naver Cloud Platform</p>\n</blockquote>\n<p>Spring Boot를 시작한 지 5개월 채 되지 않아 블록체인과 실시간 주식 거래를 하기 위한 웹 소켓, 웹 페이지 크롤링 등 어떻게 개발할 지 막막했지만, 쉬운 것부터 차근차근 빨리 개발을 마치고 나머지 남는 시간은 웹 소켓이나 블록체인에 힘을 썼다.</p>\n<h3 id=\"멋쟁이사자처럼-대학-11기-해커톤\">멋쟁이사자처럼 대학 11기 해커톤</h3>\n<p>8월 18일 오후 2시부터 8월 19일 오전 7시까지 '양재 aT센터'에서 멋쟁이사자처럼 대학 11기의 마지막 행사, 해커톤을 진행했다. 이 동아리에 들어온지 5개월채 되지 않았는데 벌써 동아리의 오피셜 활동 중 하나인 해커톤에 참가하니 시간이 너무 빠름이 느껴졌다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/372d3e4c-d713-4485-a905-85423cb893f6/image.jpeg\" /></p>\n<p>행사장에 도착하고 체크인을 진행할 때 멋쟁이사자처럼, 협찬사 WEMADE 스티커와, 해커톤 티셔츠를 받았다. XL와 2XL 사이즈가 있었는데, 처음에 받을 때 너무 큰 것 같다고 말씀드렸더니 M 정도 입으면 2XL 정도 해도 충분하다고 하셔서 받고 입어봤는데 조금 오버핏이긴 하지만 딱 맞았다. 티셔츠 디자인도 밖에서 입어도 괜찮을 정도로 이뻤고 퀄리티도 너무 좋아서 놀랐다. 그리고 사진에 화장품이랑 사진에 없는 음료수도 받았는데 음료수는 먹어버렸고 화장품은 행사장 안에 있는 부스를 체험했을 때 받을 수 있었다. 아기사자 인원 수 만큼 준비되어서 이벤트 참여도 선착순이 아니라 널널해서 좋았다.</p>\n<h3 id=\"개회식-1700--1800\">개회식 (17:00 ~ 18:00)</h3>\n<p>협찬사 소개와 멋쟁이사자처럼 대표 이두희 대표님의 개회사와 함께 해커톤의 시작을 알렸다. 사실 이 때 우리 팀에서 준비한 프로덕트 개발이 조금 남았어서 마무리 하느라 거의 안 듣고.. 사진만 찍었다. 그리고 6시부터 7시까지는 저녁식사 시간이었는데 저녁 식사는 제공해 준다고 했지만 김밥 한 줄만 제공을 해주고 중앙 디스코드 채널에서 이의가 많이 들어와 배달음식 허용으로 변경해 주어 우리는 일단 김밥 한 줄을 대충 먹고 프로덕트 개발이랑 제출이 끝나고 배달음식을 먹기로 결정했다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/705a5def-7c08-466d-843e-a79ce390a4e2/image.jpeg\" /></p>\n<h3 id=\"발표-자료-제작-및-제출-1900--2400\">발표 자료 제작 및 제출 (19:00 ~ 24:00)</h3>\n<p>사실.. 이 파트는 프로덕트 제작 &amp; 배포 시간이라고 봐도 무방할 정도로.. 정말 너무 많이 바빴다. 백엔드 파트를 맡아 개발했는데, 해커톤 3일 전에 개발이 모두 끝나서 프론트엔드 파트를 기다리고 있는 상황이었는데, 프론트엔드에서 API 연결을 하면 오류가 생겨 로직을 수정해야 하는 일이 번번히 발생하여 쉴 수 있는 시간이 거의 없었다. 그리고 더 중요한 것은 <strong>진짜 제출을 못 할 뻔 했다..</strong></p>\n<p>프론트엔드 개발이 완료되고 원래하던 식으로 배포를 마쳤는데, 내 맥북에서는 돌아가지만 다른 팀원들의 노트북으로 접속했을 때 4명은 접속이 안 되고.. 1명만 접속이 되는 불상사가 발생했다. 웹 서비스로 개발을 진행했는데.. 웹 페이지에 접속이 안 되면 결론은 안 한 것이나 마찬가지여서 이거 때문에 정말 울 뻔했다.. SSL 인증서 오류 때문임을 알고 부랴부랴 SSL 인증서를 삭제하고 원래 방식으로 배포하여 보안 인증서 없이 배포했다. 일단 이 부분은 나중에 배포 방식을 다시 공부하기로 했다..</p>\n<h3 id=\"심사위원-소개-예선-심사-이벤트-진행-0000--0400--본선-진출자-발표-심사-진행-0400--0500--시상식-및-폐회사-0500--0600\">심사위원 소개, 예선 심사, 이벤트 진행 (00:00 ~ 04:00) / 본선 진출자 발표, 심사 진행 (04:00 ~ 05:00) / 시상식 및 폐회사 (05:00 ~ 06:00)</h3>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/a733e5a3-24a4-4b30-85e8-988051932caa/image.jpeg\" /></p>\n<p>배포를 마치고, 배달 음식으로 미친 듯이 뛰는 심장과 허기를 조금 달랜 뒤, 자정에 심사위원 소개, 예선 심사, 이벤트 진행 시간을 가졌다. 심사위원 분들께서는 이번에 '멋쟁이사자처럼 대학 11기 해커톤'에 협찬해 주신 분들과 멋쟁이사자처럼 대표님 뿐만 아니라 다른 회사 대표님들이셨다. 이벤트를 진행하는 동안에 심사위원 분들께서는 전체 몇 백 팀 중 본선에 진출할 8팀을 선발한다. 이벤트는 수도권 대학 학생과 아닌 학생들과의 교류를 활성화하기 위한 네트워킹 자리라고 생각하면 될 것 같다. 그룹 별로 학교가 묶여있는데, 그룹 별로 돌아다니며 인사하고 빙고..? 같은 게임을 하는 것이였다.</p>\n<p>이벤트가 끝나고, 본선 진출할 팀을 발표하는 시간이였는데, 본선 진출한 팀을 한 번에 공지한 다음 발표를 순서대로 진행하는 것인 줄 알았는데, 1팀을 공개하고 바로 발표.. 이런 식으로 진행되었다. 발표 시간은 3분. 솔직히 아쉬운 점이라면 본선에 진출한 팀들은 정말 너무 좋은 프로덕트를 소개해 좋았긴 했지만, 제한된 발표 시간으로 인하여 시연 영상 등 프로덕트에 대한 자세한 내용을 볼 수 없었기에 아쉬움이 남았다.</p>\n<h3 id=\"멋쟁이사자처럼-대학-11기-해커톤이-끝나고\">멋쟁이사자처럼 대학 11기 해커톤이 끝나고</h3>\n<p>해커톤 행사장에 가기 전, 배포가 잘 되었고, 내 맥북에서 뿐만 아닌 다른 팀원들의 컴퓨터에서도 배포된 웹 페이지에 접속이 잘 되는지 확인을 하고 배포 작업을 완벽히 준비해야 했었는데, 행사장에서 배포로 애를 먹을 지는 꿈에도 몰랐다. Spring Boot와 React를 동시에 배포하는 것은 바람직한 방법은 아니라고 인터넷에서 글을 많이 봐왔지만, 해커톤 행사장에서 내가 다른 배포 방식에 대해 아무것도 모르는데 그 당시에 방법을 바로 바꿀 시간 조차 충분하지 않아 어쩔 수 없기도 했다. 이후 지금은 Docker를 사용하여 Spring Boot와 React를 분리하여 배포하는 방법을 공부하고 있고, GitHub Actions를 이용한 자동화 또한 공부하고 있다. 시간이 허락한다면 해커톤 프로젝트를 준비하면서 마주한 수많은 에러들과, 고치는 방법 또한 앞으로 Velog에 정리하여 공유하고 싶다.</p>\n<p>Spring Boot를 배운지 약 5개월 정도가 지났고, 팀 프로젝트도 태어나 처음 해봐서 많은 부족함이 있었을 텐데, 함께 도와준 팀원 덕분에 무사히 '멋쟁이사자처럼 대학 11기 해커톤' 행사를 마칠 수 있었다. 해커톤 프로젝트를 진행하면서 수많은 오류들과 문제 상황을 마주한 덕분에 엄청난 성장을 겪은 것 같고, 다양한 사람들과 함께 프로젝트를 진행하면서 협업 방식, 소통 방식을 더 공부해 보고 싶다. <del>내가 하고 싶은 얘기들을 다 썼는지 모르겠지만.. 일단 끝..</del></p>",
		"date": "Aug 22, 2023",
		"writer": "11기 전윤환"
	},
	"feed-63": {
		"title": "macOS에서 Docker \"Permission denied\" 해결하기",
		"link": "https://velog.io/@yunh03/macOS%EC%97%90%EC%84%9C-Docker-Permission-denied-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0",
		"description": "<pre><code>ERROR: open /Users/yunhwan/.docker/buildx/activity/desktop-linux: permission denied macos</code></pre><p>Docker 이미지 빌드 중에 위와 같은 에러가 표시됐다. 이 전에 할 때는 저런 권한 문제가 나타나지 않았는데, 갑자기 나타나서 당황스러웠지만, 아래 StackOverflow 질문을 참고하니 권한 문제 없이 잘 실행됐다.</p>\n<p><a href=\"https://stackoverflow.com/questions/75686903/open-users-user-docker-buildx-current-permission-denied-on-macbook\">https://stackoverflow.com/questions/75686903/open-users-user-docker-buildx-current-permission-denied-on-macbook</a></p>\n<pre><code>sudo chown -R $(whoami) ~/.docker</code></pre>",
		"date": "Aug 21, 2023",
		"writer": "11기 전윤환"
	},
	"feed-64": {
		"title": "리눅스에서 FTP 연결 없이 터미널로 서버에 파일 전송하기",
		"link": "https://velog.io/@yunh03/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-FTP-%EC%97%B0%EA%B2%B0-%EC%97%86%EC%9D%B4-%ED%84%B0%EB%AF%B8%EB%84%90%EB%A1%9C-%EC%84%9C%EB%B2%84%EC%97%90-%ED%8C%8C%EC%9D%BC-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0",
		"description": "<h3 id=\"scp란\">SCP란?</h3>\n<p>SSH 원격 접속 프로토콜을 기반으로 한, Secure Copy의 약자로 원격지에 있는 파일과 디렉터리를 보내거나 가져올 때 사용하는 파일 전송 프로토콜</p>\n<h3 id=\"scp-사용의-장점\">SCP 사용의 장점</h3>\n<p>파일을 전송하려고 FTP 서버를 구축하지 않아도 될 뿐만 아니라, SSH와 동일한 22번 포트를 사용해 전송하기에, 보안도 뛰어나고, 디렉터리나 파일 전송이 간편합니다.</p>\n<h3 id=\"로컬local에서-remote원격지로-파일-전송하기\">로컬(Local)에서 Remote(원격지)로 파일 전송하기</h3>\n<pre><code>scp [전송 대상 파일 경로] [원격지 계정]@[IP]&quot;/[전송될 파일 경로]</code></pre><p>전송 대상 파일 경로가, <code>/Users/yunhwan/Desktop/test.jar</code>이고, 원격지 계정이 <code>root</code>, IP가 <code>127.0.0.1</code>이며, <code>test</code> 폴더에 전송하고 싶다면 아래와 같은 명령어가 완성됩니다.</p>\n<pre><code>scp /Users/yunhwan/Desktop/test.jar root@127.0.0.1:/test</code></pre><h3 id=\"scp-전체-명령어\">SCP 전체 명령어</h3>\n<pre><code>scp [옵션] [전송 대상 파일 경로] [원격지 계정]@[IP]:/[전송될 파일 경로]</code></pre><h3 id=\"scp-명령어에서-사용할-수-있는-옵션\">SCP 명령어에서 사용할 수 있는 옵션</h3>\n<ol>\n<li>-r: 디렉토리 내 모든 파일 및 디렉터리 복사</li>\n<li>-p: 원본 파일의 권한 및 속성을 유지하여 복사</li>\n<li>-P: 포트 번호 지정</li>\n<li>-c: 압축</li>\n<li>-v: 과정 출력</li>\n</ol>",
		"date": "Aug 04, 2023",
		"writer": "11기 전윤환"
	},
	"feed-65": {
		"title": "Spring Boot와 React간 개발 환경 연동",
		"link": "https://velog.io/@yunh03/Spring-Boot%EC%99%80-React%EA%B0%84-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%97%B0%EB%8F%99",
		"description": "<h3 id=\"궁금증\">궁금증</h3>\n<p>기존에는 웹 개발을 PHP의 프레임워크인 Laravel을 사용하여 개발하고 있었습니다. 하지만, '멋쟁이사자처럼 대학 11기' 동아리에 참여하면서 Spring Boot를 처음 접하게 되었는데, '나는 백엔드를 개발하고 API를 만들면, 대체 프론트엔드에서는 이걸 어떻게 활용하고, 같이 작업하는 걸까?' 라는 의문이 생겼습니다. 그래서 찾아본 결과, Spring Boot와 React를 연결할 수 있었고, 이를 이용해서 API를 요청, 반환하여 데이터를 주고 받는 방법을 사용하고 있다는 것에 대해 알게되었습니다.</p>\n<h3 id=\"작업-환경\">작업 환경</h3>\n<blockquote>\n<ul>\n<li>Java 11</li>\n</ul>\n</blockquote>\n<ul>\n<li>macOS Monterey 12.6</li>\n<li>Spring Boot 2.5.6</li>\n</ul>\n<h3 id=\"연결-과정\">연결 과정</h3>\n<ol>\n<li>Spring Boot 프로젝트 생성</li>\n<li>React 프로젝트 생성</li>\n<li>Spring Boot와 React 간 Proxy 설정</li>\n</ol>\n<h3 id=\"1-react-프로젝트-생성\">1. React 프로젝트 생성</h3>\n<p>터미널을 켜고, 'src/main' 폴더 아래에 'frontend' React 프로젝트를 설치해 줍니다.</p>\n<pre><code>cd src/main\nnpx create-react-app frontend</code></pre><p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/52fdd448-978b-41b1-a642-98db296fe39c/image.png\" /></p>\n<p>설치가 완료되었다면, 위와 같은 구조로 React 프로젝트 파일이 설치됩니다. 이 과정까지는 대략 2분정도 소요되었습니다.</p>\n<h3 id=\"2-react-실행하기\">2. React 실행하기</h3>\n<p>이제 React 프로젝트의 설정을 마쳤으니 실행해 볼까요? 'src/main/frontend' 폴더에서 리엑트 프로젝트를 실행해 주겠습니다.</p>\n<pre><code>cd src/main/frontend\nnpm start</code></pre><p>위 명령어를 실행하면, 리엑트 프로젝트가 실행되는 과정이 보이면서, &quot;<a href=\"http://localhost:3000&quot;\">http://localhost:3000&quot;</a> 웹 페이지가 자동으로 열립니다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/3160d671-2b65-4dfe-bd09-cfde92915f45/image.png\" />\n위 페이지가 보인다면, 성공입니다! 물론, 설치한 리엑트 버전에 따라 초기 페이지는 다를 수 있지만 페이지가 표시된다면, 리엑트 프로젝트가 잘 설치된 것입니다.</p>\n<h3 id=\"의문-및-해결\">의문 및 해결</h3>\n<p>그럼 여기서 이상한(?) 점이 보이시나요? React의 웹 페이지 접근 포트는 3000으로 되어 있어요. 하지만, Spring Boot의 접근 포트는 8080입니다. 이와 같이 만약, Spring Boot와 React가 같은 포트로 동작하지 않는다면, CORS 오류가 발생합니다. CORS 오류란, Cross Origin Resource Sharing, 다른 출처 리소스 공유 정책입니다. 간단히 말해서, 같은 도메인 및 서버에서 동작하고 있다면 서로 리소스를 공유하고 있지만, 다른 도메인에서 동작하고 있다면 서로 리소스를 공유할 수 없는 것입니다. 그렇기 때문에 Spring Boot와 React가 같은 포트에서 동작할 수 있도록, Proxy 설정을 해야합니다. </p>\n<h3 id=\"3-proxy-설정\">3. Proxy 설정</h3>\n<p>Proxy 설정에 사용되는 방법은 React 공식 문서에 나와 있는 방법입니다. 문서는 <a href=\"https://create-react-app.dev/docs/proxying-api-requests-in-development/\">https://create-react-app.dev/docs/proxying-api-requests-in-development/</a> 에서 확인할 수 있습니다.</p>\n<p>'src/main/frontend/package.json' 파일에 아래의 코드를 추가해 주세요.</p>\n<pre><code>...\n&quot;proxy&quot;: &quot;http://localhost:8080&quot;,\n...</code></pre><p>Spring Boot의 포트인 8080으로 프록시 설정을 완료했습니다.</p>\n<h3 id=\"4-테스트\">4. 테스트</h3>\n<p>프록시 설정을 완료했으니, 테스트도 한 번 해보아야겠죠? 'src/main/java/com.springboot.test/controller/'에 'TestController'을 생성해 주겠습니다. 그 후, &quot;Test&quot; 문자를 반환하는 초간단한 API를 하나 만들어 주겠습니다.</p>\n<pre><code>@RestController\npublic class TestController {\n    @GetMapping(&quot;/api/test&quot;)\n    public String test() {\n        return &quot;Test&quot;;\n    }\n}</code></pre><p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/15e71a2d-725d-49ea-8b9a-0075782e7126/image.png\" />\nSpring Boot 프로젝트를 실행하고, <a href=\"http://localhost:8080/api/test%EC%97%90\">http://localhost:8080/api/test에</a> 접속하면, 위와 같이 정상적으로 작동하는 것을 볼 수 있습니다.</p>\n<p>이제 리엑트에서도 이 API 사용이 가능해야 하기 때문에, 'src/main/frontend/src/App.js'에 아래 코드를 추가하여 실행해 보겠습니다.</p>\n<pre><code>import logo from './logo.svg';\nimport './App.css';\nimport {useEffect, useState} from &quot;react&quot;;\n\nfunction App() {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('/api/test');\n                const result = await response.text();\n                setData(result);\n            } catch (error) {\n                console.error('Error fetching data:', error);\n            }\n        };\n\n        fetchData();\n    }, []);\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;header className=&quot;App-header&quot;&gt;\n        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n        &lt;p&gt;\n          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.\n        &lt;/p&gt;\n        &lt;a\n          className=&quot;App-link&quot;\n          href=&quot;https://reactjs.org&quot;\n          target=&quot;_blank&quot;\n          rel=&quot;noopener noreferrer&quot;\n        &gt;\n          Learn React\n        &lt;/a&gt;\n          {data ? (\n              &lt;p&gt;\n                  {data}\n              &lt;/p&gt;\n          ) : (\n              &lt;p&gt;Loading data...&lt;/p&gt;\n          )}\n      &lt;/header&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;</code></pre><p>위 코드를 붙여넣고, 'src/main/frontend'에서 <code>npm start</code> 명령어를 사용하여 React 프로젝트의 서버도 실행시킵니다.</p>\n<blockquote>\n<p>이 때 주의해야 할 점은, Spring Boot의 프로젝트도 동작하는 상태이고, React 프로젝트도 동작하는 상태여야 정상적으로 실행됩니다.</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/c487d563-5509-434f-bf86-8905254f626c/image.png\" />\n<a href=\"http://localhost:3000\">http://localhost:3000</a> 페이지에 접속해 보면, 위와 같이 'Learn React' 아래에 테스트로 만들었던 API의 반환 값인 'Test'를 확인할 수 있고, 이를 통해 Spring Boot와 React 간 Proxy 설정이 완료되었음을 확인할 수 있습니다.</p>\n<h3 id=\"마지막으로\">마지막으로</h3>\n<p>동아리 때문에 React와 Spring Boot를 연결하는 방법에 대해 알아본 것도 맞지만, 개인적으로 토이 프로젝트를 만들 때 Thymeleaf를 사용하고 있었는데, 데이터를 주고 받기 복잡할 뿐더러 개발 시간도 더 많이 걸리는 것 같은 느낌이 들어 React를 사용하여 프론트엔드와 백엔드를 확실하게 구분하는 것이 좋다고 생각하여 꼭 한 번 정리하고 넘어가고 싶었습니다.</p>\n<p>React도 한 번 제대로 학습하고, 사용해서 프론트엔드, 백엔드 모든 파트를 대상으로 토이 프로젝트를 만들어보고 싶습니다.</p>",
		"date": "Jul 08, 2023",
		"writer": "11기 전윤환"
	},
	"feed-66": {
		"title": "Laravel Routing - 그룹화",
		"link": "https://velog.io/@yunh03/Laravel-Routing-%EA%B7%B8%EB%A3%B9%ED%99%94",
		"description": "<h1 id=\"problem\">Problem</h1>\n<p>Laravel에서 간단한 프로젝트를 만들던 도중, web.php에 라우팅된 여러가지 것들이 있는데, 중복되는 부분이 많아 그룹화 할 수 있는 방법이 없을까라는 의문이 생겼다. 문제의 부분은 아래와 같다.</p>\n<pre><code>(web.php 일부)\nRoute::get('/upload', [ExpressController::class, 'upload'])-&gt;name('upload.view');\nRoute::post('/upload', [ExpressController::class, 'post'])-&gt;name('upload');\nRoute::get('/{name}', [ExpressController::class, 'view'])-&gt;name('view');\nRoute::get('/', [ExpressController::class, 'view'])-&gt;name('view');\nRoute::get('/view/{postId}', [ExpressController::class, 'detail'])-&gt;name('detail');\n</code></pre><p>위와 같이 필자가 사용하는 ExpressController에 포함된 get, post들이 4개 정도인데, <code>[ExpressController::class, 'className']</code>이 중복으로 계속 사용되는 것을 볼 수 있다.</p>\n<h1 id=\"solution\">Solution</h1>\n<p>위와 같은 문제를 해결하기 위해 Laravel 공식 문서를 찾아보았는데, <a href=\"https://laravel.com/docs/9.x/routing\">Routing - Laravel</a>의 <code>Route Groups</code> 부분에 필자가 찾던 부분이 명시되어 있었다.</p>\n<p><img alt=\"\" src=\"https://velog.velcdn.com/images/yunh03/post/6209c644-3856-4e35-a840-1dcd4d354acc/image.png\" /></p>\n<p>위 문서를 보면, 모든 라우팅된 부분에 같은 컨트롤러를 사용한다면, 그룹화 할 수 있다는 내용이었다. 이 글의 처음 부분에 필자의 코드를 위 내용과 예제 코드를 토대로 정리한다면, 아래와 같이 정리할 수 있었다.</p>\n<pre><code>Route::controller(ExpressController::class)-&gt;group(function () {\n    Route::post('/upload', 'post')-&gt;name('upload');\n    Route::get('/upload', 'upload')-&gt;name('upload.view');\n    Route::post('/upload', 'upload')-&gt;name('upload');\n    Route::get('/{name}', 'view')-&gt;name('view');\n    Route::get('/', 'view')-&gt;name('view');\n    Route::get('/view/{postId}', 'detail')-&gt;name('detail');\n});</code></pre><h1 id=\"in-closing\">In closing</h1>\n<p>정리하자면, Laravel에서 라우팅을 하기 위해서는 web.php에 컨트롤러 등 여러가지 정의를 해 주어야 한다. 페이지 1개, 2개 정도를 컨트롤러를 포함해 라우팅할 때에는 그룹화를 굳이 하지 않아도 되지만, N개로 늘어난다면 그룹화를 통해 사용하는 컨트롤러에 따라 묶어주는 것이 유지보수에 편리하다. 예를 들자면, 저렇게 하나의 컨트롤러에 묶인 라우트의 개수가 10개 정도인데, 컨트롤러 이름이 바뀌는 상황이 된다면, 하나하나 바꿔줄 필요 없이, 그룹에 사용되는 컨트롤러의 이름 하나만 변경하면 되는 것이다. 또, 혼자 만드는 프로젝트가 아닌 불특정 다수와 협업하는 프로젝트라면 어떤 부분이 어떤 컨트롤러를 사용하는 지도 쉽게 파악할 수 있다.</p>",
		"date": "Feb 10, 2023",
		"writer": "11기 전윤환"
	}
}